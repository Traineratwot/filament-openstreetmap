var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all3) => {
  for (var name in all3)
    __defProp(target, name, { get: all3[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/ol/events/Event.js
function stopPropagation(evt) {
  evt.stopPropagation();
}
function preventDefault(evt) {
  evt.preventDefault();
}
var BaseEvent, Event_default;
var init_Event = __esm({
  "node_modules/ol/events/Event.js"() {
    BaseEvent = class {
      /**
       * @param {string} type Type.
       */
      constructor(type) {
        this.propagationStopped;
        this.defaultPrevented;
        this.type = type;
        this.target = null;
      }
      /**
       * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
       * will be fired.
       * @api
       */
      preventDefault() {
        this.defaultPrevented = true;
      }
      /**
       * Stop event propagation.
       * @api
       */
      stopPropagation() {
        this.propagationStopped = true;
      }
    };
    Event_default = BaseEvent;
  }
});

// node_modules/ol/ObjectEventType.js
var ObjectEventType_default;
var init_ObjectEventType = __esm({
  "node_modules/ol/ObjectEventType.js"() {
    ObjectEventType_default = {
      /**
       * Triggered when a property is changed.
       * @event module:ol/Object.ObjectEvent#propertychange
       * @api
       */
      PROPERTYCHANGE: "propertychange"
    };
  }
});

// node_modules/ol/Disposable.js
var Disposable, Disposable_default;
var init_Disposable = __esm({
  "node_modules/ol/Disposable.js"() {
    Disposable = class {
      constructor() {
        this.disposed = false;
      }
      /**
       * Clean up.
       */
      dispose() {
        if (!this.disposed) {
          this.disposed = true;
          this.disposeInternal();
        }
      }
      /**
       * Extension point for disposable objects.
       * @protected
       */
      disposeInternal() {
      }
    };
    Disposable_default = Disposable;
  }
});

// node_modules/ol/array.js
function binarySearch(haystack, needle, comparator) {
  let mid, cmp;
  comparator = comparator || ascending;
  let low = 0;
  let high = haystack.length;
  let found = false;
  while (low < high) {
    mid = low + (high - low >> 1);
    cmp = +comparator(haystack[mid], needle);
    if (cmp < 0) {
      low = mid + 1;
    } else {
      high = mid;
      found = !cmp;
    }
  }
  return found ? low : ~low;
}
function ascending(a, b) {
  return a > b ? 1 : a < b ? -1 : 0;
}
function descending(a, b) {
  return a < b ? 1 : a > b ? -1 : 0;
}
function linearFindNearest(arr, target, direction) {
  if (arr[0] <= target) {
    return 0;
  }
  const n = arr.length;
  if (target <= arr[n - 1]) {
    return n - 1;
  }
  if (typeof direction === "function") {
    for (let i = 1; i < n; ++i) {
      const candidate = arr[i];
      if (candidate === target) {
        return i;
      }
      if (candidate < target) {
        if (direction(target, arr[i - 1], candidate) > 0) {
          return i - 1;
        }
        return i;
      }
    }
    return n - 1;
  }
  if (direction > 0) {
    for (let i = 1; i < n; ++i) {
      if (arr[i] < target) {
        return i - 1;
      }
    }
    return n - 1;
  }
  if (direction < 0) {
    for (let i = 1; i < n; ++i) {
      if (arr[i] <= target) {
        return i;
      }
    }
    return n - 1;
  }
  for (let i = 1; i < n; ++i) {
    if (arr[i] == target) {
      return i;
    }
    if (arr[i] < target) {
      if (arr[i - 1] - target < target - arr[i]) {
        return i - 1;
      }
      return i;
    }
  }
  return n - 1;
}
function reverseSubArray(arr, begin, end) {
  while (begin < end) {
    const tmp = arr[begin];
    arr[begin] = arr[end];
    arr[end] = tmp;
    ++begin;
    --end;
  }
}
function extend(arr, data) {
  const extension = Array.isArray(data) ? data : [data];
  const length = extension.length;
  for (let i = 0; i < length; i++) {
    arr[arr.length] = extension[i];
  }
}
function remove(arr, obj) {
  const i = arr.indexOf(obj);
  const found = i > -1;
  if (found) {
    arr.splice(i, 1);
  }
  return found;
}
function equals(arr1, arr2) {
  const len1 = arr1.length;
  if (len1 !== arr2.length) {
    return false;
  }
  for (let i = 0; i < len1; i++) {
    if (arr1[i] !== arr2[i]) {
      return false;
    }
  }
  return true;
}
function stableSort(arr, compareFnc) {
  const length = arr.length;
  const tmp = Array(arr.length);
  let i;
  for (i = 0; i < length; i++) {
    tmp[i] = { index: i, value: arr[i] };
  }
  tmp.sort(function(a, b) {
    return compareFnc(a.value, b.value) || a.index - b.index;
  });
  for (i = 0; i < arr.length; i++) {
    arr[i] = tmp[i].value;
  }
}
function isSorted(arr, func, strict) {
  const compare = func || ascending;
  return arr.every(function(currentVal, index) {
    if (index === 0) {
      return true;
    }
    const res = compare(arr[index - 1], currentVal);
    return !(res > 0 || strict && res === 0);
  });
}
var init_array = __esm({
  "node_modules/ol/array.js"() {
  }
});

// node_modules/ol/functions.js
function TRUE() {
  return true;
}
function FALSE() {
  return false;
}
function VOID() {
}
function memoizeOne(fn) {
  let called = false;
  let lastResult;
  let lastArgs;
  let lastThis;
  return function() {
    const nextArgs = Array.prototype.slice.call(arguments);
    if (!called || this !== lastThis || !equals(nextArgs, lastArgs)) {
      called = true;
      lastThis = this;
      lastArgs = nextArgs;
      lastResult = fn.apply(this, arguments);
    }
    return lastResult;
  };
}
function toPromise(getter) {
  function promiseGetter() {
    let value;
    try {
      value = getter();
    } catch (err) {
      return Promise.reject(err);
    }
    if (value instanceof Promise) {
      return value;
    }
    return Promise.resolve(value);
  }
  return promiseGetter();
}
var init_functions = __esm({
  "node_modules/ol/functions.js"() {
    init_array();
  }
});

// node_modules/ol/obj.js
function clear(object) {
  for (const property in object) {
    delete object[property];
  }
}
function isEmpty(object) {
  let property;
  for (property in object) {
    return false;
  }
  return !property;
}
var init_obj = __esm({
  "node_modules/ol/obj.js"() {
  }
});

// node_modules/ol/events/Target.js
var Target, Target_default;
var init_Target = __esm({
  "node_modules/ol/events/Target.js"() {
    init_Disposable();
    init_Event();
    init_functions();
    init_obj();
    Target = class extends Disposable_default {
      /**
       * @param {*} [target] Default event target for dispatched events.
       */
      constructor(target) {
        super();
        this.eventTarget_ = target;
        this.pendingRemovals_ = null;
        this.dispatching_ = null;
        this.listeners_ = null;
      }
      /**
       * @param {string} type Type.
       * @param {import("../events.js").Listener} listener Listener.
       */
      addEventListener(type, listener) {
        if (!type || !listener) {
          return;
        }
        const listeners = this.listeners_ || (this.listeners_ = {});
        const listenersForType = listeners[type] || (listeners[type] = []);
        if (!listenersForType.includes(listener)) {
          listenersForType.push(listener);
        }
      }
      /**
       * Dispatches an event and calls all listeners listening for events
       * of this type. The event parameter can either be a string or an
       * Object with a `type` property.
       *
       * @param {import("./Event.js").default|string} event Event object.
       * @return {boolean|undefined} `false` if anyone called preventDefault on the
       *     event object or if any of the listeners returned false.
       * @api
       */
      dispatchEvent(event) {
        const isString = typeof event === "string";
        const type = isString ? event : event.type;
        const listeners = this.listeners_ && this.listeners_[type];
        if (!listeners) {
          return;
        }
        const evt = isString ? new Event_default(event) : (
          /** @type {Event} */
          event
        );
        if (!evt.target) {
          evt.target = this.eventTarget_ || this;
        }
        const dispatching = this.dispatching_ || (this.dispatching_ = {});
        const pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
        if (!(type in dispatching)) {
          dispatching[type] = 0;
          pendingRemovals[type] = 0;
        }
        ++dispatching[type];
        let propagate;
        for (let i = 0, ii = listeners.length; i < ii; ++i) {
          if ("handleEvent" in listeners[i]) {
            propagate = /** @type {import("../events.js").ListenerObject} */
            listeners[i].handleEvent(evt);
          } else {
            propagate = /** @type {import("../events.js").ListenerFunction} */
            listeners[i].call(this, evt);
          }
          if (propagate === false || evt.propagationStopped) {
            propagate = false;
            break;
          }
        }
        if (--dispatching[type] === 0) {
          let pr = pendingRemovals[type];
          delete pendingRemovals[type];
          while (pr--) {
            this.removeEventListener(type, VOID);
          }
          delete dispatching[type];
        }
        return propagate;
      }
      /**
       * Clean up.
       */
      disposeInternal() {
        this.listeners_ && clear(this.listeners_);
      }
      /**
       * Get the listeners for a specified event type. Listeners are returned in the
       * order that they will be called in.
       *
       * @param {string} type Type.
       * @return {Array<import("../events.js").Listener>|undefined} Listeners.
       */
      getListeners(type) {
        return this.listeners_ && this.listeners_[type] || void 0;
      }
      /**
       * @param {string} [type] Type. If not provided,
       *     `true` will be returned if this event target has any listeners.
       * @return {boolean} Has listeners.
       */
      hasListener(type) {
        if (!this.listeners_) {
          return false;
        }
        return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;
      }
      /**
       * @param {string} type Type.
       * @param {import("../events.js").Listener} listener Listener.
       */
      removeEventListener(type, listener) {
        if (!this.listeners_) {
          return;
        }
        const listeners = this.listeners_[type];
        if (!listeners) {
          return;
        }
        const index = listeners.indexOf(listener);
        if (index !== -1) {
          if (this.pendingRemovals_ && type in this.pendingRemovals_) {
            listeners[index] = VOID;
            ++this.pendingRemovals_[type];
          } else {
            listeners.splice(index, 1);
            if (listeners.length === 0) {
              delete this.listeners_[type];
            }
          }
        }
      }
    };
    Target_default = Target;
  }
});

// node_modules/ol/events/EventType.js
var EventType_default;
var init_EventType = __esm({
  "node_modules/ol/events/EventType.js"() {
    EventType_default = {
      /**
       * Generic change event. Triggered when the revision counter is increased.
       * @event module:ol/events/Event~BaseEvent#change
       * @api
       */
      CHANGE: "change",
      /**
       * Generic error event. Triggered when an error occurs.
       * @event module:ol/events/Event~BaseEvent#error
       * @api
       */
      ERROR: "error",
      BLUR: "blur",
      CLEAR: "clear",
      CONTEXTMENU: "contextmenu",
      CLICK: "click",
      DBLCLICK: "dblclick",
      DRAGENTER: "dragenter",
      DRAGOVER: "dragover",
      DROP: "drop",
      FOCUS: "focus",
      KEYDOWN: "keydown",
      KEYPRESS: "keypress",
      LOAD: "load",
      RESIZE: "resize",
      TOUCHMOVE: "touchmove",
      WHEEL: "wheel"
    };
  }
});

// node_modules/ol/events.js
function listen(target, type, listener, thisArg, once) {
  if (thisArg && thisArg !== target) {
    listener = listener.bind(thisArg);
  }
  if (once) {
    const originalListener = listener;
    listener = function() {
      target.removeEventListener(type, listener);
      originalListener.apply(this, arguments);
    };
  }
  const eventsKey = {
    target,
    type,
    listener
  };
  target.addEventListener(type, listener);
  return eventsKey;
}
function listenOnce(target, type, listener, thisArg) {
  return listen(target, type, listener, thisArg, true);
}
function unlistenByKey(key) {
  if (key && key.target) {
    key.target.removeEventListener(key.type, key.listener);
    clear(key);
  }
}
var init_events = __esm({
  "node_modules/ol/events.js"() {
    init_obj();
  }
});

// node_modules/ol/Observable.js
function unByKey(key) {
  if (Array.isArray(key)) {
    for (let i = 0, ii = key.length; i < ii; ++i) {
      unlistenByKey(key[i]);
    }
  } else {
    unlistenByKey(
      /** @type {import("./events.js").EventsKey} */
      key
    );
  }
}
var Observable, Observable_default;
var init_Observable = __esm({
  "node_modules/ol/Observable.js"() {
    init_Target();
    init_EventType();
    init_events();
    Observable = class extends Target_default {
      constructor() {
        super();
        this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
        this.onInternal;
        this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
        this.onceInternal;
        this.un = /** @type {ObservableOnSignature<void>} */
        this.unInternal;
        this.revision_ = 0;
      }
      /**
       * Increases the revision counter and dispatches a 'change' event.
       * @api
       */
      changed() {
        ++this.revision_;
        this.dispatchEvent(EventType_default.CHANGE);
      }
      /**
       * Get the version number for this object.  Each time the object is modified,
       * its version number will be incremented.
       * @return {number} Revision.
       * @api
       */
      getRevision() {
        return this.revision_;
      }
      /**
       * @param {string|Array<string>} type Type.
       * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
       * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
       * @protected
       */
      onInternal(type, listener) {
        if (Array.isArray(type)) {
          const len = type.length;
          const keys = new Array(len);
          for (let i = 0; i < len; ++i) {
            keys[i] = listen(this, type[i], listener);
          }
          return keys;
        }
        return listen(
          this,
          /** @type {string} */
          type,
          listener
        );
      }
      /**
       * @param {string|Array<string>} type Type.
       * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
       * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
       * @protected
       */
      onceInternal(type, listener) {
        let key;
        if (Array.isArray(type)) {
          const len = type.length;
          key = new Array(len);
          for (let i = 0; i < len; ++i) {
            key[i] = listenOnce(this, type[i], listener);
          }
        } else {
          key = listenOnce(
            this,
            /** @type {string} */
            type,
            listener
          );
        }
        listener.ol_key = key;
        return key;
      }
      /**
       * Unlisten for a certain type of event.
       * @param {string|Array<string>} type Type.
       * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
       * @protected
       */
      unInternal(type, listener) {
        const key = (
          /** @type {Object} */
          listener.ol_key
        );
        if (key) {
          unByKey(key);
        } else if (Array.isArray(type)) {
          for (let i = 0, ii = type.length; i < ii; ++i) {
            this.removeEventListener(type[i], listener);
          }
        } else {
          this.removeEventListener(type, listener);
        }
      }
    };
    Observable.prototype.on;
    Observable.prototype.once;
    Observable.prototype.un;
    Observable_default = Observable;
  }
});

// node_modules/ol/util.js
function abstract() {
  throw new Error("Unimplemented abstract method.");
}
function getUid(obj) {
  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
}
var uidCounter_, VERSION;
var init_util = __esm({
  "node_modules/ol/util.js"() {
    uidCounter_ = 0;
    VERSION = "8.2.0";
  }
});

// node_modules/ol/Object.js
var ObjectEvent, BaseObject, Object_default;
var init_Object = __esm({
  "node_modules/ol/Object.js"() {
    init_Event();
    init_ObjectEventType();
    init_Observable();
    init_util();
    init_obj();
    ObjectEvent = class extends Event_default {
      /**
       * @param {string} type The event type.
       * @param {string} key The property name.
       * @param {*} oldValue The old value for `key`.
       */
      constructor(type, key, oldValue) {
        super(type);
        this.key = key;
        this.oldValue = oldValue;
      }
    };
    BaseObject = class extends Observable_default {
      /**
       * @param {Object<string, *>} [values] An object with key-value pairs.
       */
      constructor(values) {
        super();
        this.on;
        this.once;
        this.un;
        getUid(this);
        this.values_ = null;
        if (values !== void 0) {
          this.setProperties(values);
        }
      }
      /**
       * Gets a value.
       * @param {string} key Key name.
       * @return {*} Value.
       * @api
       */
      get(key) {
        let value;
        if (this.values_ && this.values_.hasOwnProperty(key)) {
          value = this.values_[key];
        }
        return value;
      }
      /**
       * Get a list of object property names.
       * @return {Array<string>} List of property names.
       * @api
       */
      getKeys() {
        return this.values_ && Object.keys(this.values_) || [];
      }
      /**
       * Get an object of all property names and values.
       * @return {Object<string, *>} Object.
       * @api
       */
      getProperties() {
        return this.values_ && Object.assign({}, this.values_) || {};
      }
      /**
       * Get an object of all property names and values.
       * @return {Object<string, *>?} Object.
       */
      getPropertiesInternal() {
        return this.values_;
      }
      /**
       * @return {boolean} The object has properties.
       */
      hasProperties() {
        return !!this.values_;
      }
      /**
       * @param {string} key Key name.
       * @param {*} oldValue Old value.
       */
      notify(key, oldValue) {
        let eventType;
        eventType = `change:${key}`;
        if (this.hasListener(eventType)) {
          this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
        }
        eventType = ObjectEventType_default.PROPERTYCHANGE;
        if (this.hasListener(eventType)) {
          this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
        }
      }
      /**
       * @param {string} key Key name.
       * @param {import("./events.js").Listener} listener Listener.
       */
      addChangeListener(key, listener) {
        this.addEventListener(`change:${key}`, listener);
      }
      /**
       * @param {string} key Key name.
       * @param {import("./events.js").Listener} listener Listener.
       */
      removeChangeListener(key, listener) {
        this.removeEventListener(`change:${key}`, listener);
      }
      /**
       * Sets a value.
       * @param {string} key Key name.
       * @param {*} value Value.
       * @param {boolean} [silent] Update without triggering an event.
       * @api
       */
      set(key, value, silent) {
        const values = this.values_ || (this.values_ = {});
        if (silent) {
          values[key] = value;
        } else {
          const oldValue = values[key];
          values[key] = value;
          if (oldValue !== value) {
            this.notify(key, oldValue);
          }
        }
      }
      /**
       * Sets a collection of key-value pairs.  Note that this changes any existing
       * properties and adds new ones (it does not remove any existing properties).
       * @param {Object<string, *>} values Values.
       * @param {boolean} [silent] Update without triggering an event.
       * @api
       */
      setProperties(values, silent) {
        for (const key in values) {
          this.set(key, values[key], silent);
        }
      }
      /**
       * Apply any properties from another object without triggering events.
       * @param {BaseObject} source The source object.
       * @protected
       */
      applyProperties(source) {
        if (!source.values_) {
          return;
        }
        Object.assign(this.values_ || (this.values_ = {}), source.values_);
      }
      /**
       * Unsets a property.
       * @param {string} key Key name.
       * @param {boolean} [silent] Unset without triggering an event.
       * @api
       */
      unset(key, silent) {
        if (this.values_ && key in this.values_) {
          const oldValue = this.values_[key];
          delete this.values_[key];
          if (isEmpty(this.values_)) {
            this.values_ = null;
          }
          if (!silent) {
            this.notify(key, oldValue);
          }
        }
      }
    };
    Object_default = BaseObject;
  }
});

// node_modules/ol/CollectionEventType.js
var CollectionEventType_default;
var init_CollectionEventType = __esm({
  "node_modules/ol/CollectionEventType.js"() {
    CollectionEventType_default = {
      /**
       * Triggered when an item is added to the collection.
       * @event module:ol/Collection.CollectionEvent#add
       * @api
       */
      ADD: "add",
      /**
       * Triggered when an item is removed from the collection.
       * @event module:ol/Collection.CollectionEvent#remove
       * @api
       */
      REMOVE: "remove"
    };
  }
});

// node_modules/ol/Collection.js
var Property, CollectionEvent, Collection, Collection_default;
var init_Collection = __esm({
  "node_modules/ol/Collection.js"() {
    init_Object();
    init_CollectionEventType();
    init_Event();
    Property = {
      LENGTH: "length"
    };
    CollectionEvent = class extends Event_default {
      /**
       * @param {import("./CollectionEventType.js").default} type Type.
       * @param {T} element Element.
       * @param {number} index The index of the added or removed element.
       */
      constructor(type, element, index) {
        super(type);
        this.element = element;
        this.index = index;
      }
    };
    Collection = class extends Object_default {
      /**
       * @param {Array<T>} [array] Array.
       * @param {Options} [options] Collection options.
       */
      constructor(array, options) {
        super();
        this.on;
        this.once;
        this.un;
        options = options || {};
        this.unique_ = !!options.unique;
        this.array_ = array ? array : [];
        if (this.unique_) {
          for (let i = 0, ii = this.array_.length; i < ii; ++i) {
            this.assertUnique_(this.array_[i], i);
          }
        }
        this.updateLength_();
      }
      /**
       * Remove all elements from the collection.
       * @api
       */
      clear() {
        while (this.getLength() > 0) {
          this.pop();
        }
      }
      /**
       * Add elements to the collection.  This pushes each item in the provided array
       * to the end of the collection.
       * @param {!Array<T>} arr Array.
       * @return {Collection<T>} This collection.
       * @api
       */
      extend(arr) {
        for (let i = 0, ii = arr.length; i < ii; ++i) {
          this.push(arr[i]);
        }
        return this;
      }
      /**
       * Iterate over each element, calling the provided callback.
       * @param {function(T, number, Array<T>): *} f The function to call
       *     for every element. This function takes 3 arguments (the element, the
       *     index and the array). The return value is ignored.
       * @api
       */
      forEach(f) {
        const array = this.array_;
        for (let i = 0, ii = array.length; i < ii; ++i) {
          f(array[i], i, array);
        }
      }
      /**
       * Get a reference to the underlying Array object. Warning: if the array
       * is mutated, no events will be dispatched by the collection, and the
       * collection's "length" property won't be in sync with the actual length
       * of the array.
       * @return {!Array<T>} Array.
       * @api
       */
      getArray() {
        return this.array_;
      }
      /**
       * Get the element at the provided index.
       * @param {number} index Index.
       * @return {T} Element.
       * @api
       */
      item(index) {
        return this.array_[index];
      }
      /**
       * Get the length of this collection.
       * @return {number} The length of the array.
       * @observable
       * @api
       */
      getLength() {
        return this.get(Property.LENGTH);
      }
      /**
       * Insert an element at the provided index.
       * @param {number} index Index.
       * @param {T} elem Element.
       * @api
       */
      insertAt(index, elem) {
        if (index < 0 || index > this.getLength()) {
          throw new Error("Index out of bounds: " + index);
        }
        if (this.unique_) {
          this.assertUnique_(elem);
        }
        this.array_.splice(index, 0, elem);
        this.updateLength_();
        this.dispatchEvent(
          new CollectionEvent(CollectionEventType_default.ADD, elem, index)
        );
      }
      /**
       * Remove the last element of the collection and return it.
       * Return `undefined` if the collection is empty.
       * @return {T|undefined} Element.
       * @api
       */
      pop() {
        return this.removeAt(this.getLength() - 1);
      }
      /**
       * Insert the provided element at the end of the collection.
       * @param {T} elem Element.
       * @return {number} New length of the collection.
       * @api
       */
      push(elem) {
        if (this.unique_) {
          this.assertUnique_(elem);
        }
        const n = this.getLength();
        this.insertAt(n, elem);
        return this.getLength();
      }
      /**
       * Remove the first occurrence of an element from the collection.
       * @param {T} elem Element.
       * @return {T|undefined} The removed element or undefined if none found.
       * @api
       */
      remove(elem) {
        const arr = this.array_;
        for (let i = 0, ii = arr.length; i < ii; ++i) {
          if (arr[i] === elem) {
            return this.removeAt(i);
          }
        }
        return void 0;
      }
      /**
       * Remove the element at the provided index and return it.
       * Return `undefined` if the collection does not contain this index.
       * @param {number} index Index.
       * @return {T|undefined} Value.
       * @api
       */
      removeAt(index) {
        if (index < 0 || index >= this.getLength()) {
          return void 0;
        }
        const prev = this.array_[index];
        this.array_.splice(index, 1);
        this.updateLength_();
        this.dispatchEvent(
          /** @type {CollectionEvent<T>} */
          new CollectionEvent(CollectionEventType_default.REMOVE, prev, index)
        );
        return prev;
      }
      /**
       * Set the element at the provided index.
       * @param {number} index Index.
       * @param {T} elem Element.
       * @api
       */
      setAt(index, elem) {
        const n = this.getLength();
        if (index >= n) {
          this.insertAt(index, elem);
          return;
        }
        if (index < 0) {
          throw new Error("Index out of bounds: " + index);
        }
        if (this.unique_) {
          this.assertUnique_(elem, index);
        }
        const prev = this.array_[index];
        this.array_[index] = elem;
        this.dispatchEvent(
          /** @type {CollectionEvent<T>} */
          new CollectionEvent(CollectionEventType_default.REMOVE, prev, index)
        );
        this.dispatchEvent(
          /** @type {CollectionEvent<T>} */
          new CollectionEvent(CollectionEventType_default.ADD, elem, index)
        );
      }
      /**
       * @private
       */
      updateLength_() {
        this.set(Property.LENGTH, this.array_.length);
      }
      /**
       * @private
       * @param {T} elem Element.
       * @param {number} [except] Optional index to ignore.
       */
      assertUnique_(elem, except) {
        for (let i = 0, ii = this.array_.length; i < ii; ++i) {
          if (this.array_[i] === elem && i !== except) {
            throw new Error("Duplicate item added to a unique collection");
          }
        }
      }
    };
    Collection_default = Collection;
  }
});

// node_modules/ol/has.js
var ua, FIREFOX, SAFARI, SAFARI_BUG_237906, WEBKIT, MAC, DEVICE_PIXEL_RATIO, WORKER_OFFSCREEN_CANVAS, IMAGE_DECODE, CREATE_IMAGE_BITMAP, PASSIVE_EVENT_LISTENERS;
var init_has = __esm({
  "node_modules/ol/has.js"() {
    ua = typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined" ? navigator.userAgent.toLowerCase() : "";
    FIREFOX = ua.includes("firefox");
    SAFARI = ua.includes("safari") && !ua.includes("chrom");
    SAFARI_BUG_237906 = SAFARI && (ua.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(ua));
    WEBKIT = ua.includes("webkit") && !ua.includes("edge");
    MAC = ua.includes("macintosh");
    DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== "undefined" ? devicePixelRatio : 1;
    WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== "undefined" && typeof OffscreenCanvas !== "undefined" && self instanceof WorkerGlobalScope;
    IMAGE_DECODE = typeof Image !== "undefined" && Image.prototype.decode;
    CREATE_IMAGE_BITMAP = typeof createImageBitmap === "function";
    PASSIVE_EVENT_LISTENERS = function() {
      let passive = false;
      try {
        const options = Object.defineProperty({}, "passive", {
          get: function() {
            passive = true;
          }
        });
        window.addEventListener("_", null, options);
        window.removeEventListener("_", null, options);
      } catch (error2) {
      }
      return passive;
    }();
  }
});

// node_modules/ol/asserts.js
function assert(assertion, errorMessage) {
  if (!assertion) {
    throw new Error(errorMessage);
  }
}
var init_asserts = __esm({
  "node_modules/ol/asserts.js"() {
  }
});

// node_modules/ol/transform.js
function create() {
  return [1, 0, 0, 1, 0, 0];
}
function reset(transform2) {
  return set(transform2, 1, 0, 0, 1, 0, 0);
}
function multiply(transform1, transform2) {
  const a1 = transform1[0];
  const b1 = transform1[1];
  const c1 = transform1[2];
  const d1 = transform1[3];
  const e1 = transform1[4];
  const f1 = transform1[5];
  const a2 = transform2[0];
  const b2 = transform2[1];
  const c2 = transform2[2];
  const d2 = transform2[3];
  const e2 = transform2[4];
  const f2 = transform2[5];
  transform1[0] = a1 * a2 + c1 * b2;
  transform1[1] = b1 * a2 + d1 * b2;
  transform1[2] = a1 * c2 + c1 * d2;
  transform1[3] = b1 * c2 + d1 * d2;
  transform1[4] = a1 * e2 + c1 * f2 + e1;
  transform1[5] = b1 * e2 + d1 * f2 + f1;
  return transform1;
}
function set(transform2, a, b, c, d, e, f) {
  transform2[0] = a;
  transform2[1] = b;
  transform2[2] = c;
  transform2[3] = d;
  transform2[4] = e;
  transform2[5] = f;
  return transform2;
}
function setFromArray(transform1, transform2) {
  transform1[0] = transform2[0];
  transform1[1] = transform2[1];
  transform1[2] = transform2[2];
  transform1[3] = transform2[3];
  transform1[4] = transform2[4];
  transform1[5] = transform2[5];
  return transform1;
}
function apply(transform2, coordinate) {
  const x = coordinate[0];
  const y = coordinate[1];
  coordinate[0] = transform2[0] * x + transform2[2] * y + transform2[4];
  coordinate[1] = transform2[1] * x + transform2[3] * y + transform2[5];
  return coordinate;
}
function rotate(transform2, angle) {
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  return multiply(transform2, set(tmp_, cos, sin, -sin, cos, 0, 0));
}
function scale(transform2, x, y) {
  return multiply(transform2, set(tmp_, x, 0, 0, y, 0, 0));
}
function makeScale(target, x, y) {
  return set(target, x, 0, 0, y, 0, 0);
}
function translate(transform2, dx, dy) {
  return multiply(transform2, set(tmp_, 1, 0, 0, 1, dx, dy));
}
function compose(transform2, dx1, dy1, sx, sy, angle, dx2, dy2) {
  const sin = Math.sin(angle);
  const cos = Math.cos(angle);
  transform2[0] = sx * cos;
  transform2[1] = sy * sin;
  transform2[2] = -sx * sin;
  transform2[3] = sy * cos;
  transform2[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
  transform2[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
  return transform2;
}
function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {
  return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));
}
function invert(source) {
  return makeInverse(source, source);
}
function makeInverse(target, source) {
  const det = determinant(source);
  assert(det !== 0, "Transformation matrix cannot be inverted");
  const a = source[0];
  const b = source[1];
  const c = source[2];
  const d = source[3];
  const e = source[4];
  const f = source[5];
  target[0] = d / det;
  target[1] = -b / det;
  target[2] = -c / det;
  target[3] = a / det;
  target[4] = (c * f - d * e) / det;
  target[5] = -(a * f - b * e) / det;
  return target;
}
function determinant(mat) {
  return mat[0] * mat[3] - mat[1] * mat[2];
}
function toString(mat) {
  const transformString = "matrix(" + mat.join(", ") + ")";
  if (WORKER_OFFSCREEN_CANVAS) {
    return transformString;
  }
  const node = transformStringDiv || (transformStringDiv = document.createElement("div"));
  node.style.transform = transformString;
  return node.style.transform;
}
var tmp_, transformStringDiv;
var init_transform = __esm({
  "node_modules/ol/transform.js"() {
    init_has();
    init_asserts();
    tmp_ = new Array(6);
  }
});

// node_modules/ol/extent/Relationship.js
var Relationship_default;
var init_Relationship = __esm({
  "node_modules/ol/extent/Relationship.js"() {
    Relationship_default = {
      UNKNOWN: 0,
      INTERSECTING: 1,
      ABOVE: 2,
      RIGHT: 4,
      BELOW: 8,
      LEFT: 16
    };
  }
});

// node_modules/ol/extent.js
function boundingExtent(coordinates2) {
  const extent = createEmpty();
  for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates2[i]);
  }
  return extent;
}
function _boundingExtentXYs(xs, ys, dest) {
  const minX = Math.min.apply(null, xs);
  const minY = Math.min.apply(null, ys);
  const maxX = Math.max.apply(null, xs);
  const maxY = Math.max.apply(null, ys);
  return createOrUpdate(minX, minY, maxX, maxY, dest);
}
function buffer(extent, value, dest) {
  if (dest) {
    dest[0] = extent[0] - value;
    dest[1] = extent[1] - value;
    dest[2] = extent[2] + value;
    dest[3] = extent[3] + value;
    return dest;
  }
  return [
    extent[0] - value,
    extent[1] - value,
    extent[2] + value,
    extent[3] + value
  ];
}
function clone(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent.slice();
}
function closestSquaredDistanceXY(extent, x, y) {
  let dx, dy;
  if (x < extent[0]) {
    dx = extent[0] - x;
  } else if (extent[2] < x) {
    dx = x - extent[2];
  } else {
    dx = 0;
  }
  if (y < extent[1]) {
    dy = extent[1] - y;
  } else if (extent[3] < y) {
    dy = y - extent[3];
  } else {
    dy = 0;
  }
  return dx * dx + dy * dy;
}
function containsCoordinate(extent, coordinate) {
  return containsXY(extent, coordinate[0], coordinate[1]);
}
function containsExtent(extent1, extent2) {
  return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
}
function containsXY(extent, x, y) {
  return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
}
function coordinateRelationship(extent, coordinate) {
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const x = coordinate[0];
  const y = coordinate[1];
  let relationship = Relationship_default.UNKNOWN;
  if (x < minX) {
    relationship = relationship | Relationship_default.LEFT;
  } else if (x > maxX) {
    relationship = relationship | Relationship_default.RIGHT;
  }
  if (y < minY) {
    relationship = relationship | Relationship_default.BELOW;
  } else if (y > maxY) {
    relationship = relationship | Relationship_default.ABOVE;
  }
  if (relationship === Relationship_default.UNKNOWN) {
    relationship = Relationship_default.INTERSECTING;
  }
  return relationship;
}
function createEmpty() {
  return [Infinity, Infinity, -Infinity, -Infinity];
}
function createOrUpdate(minX, minY, maxX, maxY, dest) {
  if (dest) {
    dest[0] = minX;
    dest[1] = minY;
    dest[2] = maxX;
    dest[3] = maxY;
    return dest;
  }
  return [minX, minY, maxX, maxY];
}
function createOrUpdateEmpty(dest) {
  return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);
}
function createOrUpdateFromCoordinate(coordinate, dest) {
  const x = coordinate[0];
  const y = coordinate[1];
  return createOrUpdate(x, y, x, y, dest);
}
function createOrUpdateFromCoordinates(coordinates2, dest) {
  const extent = createOrUpdateEmpty(dest);
  return extendCoordinates(extent, coordinates2);
}
function createOrUpdateFromFlatCoordinates(flatCoordinates, offset2, end, stride, dest) {
  const extent = createOrUpdateEmpty(dest);
  return extendFlatCoordinates(extent, flatCoordinates, offset2, end, stride);
}
function createOrUpdateFromRings(rings, dest) {
  const extent = createOrUpdateEmpty(dest);
  return extendRings(extent, rings);
}
function equals2(extent1, extent2) {
  return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
}
function approximatelyEquals(extent1, extent2, tolerance) {
  return Math.abs(extent1[0] - extent2[0]) < tolerance && Math.abs(extent1[2] - extent2[2]) < tolerance && Math.abs(extent1[1] - extent2[1]) < tolerance && Math.abs(extent1[3] - extent2[3]) < tolerance;
}
function extend2(extent1, extent2) {
  if (extent2[0] < extent1[0]) {
    extent1[0] = extent2[0];
  }
  if (extent2[2] > extent1[2]) {
    extent1[2] = extent2[2];
  }
  if (extent2[1] < extent1[1]) {
    extent1[1] = extent2[1];
  }
  if (extent2[3] > extent1[3]) {
    extent1[3] = extent2[3];
  }
  return extent1;
}
function extendCoordinate(extent, coordinate) {
  if (coordinate[0] < extent[0]) {
    extent[0] = coordinate[0];
  }
  if (coordinate[0] > extent[2]) {
    extent[2] = coordinate[0];
  }
  if (coordinate[1] < extent[1]) {
    extent[1] = coordinate[1];
  }
  if (coordinate[1] > extent[3]) {
    extent[3] = coordinate[1];
  }
}
function extendCoordinates(extent, coordinates2) {
  for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
    extendCoordinate(extent, coordinates2[i]);
  }
  return extent;
}
function extendFlatCoordinates(extent, flatCoordinates, offset2, end, stride) {
  for (; offset2 < end; offset2 += stride) {
    extendXY(extent, flatCoordinates[offset2], flatCoordinates[offset2 + 1]);
  }
  return extent;
}
function extendRings(extent, rings) {
  for (let i = 0, ii = rings.length; i < ii; ++i) {
    extendCoordinates(extent, rings[i]);
  }
  return extent;
}
function extendXY(extent, x, y) {
  extent[0] = Math.min(extent[0], x);
  extent[1] = Math.min(extent[1], y);
  extent[2] = Math.max(extent[2], x);
  extent[3] = Math.max(extent[3], y);
}
function forEachCorner(extent, callback) {
  let val;
  val = callback(getBottomLeft(extent));
  if (val) {
    return val;
  }
  val = callback(getBottomRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopRight(extent));
  if (val) {
    return val;
  }
  val = callback(getTopLeft(extent));
  if (val) {
    return val;
  }
  return false;
}
function getArea(extent) {
  let area = 0;
  if (!isEmpty2(extent)) {
    area = getWidth(extent) * getHeight(extent);
  }
  return area;
}
function getBottomLeft(extent) {
  return [extent[0], extent[1]];
}
function getBottomRight(extent) {
  return [extent[2], extent[1]];
}
function getCenter(extent) {
  return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
}
function getCorner(extent, corner) {
  let coordinate;
  if (corner === "bottom-left") {
    coordinate = getBottomLeft(extent);
  } else if (corner === "bottom-right") {
    coordinate = getBottomRight(extent);
  } else if (corner === "top-left") {
    coordinate = getTopLeft(extent);
  } else if (corner === "top-right") {
    coordinate = getTopRight(extent);
  } else {
    throw new Error("Invalid corner");
  }
  return coordinate;
}
function getEnlargedArea(extent1, extent2) {
  const minX = Math.min(extent1[0], extent2[0]);
  const minY = Math.min(extent1[1], extent2[1]);
  const maxX = Math.max(extent1[2], extent2[2]);
  const maxY = Math.max(extent1[3], extent2[3]);
  return (maxX - minX) * (maxY - minY);
}
function getForViewAndSize(center, resolution, rotation, size, dest) {
  const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(
    center,
    resolution,
    rotation,
    size
  );
  return createOrUpdate(
    Math.min(x0, x1, x2, x3),
    Math.min(y0, y1, y2, y3),
    Math.max(x0, x1, x2, x3),
    Math.max(y0, y1, y2, y3),
    dest
  );
}
function getRotatedViewport(center, resolution, rotation, size) {
  const dx = resolution * size[0] / 2;
  const dy = resolution * size[1] / 2;
  const cosRotation = Math.cos(rotation);
  const sinRotation = Math.sin(rotation);
  const xCos = dx * cosRotation;
  const xSin = dx * sinRotation;
  const yCos = dy * cosRotation;
  const ySin = dy * sinRotation;
  const x = center[0];
  const y = center[1];
  return [
    x - xCos + ySin,
    y - xSin - yCos,
    x - xCos - ySin,
    y - xSin + yCos,
    x + xCos - ySin,
    y + xSin + yCos,
    x + xCos + ySin,
    y + xSin - yCos,
    x - xCos + ySin,
    y - xSin - yCos
  ];
}
function getHeight(extent) {
  return extent[3] - extent[1];
}
function getIntersectionArea(extent1, extent2) {
  const intersection = getIntersection(extent1, extent2);
  return getArea(intersection);
}
function getIntersection(extent1, extent2, dest) {
  const intersection = dest ? dest : createEmpty();
  if (intersects(extent1, extent2)) {
    if (extent1[0] > extent2[0]) {
      intersection[0] = extent1[0];
    } else {
      intersection[0] = extent2[0];
    }
    if (extent1[1] > extent2[1]) {
      intersection[1] = extent1[1];
    } else {
      intersection[1] = extent2[1];
    }
    if (extent1[2] < extent2[2]) {
      intersection[2] = extent1[2];
    } else {
      intersection[2] = extent2[2];
    }
    if (extent1[3] < extent2[3]) {
      intersection[3] = extent1[3];
    } else {
      intersection[3] = extent2[3];
    }
  } else {
    createOrUpdateEmpty(intersection);
  }
  return intersection;
}
function getMargin(extent) {
  return getWidth(extent) + getHeight(extent);
}
function getSize(extent) {
  return [extent[2] - extent[0], extent[3] - extent[1]];
}
function getTopLeft(extent) {
  return [extent[0], extent[3]];
}
function getTopRight(extent) {
  return [extent[2], extent[3]];
}
function getWidth(extent) {
  return extent[2] - extent[0];
}
function intersects(extent1, extent2) {
  return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
}
function isEmpty2(extent) {
  return extent[2] < extent[0] || extent[3] < extent[1];
}
function returnOrUpdate(extent, dest) {
  if (dest) {
    dest[0] = extent[0];
    dest[1] = extent[1];
    dest[2] = extent[2];
    dest[3] = extent[3];
    return dest;
  }
  return extent;
}
function scaleFromCenter(extent, value) {
  const deltaX = (extent[2] - extent[0]) / 2 * (value - 1);
  const deltaY = (extent[3] - extent[1]) / 2 * (value - 1);
  extent[0] -= deltaX;
  extent[2] += deltaX;
  extent[1] -= deltaY;
  extent[3] += deltaY;
}
function intersectsSegment(extent, start, end) {
  let intersects3 = false;
  const startRel = coordinateRelationship(extent, start);
  const endRel = coordinateRelationship(extent, end);
  if (startRel === Relationship_default.INTERSECTING || endRel === Relationship_default.INTERSECTING) {
    intersects3 = true;
  } else {
    const minX = extent[0];
    const minY = extent[1];
    const maxX = extent[2];
    const maxY = extent[3];
    const startX = start[0];
    const startY = start[1];
    const endX = end[0];
    const endY = end[1];
    const slope = (endY - startY) / (endX - startX);
    let x, y;
    if (!!(endRel & Relationship_default.ABOVE) && !(startRel & Relationship_default.ABOVE)) {
      x = endX - (endY - maxY) / slope;
      intersects3 = x >= minX && x <= maxX;
    }
    if (!intersects3 && !!(endRel & Relationship_default.RIGHT) && !(startRel & Relationship_default.RIGHT)) {
      y = endY - (endX - maxX) * slope;
      intersects3 = y >= minY && y <= maxY;
    }
    if (!intersects3 && !!(endRel & Relationship_default.BELOW) && !(startRel & Relationship_default.BELOW)) {
      x = endX - (endY - minY) / slope;
      intersects3 = x >= minX && x <= maxX;
    }
    if (!intersects3 && !!(endRel & Relationship_default.LEFT) && !(startRel & Relationship_default.LEFT)) {
      y = endY - (endX - minX) * slope;
      intersects3 = y >= minY && y <= maxY;
    }
  }
  return intersects3;
}
function applyTransform(extent, transformFn, dest, stops) {
  if (isEmpty2(extent)) {
    return createOrUpdateEmpty(dest);
  }
  let coordinates2 = [];
  if (stops > 1) {
    const width = extent[2] - extent[0];
    const height = extent[3] - extent[1];
    for (let i = 0; i < stops; ++i) {
      coordinates2.push(
        extent[0] + width * i / stops,
        extent[1],
        extent[2],
        extent[1] + height * i / stops,
        extent[2] - width * i / stops,
        extent[3],
        extent[0],
        extent[3] - height * i / stops
      );
    }
  } else {
    coordinates2 = [
      extent[0],
      extent[1],
      extent[2],
      extent[1],
      extent[2],
      extent[3],
      extent[0],
      extent[3]
    ];
  }
  transformFn(coordinates2, coordinates2, 2);
  const xs = [];
  const ys = [];
  for (let i = 0, l = coordinates2.length; i < l; i += 2) {
    xs.push(coordinates2[i]);
    ys.push(coordinates2[i + 1]);
  }
  return _boundingExtentXYs(xs, ys, dest);
}
function wrapX(extent, projection) {
  const projectionExtent = projection.getExtent();
  const center = getCenter(extent);
  if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
    const worldWidth = getWidth(projectionExtent);
    const worldsAway = Math.floor(
      (center[0] - projectionExtent[0]) / worldWidth
    );
    const offset2 = worldsAway * worldWidth;
    extent[0] -= offset2;
    extent[2] -= offset2;
  }
  return extent;
}
function wrapAndSliceX(extent, projection) {
  if (projection.canWrapX()) {
    const projectionExtent = projection.getExtent();
    if (!isFinite(extent[0]) || !isFinite(extent[2])) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    wrapX(extent, projection);
    const worldWidth = getWidth(projectionExtent);
    if (getWidth(extent) > worldWidth) {
      return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
    }
    if (extent[0] < projectionExtent[0]) {
      return [
        [extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2], extent[3]]
      ];
    }
    if (extent[2] > projectionExtent[2]) {
      return [
        [extent[0], extent[1], projectionExtent[2], extent[3]],
        [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]]
      ];
    }
  }
  return [extent];
}
var init_extent = __esm({
  "node_modules/ol/extent.js"() {
    init_Relationship();
  }
});

// node_modules/color-space/rgb.js
var rgb_default;
var init_rgb = __esm({
  "node_modules/color-space/rgb.js"() {
    rgb_default = {
      name: "rgb",
      min: [0, 0, 0],
      max: [255, 255, 255],
      channel: ["red", "green", "blue"],
      alias: ["RGB"]
    };
  }
});

// node_modules/color-space/xyz.js
var xyz, xyz_default;
var init_xyz = __esm({
  "node_modules/color-space/xyz.js"() {
    init_rgb();
    xyz = {
      name: "xyz",
      min: [0, 0, 0],
      channel: ["X", "Y", "Z"],
      alias: ["XYZ", "ciexyz", "cie1931"]
    };
    xyz.whitepoint = {
      //1931 2
      2: {
        //incadescent
        A: [109.85, 100, 35.585],
        // B:[],
        C: [98.074, 100, 118.232],
        D50: [96.422, 100, 82.521],
        D55: [95.682, 100, 92.149],
        //daylight
        D65: [95.045592705167, 100, 108.9057750759878],
        D75: [94.972, 100, 122.638],
        //flourescent
        // F1: [],
        F2: [99.187, 100, 67.395],
        // F3: [],
        // F4: [],
        // F5: [],
        // F6:[],
        F7: [95.044, 100, 108.755],
        // F8: [],
        // F9: [],
        // F10: [],
        F11: [100.966, 100, 64.37],
        // F12: [],
        E: [100, 100, 100]
      },
      //1964  10
      10: {
        //incadescent
        A: [111.144, 100, 35.2],
        C: [97.285, 100, 116.145],
        D50: [96.72, 100, 81.427],
        D55: [95.799, 100, 90.926],
        //daylight
        D65: [94.811, 100, 107.304],
        D75: [94.416, 100, 120.641],
        //flourescent
        F2: [103.28, 100, 69.026],
        F7: [95.792, 100, 107.687],
        F11: [103.866, 100, 65.627],
        E: [100, 100, 100]
      }
    };
    xyz.max = xyz.whitepoint[2].D65;
    xyz.rgb = function(_xyz, white) {
      white = white || xyz.whitepoint[2].E;
      var x = _xyz[0] / white[0], y = _xyz[1] / white[1], z = _xyz[2] / white[2], r, g, b;
      r = x * 3.240969941904521 + y * -1.537383177570093 + z * -0.498610760293;
      g = x * -0.96924363628087 + y * 1.87596750150772 + z * 0.041555057407175;
      b = x * 0.055630079696993 + y * -0.20397695888897 + z * 1.056971514242878;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r = r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g = g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b = b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    rgb_default.xyz = function(rgb, white) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.41239079926595 + g * 0.35758433938387 + b * 0.18048078840183;
      var y = r * 0.21263900587151 + g * 0.71516867876775 + b * 0.072192315360733;
      var z = r * 0.019330818715591 + g * 0.11919477979462 + b * 0.95053215224966;
      white = white || xyz.whitepoint[2].E;
      return [x * white[0], y * white[1], z * white[2]];
    };
    xyz_default = xyz;
  }
});

// node_modules/color-space/luv.js
var luv_default;
var init_luv = __esm({
  "node_modules/color-space/luv.js"() {
    init_xyz();
    luv_default = {
      name: "luv",
      //NOTE: luv has no rigidly defined limits
      //easyrgb fails to get proper coords
      //boronine states no rigid limits
      //colorMine refers this ones:
      min: [0, -134, -140],
      max: [100, 224, 122],
      channel: ["lightness", "u", "v"],
      alias: ["LUV", "cieluv", "cie1976"],
      xyz: function(arg, i, o) {
        var _u, _v, l, u, v, x, y, z, xn, yn, zn, un, vn;
        l = arg[0], u = arg[1], v = arg[2];
        if (l === 0)
          return [0, 0, 0];
        var k = 0.0011070564598794539;
        i = i || "D65";
        o = o || 2;
        xn = xyz_default.whitepoint[o][i][0];
        yn = xyz_default.whitepoint[o][i][1];
        zn = xyz_default.whitepoint[o][i][2];
        un = 4 * xn / (xn + 15 * yn + 3 * zn);
        vn = 9 * yn / (xn + 15 * yn + 3 * zn);
        _u = u / (13 * l) + un || 0;
        _v = v / (13 * l) + vn || 0;
        y = l > 8 ? yn * Math.pow((l + 16) / 116, 3) : yn * l * k;
        x = y * 9 * _u / (4 * _v) || 0;
        z = y * (12 - 3 * _u - 20 * _v) / (4 * _v) || 0;
        return [x, y, z];
      }
    };
    xyz_default.luv = function(arg, i, o) {
      var _u, _v, l, u, v, x, y, z, xn, yn, zn, un, vn;
      var e = 0.008856451679035631;
      var k = 903.2962962962961;
      i = i || "D65";
      o = o || 2;
      xn = xyz_default.whitepoint[o][i][0];
      yn = xyz_default.whitepoint[o][i][1];
      zn = xyz_default.whitepoint[o][i][2];
      un = 4 * xn / (xn + 15 * yn + 3 * zn);
      vn = 9 * yn / (xn + 15 * yn + 3 * zn);
      x = arg[0], y = arg[1], z = arg[2];
      _u = 4 * x / (x + 15 * y + 3 * z) || 0;
      _v = 9 * y / (x + 15 * y + 3 * z) || 0;
      var yr = y / yn;
      l = yr <= e ? k * yr : 116 * Math.pow(yr, 1 / 3) - 16;
      u = 13 * l * (_u - un);
      v = 13 * l * (_v - vn);
      return [l, u, v];
    };
  }
});

// node_modules/color-space/lchuv.js
var lchuv, lchuv_default;
var init_lchuv = __esm({
  "node_modules/color-space/lchuv.js"() {
    init_luv();
    init_xyz();
    lchuv = {
      name: "lchuv",
      channel: ["lightness", "chroma", "hue"],
      alias: ["LCHuv", "cielchuv"],
      min: [0, 0, 0],
      max: [100, 100, 360],
      luv: function(luv) {
        var l = luv[0], c = luv[1], h = luv[2], u, v, hr;
        hr = h / 360 * 2 * Math.PI;
        u = c * Math.cos(hr);
        v = c * Math.sin(hr);
        return [l, u, v];
      },
      xyz: function(arg) {
        return luv_default.xyz(lchuv.luv(arg));
      }
    };
    lchuv_default = lchuv;
    luv_default.lchuv = function(luv) {
      var l = luv[0], u = luv[1], v = luv[2];
      var c = Math.sqrt(u * u + v * v);
      var hr = Math.atan2(v, u);
      var h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      return [l, c, h];
    };
    xyz_default.lchuv = function(arg) {
      return luv_default.lchuv(xyz_default.luv(arg));
    };
  }
});

// node_modules/color-parse/node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-parse/node_modules/color-name/index.js"(exports, module) {
    "use strict";
    module.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/color-parse/index.js
function parse(cstr) {
  var m, parts = [], alpha = 1, space;
  if (typeof cstr === "number") {
    return { space: "rgb", values: [cstr >>> 16, (cstr & 65280) >>> 8, cstr & 255], alpha: 1 };
  }
  if (typeof cstr === "number")
    return { space: "rgb", values: [cstr >>> 16, (cstr & 65280) >>> 8, cstr & 255], alpha: 1 };
  cstr = String(cstr).toLowerCase();
  if (import_color_name.default[cstr]) {
    parts = import_color_name.default[cstr].slice();
    space = "rgb";
  } else if (cstr === "transparent") {
    alpha = 0;
    space = "rgb";
    parts = [0, 0, 0];
  } else if (cstr[0] === "#") {
    var base = cstr.slice(1);
    var size = base.length;
    var isShort = size <= 4;
    alpha = 1;
    if (isShort) {
      parts = [
        parseInt(base[0] + base[0], 16),
        parseInt(base[1] + base[1], 16),
        parseInt(base[2] + base[2], 16)
      ];
      if (size === 4) {
        alpha = parseInt(base[3] + base[3], 16) / 255;
      }
    } else {
      parts = [
        parseInt(base[0] + base[1], 16),
        parseInt(base[2] + base[3], 16),
        parseInt(base[4] + base[5], 16)
      ];
      if (size === 8) {
        alpha = parseInt(base[6] + base[7], 16) / 255;
      }
    }
    if (!parts[0])
      parts[0] = 0;
    if (!parts[1])
      parts[1] = 0;
    if (!parts[2])
      parts[2] = 0;
    space = "rgb";
  } else if (m = /^((?:rgba?|hs[lvb]a?|hwba?|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms|oklch|oklab|color))\s*\(([^\)]*)\)/.exec(cstr)) {
    var name = m[1];
    space = name.replace(/a$/, "");
    var dims = space === "cmyk" ? 4 : space === "gray" ? 1 : 3;
    parts = m[2].trim().split(/\s*[,\/]\s*|\s+/);
    if (space === "color")
      space = parts.shift();
    parts = parts.map(function(x, i) {
      if (x[x.length - 1] === "%") {
        x = parseFloat(x) / 100;
        if (i === 3)
          return x;
        if (space === "rgb")
          return x * 255;
        if (space[0] === "h")
          return x * 100;
        if (space[0] === "l" && !i)
          return x * 100;
        if (space === "lab")
          return x * 125;
        if (space === "lch")
          return i < 2 ? x * 150 : x * 360;
        if (space[0] === "o" && !i)
          return x;
        if (space === "oklab")
          return x * 0.4;
        if (space === "oklch")
          return i < 2 ? x * 0.4 : x * 360;
        return x;
      }
      if (space[i] === "h" || i === 2 && space[space.length - 1] === "h") {
        if (baseHues[x] !== void 0)
          return baseHues[x];
        if (x.endsWith("deg"))
          return parseFloat(x);
        if (x.endsWith("turn"))
          return parseFloat(x) * 360;
        if (x.endsWith("grad"))
          return parseFloat(x) * 360 / 400;
        if (x.endsWith("rad"))
          return parseFloat(x) * 180 / Math.PI;
      }
      if (x === "none")
        return 0;
      return parseFloat(x);
    });
    alpha = parts.length > dims ? parts.pop() : 1;
  } else if (/[0-9](?:\s|\/|,)/.test(cstr)) {
    parts = cstr.match(/([0-9]+)/g).map(function(value) {
      return parseFloat(value);
    });
    space = cstr.match(/([a-z])/ig)?.join("")?.toLowerCase() || "rgb";
  }
  return {
    space,
    values: parts,
    alpha
  };
}
var import_color_name, color_parse_default, baseHues;
var init_color_parse = __esm({
  "node_modules/color-parse/index.js"() {
    import_color_name = __toESM(require_color_name(), 1);
    color_parse_default = parse;
    baseHues = {
      red: 0,
      orange: 60,
      yellow: 120,
      green: 180,
      blue: 240,
      purple: 300
    };
  }
});

// node_modules/color-space/hsl.js
var hsl_default;
var init_hsl = __esm({
  "node_modules/color-space/hsl.js"() {
    init_rgb();
    hsl_default = {
      name: "hsl",
      min: [0, 0, 0],
      max: [360, 100, 100],
      channel: ["hue", "saturation", "lightness"],
      alias: ["HSL"],
      rgb: function(hsl) {
        var h = hsl[0] / 360, s = hsl[1] / 100, l = hsl[2] / 100, t1, t2, t3, rgb, val, i = 0;
        if (s === 0)
          return val = l * 255, [val, val, val];
        t2 = l < 0.5 ? l * (1 + s) : l + s - l * s;
        t1 = 2 * l - t2;
        rgb = [0, 0, 0];
        for (; i < 3; ) {
          t3 = h + 1 / 3 * -(i - 1);
          t3 < 0 ? t3++ : t3 > 1 && t3--;
          val = 6 * t3 < 1 ? t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? t2 : 3 * t3 < 2 ? t1 + (t2 - t1) * (2 / 3 - t3) * 6 : t1;
          rgb[i++] = val * 255;
        }
        return rgb;
      }
    };
    rgb_default.hsl = function(rgb) {
      var r = rgb[0] / 255, g = rgb[1] / 255, b = rgb[2] / 255, min = Math.min(r, g, b), max = Math.max(r, g, b), delta = max - min, h, s, l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
  }
});

// node_modules/color-rgba/index.js
function rgba(color) {
  if (Array.isArray(color) && color.raw)
    color = String.raw(...arguments);
  if (color instanceof Number)
    color = +color;
  var values, i, l;
  var parsed = color_parse_default(color);
  if (!parsed.space)
    return [];
  const min = parsed.space[0] === "h" ? hsl_default.min : rgb_default.min;
  const max = parsed.space[0] === "h" ? hsl_default.max : rgb_default.max;
  values = Array(3);
  values[0] = Math.min(Math.max(parsed.values[0], min[0]), max[0]);
  values[1] = Math.min(Math.max(parsed.values[1], min[1]), max[1]);
  values[2] = Math.min(Math.max(parsed.values[2], min[2]), max[2]);
  if (parsed.space[0] === "h") {
    values = hsl_default.rgb(values);
  }
  values.push(Math.min(Math.max(parsed.alpha, 0), 1));
  return values;
}
var init_color_rgba = __esm({
  "node_modules/color-rgba/index.js"() {
    init_color_parse();
    init_rgb();
    init_hsl();
  }
});

// node_modules/ol/math.js
function clamp(value, min, max) {
  return Math.min(Math.max(value, min), max);
}
function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  if (dx !== 0 || dy !== 0) {
    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      x1 = x2;
      y1 = y2;
    } else if (t > 0) {
      x1 += dx * t;
      y1 += dy * t;
    }
  }
  return squaredDistance(x, y, x1, y1);
}
function squaredDistance(x1, y1, x2, y2) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  return dx * dx + dy * dy;
}
function solveLinearSystem(mat) {
  const n = mat.length;
  for (let i = 0; i < n; i++) {
    let maxRow = i;
    let maxEl = Math.abs(mat[i][i]);
    for (let r = i + 1; r < n; r++) {
      const absValue = Math.abs(mat[r][i]);
      if (absValue > maxEl) {
        maxEl = absValue;
        maxRow = r;
      }
    }
    if (maxEl === 0) {
      return null;
    }
    const tmp = mat[maxRow];
    mat[maxRow] = mat[i];
    mat[i] = tmp;
    for (let j = i + 1; j < n; j++) {
      const coef = -mat[j][i] / mat[i][i];
      for (let k = i; k < n + 1; k++) {
        if (i == k) {
          mat[j][k] = 0;
        } else {
          mat[j][k] += coef * mat[i][k];
        }
      }
    }
  }
  const x = new Array(n);
  for (let l = n - 1; l >= 0; l--) {
    x[l] = mat[l][n] / mat[l][l];
    for (let m = l - 1; m >= 0; m--) {
      mat[m][n] -= mat[m][l] * x[l];
    }
  }
  return x;
}
function toDegrees(angleInRadians) {
  return angleInRadians * 180 / Math.PI;
}
function toRadians(angleInDegrees) {
  return angleInDegrees * Math.PI / 180;
}
function modulo(a, b) {
  const r = a % b;
  return r * b < 0 ? r + b : r;
}
function lerp(a, b, x) {
  return a + x * (b - a);
}
function toFixed(n, decimals) {
  const factor = Math.pow(10, decimals);
  return Math.round(n * factor) / factor;
}
function round(n, decimals) {
  return Math.round(toFixed(n, decimals));
}
function floor(n, decimals) {
  return Math.floor(toFixed(n, decimals));
}
function ceil(n, decimals) {
  return Math.ceil(toFixed(n, decimals));
}
var init_math = __esm({
  "node_modules/ol/math.js"() {
  }
});

// node_modules/ol/color.js
function asString(color) {
  if (typeof color === "string") {
    return color;
  }
  return toString2(color);
}
function withAlpha(color) {
  if (color.length === 4) {
    return color;
  }
  const output = color.slice();
  output[3] = 1;
  return output;
}
function rgbaToLcha(color) {
  const output = xyz_default.lchuv(rgb_default.xyz(color));
  output[3] = color[3];
  return output;
}
function lchaToRgba(color) {
  const output = xyz_default.rgb(lchuv_default.xyz(color));
  output[3] = color[3];
  return output;
}
function fromString(s) {
  if (cache.hasOwnProperty(s)) {
    return cache[s];
  }
  if (cacheSize >= MAX_CACHE_SIZE) {
    let i = 0;
    for (const key in cache) {
      if ((i++ & 3) === 0) {
        delete cache[key];
        --cacheSize;
      }
    }
  }
  const color = rgba(s);
  if (color.length !== 4) {
    throw new Error('Failed to parse "' + s + '" as color');
  }
  for (const c of color) {
    if (isNaN(c)) {
      throw new Error('Failed to parse "' + s + '" as color');
    }
  }
  normalize(color);
  cache[s] = color;
  ++cacheSize;
  return color;
}
function asArray(color) {
  if (Array.isArray(color)) {
    return color;
  }
  return fromString(color);
}
function normalize(color) {
  color[0] = clamp(color[0] + 0.5 | 0, 0, 255);
  color[1] = clamp(color[1] + 0.5 | 0, 0, 255);
  color[2] = clamp(color[2] + 0.5 | 0, 0, 255);
  color[3] = clamp(color[3], 0, 1);
  return color;
}
function toString2(color) {
  let r = color[0];
  if (r != (r | 0)) {
    r = r + 0.5 | 0;
  }
  let g = color[1];
  if (g != (g | 0)) {
    g = g + 0.5 | 0;
  }
  let b = color[2];
  if (b != (b | 0)) {
    b = b + 0.5 | 0;
  }
  const a = color[3] === void 0 ? 1 : Math.round(color[3] * 100) / 100;
  return "rgba(" + r + "," + g + "," + b + "," + a + ")";
}
function isStringColor(s) {
  try {
    fromString(s);
    return true;
  } catch (_) {
    return false;
  }
}
var MAX_CACHE_SIZE, cache, cacheSize;
var init_color = __esm({
  "node_modules/ol/color.js"() {
    init_lchuv();
    init_color_rgba();
    init_rgb();
    init_xyz();
    init_math();
    MAX_CACHE_SIZE = 1024;
    cache = {};
    cacheSize = 0;
  }
});

// node_modules/ol/style/IconImageCache.js
function getKey(src, crossOrigin, color) {
  const colorString = color ? asString(color) : "null";
  return crossOrigin + ":" + src + ":" + colorString;
}
var IconImageCache, IconImageCache_default, shared;
var init_IconImageCache = __esm({
  "node_modules/ol/style/IconImageCache.js"() {
    init_color();
    IconImageCache = class {
      constructor() {
        this.cache_ = {};
        this.cacheSize_ = 0;
        this.maxCacheSize_ = 32;
      }
      /**
       * FIXME empty description for jsdoc
       */
      clear() {
        this.cache_ = {};
        this.cacheSize_ = 0;
      }
      /**
       * @return {boolean} Can expire cache.
       */
      canExpireCache() {
        return this.cacheSize_ > this.maxCacheSize_;
      }
      /**
       * FIXME empty description for jsdoc
       */
      expire() {
        if (this.canExpireCache()) {
          let i = 0;
          for (const key in this.cache_) {
            const iconImage = this.cache_[key];
            if ((i++ & 3) === 0 && !iconImage.hasListener()) {
              delete this.cache_[key];
              --this.cacheSize_;
            }
          }
        }
      }
      /**
       * @param {string} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../color.js").Color} color Color.
       * @return {import("./IconImage.js").default} Icon image.
       */
      get(src, crossOrigin, color) {
        const key = getKey(src, crossOrigin, color);
        return key in this.cache_ ? this.cache_[key] : null;
      }
      /**
       * @param {string} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../color.js").Color} color Color.
       * @param {import("./IconImage.js").default} iconImage Icon image.
       */
      set(src, crossOrigin, color, iconImage) {
        const key = getKey(src, crossOrigin, color);
        this.cache_[key] = iconImage;
        ++this.cacheSize_;
      }
      /**
       * Set the cache size of the icon cache. Default is `32`. Change this value when
       * your map uses more than 32 different icon images and you are not caching icon
       * styles on the application level.
       * @param {number} maxCacheSize Cache max size.
       * @api
       */
      setSize(maxCacheSize) {
        this.maxCacheSize_ = maxCacheSize;
        this.expire();
      }
    };
    IconImageCache_default = IconImageCache;
    shared = new IconImageCache();
  }
});

// node_modules/ol/layer/Property.js
var Property_default;
var init_Property = __esm({
  "node_modules/ol/layer/Property.js"() {
    Property_default = {
      OPACITY: "opacity",
      VISIBLE: "visible",
      EXTENT: "extent",
      Z_INDEX: "zIndex",
      MAX_RESOLUTION: "maxResolution",
      MIN_RESOLUTION: "minResolution",
      MAX_ZOOM: "maxZoom",
      MIN_ZOOM: "minZoom",
      SOURCE: "source",
      MAP: "map"
    };
  }
});

// node_modules/ol/layer/Base.js
var BaseLayer, Base_default;
var init_Base = __esm({
  "node_modules/ol/layer/Base.js"() {
    init_Object();
    init_Property();
    init_util();
    init_asserts();
    init_math();
    BaseLayer = class extends Object_default {
      /**
       * @param {Options} options Layer options.
       */
      constructor(options) {
        super();
        this.on;
        this.once;
        this.un;
        this.background_ = options.background;
        const properties = Object.assign({}, options);
        if (typeof options.properties === "object") {
          delete properties.properties;
          Object.assign(properties, options.properties);
        }
        properties[Property_default.OPACITY] = options.opacity !== void 0 ? options.opacity : 1;
        assert(
          typeof properties[Property_default.OPACITY] === "number",
          "Layer opacity must be a number"
        );
        properties[Property_default.VISIBLE] = options.visible !== void 0 ? options.visible : true;
        properties[Property_default.Z_INDEX] = options.zIndex;
        properties[Property_default.MAX_RESOLUTION] = options.maxResolution !== void 0 ? options.maxResolution : Infinity;
        properties[Property_default.MIN_RESOLUTION] = options.minResolution !== void 0 ? options.minResolution : 0;
        properties[Property_default.MIN_ZOOM] = options.minZoom !== void 0 ? options.minZoom : -Infinity;
        properties[Property_default.MAX_ZOOM] = options.maxZoom !== void 0 ? options.maxZoom : Infinity;
        this.className_ = properties.className !== void 0 ? properties.className : "ol-layer";
        delete properties.className;
        this.setProperties(properties);
        this.state_ = null;
      }
      /**
       * Get the background for this layer.
       * @return {BackgroundColor|false} Layer background.
       */
      getBackground() {
        return this.background_;
      }
      /**
       * @return {string} CSS class name.
       */
      getClassName() {
        return this.className_;
      }
      /**
       * This method is not meant to be called by layers or layer renderers because the state
       * is incorrect if the layer is included in a layer group.
       *
       * @param {boolean} [managed] Layer is managed.
       * @return {import("./Layer.js").State} Layer state.
       */
      getLayerState(managed) {
        const state = this.state_ || /** @type {?} */
        {
          layer: this,
          managed: managed === void 0 ? true : managed
        };
        const zIndex = this.getZIndex();
        state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
        state.visible = this.getVisible();
        state.extent = this.getExtent();
        state.zIndex = zIndex === void 0 && !state.managed ? Infinity : zIndex;
        state.maxResolution = this.getMaxResolution();
        state.minResolution = Math.max(this.getMinResolution(), 0);
        state.minZoom = this.getMinZoom();
        state.maxZoom = this.getMaxZoom();
        this.state_ = state;
        return state;
      }
      /**
       * @abstract
       * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
       *     modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       */
      getLayersArray(array) {
        return abstract();
      }
      /**
       * @abstract
       * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
       *     states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       */
      getLayerStatesArray(states) {
        return abstract();
      }
      /**
       * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
       * will be visible regardless of extent.
       * @return {import("../extent.js").Extent|undefined} The layer extent.
       * @observable
       * @api
       */
      getExtent() {
        return (
          /** @type {import("../extent.js").Extent|undefined} */
          this.get(Property_default.EXTENT)
        );
      }
      /**
       * Return the maximum resolution of the layer. Returns Infinity if
       * the layer has no maximum resolution set.
       * @return {number} The maximum resolution of the layer.
       * @observable
       * @api
       */
      getMaxResolution() {
        return (
          /** @type {number} */
          this.get(Property_default.MAX_RESOLUTION)
        );
      }
      /**
       * Return the minimum resolution of the layer. Returns 0 if
       * the layer has no minimum resolution set.
       * @return {number} The minimum resolution of the layer.
       * @observable
       * @api
       */
      getMinResolution() {
        return (
          /** @type {number} */
          this.get(Property_default.MIN_RESOLUTION)
        );
      }
      /**
       * Return the minimum zoom level of the layer. Returns -Infinity if
       * the layer has no minimum zoom set.
       * @return {number} The minimum zoom level of the layer.
       * @observable
       * @api
       */
      getMinZoom() {
        return (
          /** @type {number} */
          this.get(Property_default.MIN_ZOOM)
        );
      }
      /**
       * Return the maximum zoom level of the layer. Returns Infinity if
       * the layer has no maximum zoom set.
       * @return {number} The maximum zoom level of the layer.
       * @observable
       * @api
       */
      getMaxZoom() {
        return (
          /** @type {number} */
          this.get(Property_default.MAX_ZOOM)
        );
      }
      /**
       * Return the opacity of the layer (between 0 and 1).
       * @return {number} The opacity of the layer.
       * @observable
       * @api
       */
      getOpacity() {
        return (
          /** @type {number} */
          this.get(Property_default.OPACITY)
        );
      }
      /**
       * @abstract
       * @return {import("../source/Source.js").State} Source state.
       */
      getSourceState() {
        return abstract();
      }
      /**
       * Return the value of this layer's `visible` property. To find out whether the layer
       * is visible on a map, use `isVisible()` instead.
       * @return {boolean} The value of the `visible` property of the layer.
       * @observable
       * @api
       */
      getVisible() {
        return (
          /** @type {boolean} */
          this.get(Property_default.VISIBLE)
        );
      }
      /**
       * Return the Z-index of the layer, which is used to order layers before
       * rendering. Returns undefined if the layer is unmanaged.
       * @return {number|undefined} The Z-index of the layer.
       * @observable
       * @api
       */
      getZIndex() {
        return (
          /** @type {number|undefined} */
          this.get(Property_default.Z_INDEX)
        );
      }
      /**
       * Sets the background color.
       * @param {BackgroundColor} [background] Background color.
       */
      setBackground(background) {
        this.background_ = background;
        this.changed();
      }
      /**
       * Set the extent at which the layer is visible.  If `undefined`, the layer
       * will be visible at all extents.
       * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
       * @observable
       * @api
       */
      setExtent(extent) {
        this.set(Property_default.EXTENT, extent);
      }
      /**
       * Set the maximum resolution at which the layer is visible.
       * @param {number} maxResolution The maximum resolution of the layer.
       * @observable
       * @api
       */
      setMaxResolution(maxResolution) {
        this.set(Property_default.MAX_RESOLUTION, maxResolution);
      }
      /**
       * Set the minimum resolution at which the layer is visible.
       * @param {number} minResolution The minimum resolution of the layer.
       * @observable
       * @api
       */
      setMinResolution(minResolution) {
        this.set(Property_default.MIN_RESOLUTION, minResolution);
      }
      /**
       * Set the maximum zoom (exclusive) at which the layer is visible.
       * Note that the zoom levels for layer visibility are based on the
       * view zoom level, which may be different from a tile source zoom level.
       * @param {number} maxZoom The maximum zoom of the layer.
       * @observable
       * @api
       */
      setMaxZoom(maxZoom) {
        this.set(Property_default.MAX_ZOOM, maxZoom);
      }
      /**
       * Set the minimum zoom (inclusive) at which the layer is visible.
       * Note that the zoom levels for layer visibility are based on the
       * view zoom level, which may be different from a tile source zoom level.
       * @param {number} minZoom The minimum zoom of the layer.
       * @observable
       * @api
       */
      setMinZoom(minZoom) {
        this.set(Property_default.MIN_ZOOM, minZoom);
      }
      /**
       * Set the opacity of the layer, allowed values range from 0 to 1.
       * @param {number} opacity The opacity of the layer.
       * @observable
       * @api
       */
      setOpacity(opacity) {
        assert(typeof opacity === "number", "Layer opacity must be a number");
        this.set(Property_default.OPACITY, opacity);
      }
      /**
       * Set the visibility of the layer (`true` or `false`).
       * @param {boolean} visible The visibility of the layer.
       * @observable
       * @api
       */
      setVisible(visible) {
        this.set(Property_default.VISIBLE, visible);
      }
      /**
       * Set Z-index of the layer, which is used to order layers before rendering.
       * The default Z-index is 0.
       * @param {number} zindex The z-index of the layer.
       * @observable
       * @api
       */
      setZIndex(zindex) {
        this.set(Property_default.Z_INDEX, zindex);
      }
      /**
       * Clean up.
       */
      disposeInternal() {
        if (this.state_) {
          this.state_.layer = null;
          this.state_ = null;
        }
        super.disposeInternal();
      }
    };
    Base_default = BaseLayer;
  }
});

// node_modules/ol/render/EventType.js
var EventType_default2;
var init_EventType2 = __esm({
  "node_modules/ol/render/EventType.js"() {
    EventType_default2 = {
      /**
       * Triggered before a layer is rendered.
       * @event module:ol/render/Event~RenderEvent#prerender
       * @api
       */
      PRERENDER: "prerender",
      /**
       * Triggered after a layer is rendered.
       * @event module:ol/render/Event~RenderEvent#postrender
       * @api
       */
      POSTRENDER: "postrender",
      /**
       * Triggered before layers are composed.  When dispatched by the map, the event object will not have
       * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
       * WebGL layers currently dispatch this event.
       * @event module:ol/render/Event~RenderEvent#precompose
       * @api
       */
      PRECOMPOSE: "precompose",
      /**
       * Triggered after layers are composed.  When dispatched by the map, the event object will not have
       * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
       * WebGL layers currently dispatch this event.
       * @event module:ol/render/Event~RenderEvent#postcompose
       * @api
       */
      POSTCOMPOSE: "postcompose",
      /**
       * Triggered when rendering is complete, i.e. all sources and tiles have
       * finished loading for the current viewport, and all tiles are faded in.
       * The event object will not have a `context` set.
       * @event module:ol/render/Event~RenderEvent#rendercomplete
       * @api
       */
      RENDERCOMPLETE: "rendercomplete"
    };
  }
});

// node_modules/ol/ViewHint.js
var ViewHint_default;
var init_ViewHint = __esm({
  "node_modules/ol/ViewHint.js"() {
    ViewHint_default = {
      ANIMATING: 0,
      INTERACTING: 1
    };
  }
});

// node_modules/ol/ViewProperty.js
var ViewProperty_default;
var init_ViewProperty = __esm({
  "node_modules/ol/ViewProperty.js"() {
    ViewProperty_default = {
      CENTER: "center",
      RESOLUTION: "resolution",
      ROTATION: "rotation"
    };
  }
});

// node_modules/ol/tilegrid/common.js
var DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE;
var init_common = __esm({
  "node_modules/ol/tilegrid/common.js"() {
    DEFAULT_MAX_ZOOM = 42;
    DEFAULT_TILE_SIZE = 256;
  }
});

// node_modules/ol/proj/Units.js
function fromCode(code) {
  return unitByCode[code];
}
var unitByCode, METERS_PER_UNIT;
var init_Units = __esm({
  "node_modules/ol/proj/Units.js"() {
    unitByCode = {
      "9001": "m",
      "9002": "ft",
      "9003": "us-ft",
      "9101": "radians",
      "9102": "degrees"
    };
    METERS_PER_UNIT = {
      // use the radius of the Normal sphere
      "radians": 6370997 / (2 * Math.PI),
      "degrees": 2 * Math.PI * 6370997 / 360,
      "ft": 0.3048,
      "m": 1,
      "us-ft": 1200 / 3937
    };
  }
});

// node_modules/ol/proj/Projection.js
var Projection, Projection_default;
var init_Projection = __esm({
  "node_modules/ol/proj/Projection.js"() {
    init_Units();
    Projection = class {
      /**
       * @param {Options} options Projection options.
       */
      constructor(options) {
        this.code_ = options.code;
        this.units_ = /** @type {import("./Units.js").Units} */
        options.units;
        this.extent_ = options.extent !== void 0 ? options.extent : null;
        this.worldExtent_ = options.worldExtent !== void 0 ? options.worldExtent : null;
        this.axisOrientation_ = options.axisOrientation !== void 0 ? options.axisOrientation : "enu";
        this.global_ = options.global !== void 0 ? options.global : false;
        this.canWrapX_ = !!(this.global_ && this.extent_);
        this.getPointResolutionFunc_ = options.getPointResolution;
        this.defaultTileGrid_ = null;
        this.metersPerUnit_ = options.metersPerUnit;
      }
      /**
       * @return {boolean} The projection is suitable for wrapping the x-axis
       */
      canWrapX() {
        return this.canWrapX_;
      }
      /**
       * Get the code for this projection, e.g. 'EPSG:4326'.
       * @return {string} Code.
       * @api
       */
      getCode() {
        return this.code_;
      }
      /**
       * Get the validity extent for this projection.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getExtent() {
        return this.extent_;
      }
      /**
       * Get the units of this projection.
       * @return {import("./Units.js").Units} Units.
       * @api
       */
      getUnits() {
        return this.units_;
      }
      /**
       * Get the amount of meters per unit of this projection.  If the projection is
       * not configured with `metersPerUnit` or a units identifier, the return is
       * `undefined`.
       * @return {number|undefined} Meters.
       * @api
       */
      getMetersPerUnit() {
        return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];
      }
      /**
       * Get the world extent for this projection.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getWorldExtent() {
        return this.worldExtent_;
      }
      /**
       * Get the axis orientation of this projection.
       * Example values are:
       * enu - the default easting, northing, elevation.
       * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
       *     or south orientated transverse mercator.
       * wnu - westing, northing, up - some planetary coordinate systems have
       *     "west positive" coordinate systems
       * @return {string} Axis orientation.
       * @api
       */
      getAxisOrientation() {
        return this.axisOrientation_;
      }
      /**
       * Is this projection a global projection which spans the whole world?
       * @return {boolean} Whether the projection is global.
       * @api
       */
      isGlobal() {
        return this.global_;
      }
      /**
       * Set if the projection is a global projection which spans the whole world
       * @param {boolean} global Whether the projection is global.
       * @api
       */
      setGlobal(global) {
        this.global_ = global;
        this.canWrapX_ = !!(global && this.extent_);
      }
      /**
       * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
       */
      getDefaultTileGrid() {
        return this.defaultTileGrid_;
      }
      /**
       * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
       */
      setDefaultTileGrid(tileGrid) {
        this.defaultTileGrid_ = tileGrid;
      }
      /**
       * Set the validity extent for this projection.
       * @param {import("../extent.js").Extent} extent Extent.
       * @api
       */
      setExtent(extent) {
        this.extent_ = extent;
        this.canWrapX_ = !!(this.global_ && extent);
      }
      /**
       * Set the world extent for this projection.
       * @param {import("../extent.js").Extent} worldExtent World extent
       *     [minlon, minlat, maxlon, maxlat].
       * @api
       */
      setWorldExtent(worldExtent) {
        this.worldExtent_ = worldExtent;
      }
      /**
       * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
       * for this projection.
       * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
       * @api
       */
      setGetPointResolution(func) {
        this.getPointResolutionFunc_ = func;
      }
      /**
       * Get the custom point resolution function for this projection (if set).
       * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
       * resolution function (if set).
       */
      getPointResolutionFunc() {
        return this.getPointResolutionFunc_;
      }
    };
    Projection_default = Projection;
  }
});

// node_modules/ol/proj/epsg3857.js
function fromEPSG4326(input, output, dimension) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += dimension) {
    output[i] = HALF_SIZE * input[i] / 180;
    let y = RADIUS * Math.log(Math.tan(Math.PI * (+input[i + 1] + 90) / 360));
    if (y > MAX_SAFE_Y) {
      y = MAX_SAFE_Y;
    } else if (y < -MAX_SAFE_Y) {
      y = -MAX_SAFE_Y;
    }
    output[i + 1] = y;
  }
  return output;
}
function toEPSG4326(input, output, dimension) {
  const length = input.length;
  dimension = dimension > 1 ? dimension : 2;
  if (output === void 0) {
    if (dimension > 2) {
      output = input.slice();
    } else {
      output = new Array(length);
    }
  }
  for (let i = 0; i < length; i += dimension) {
    output[i] = 180 * input[i] / HALF_SIZE;
    output[i + 1] = 360 * Math.atan(Math.exp(input[i + 1] / RADIUS)) / Math.PI - 90;
  }
  return output;
}
var RADIUS, HALF_SIZE, EXTENT, WORLD_EXTENT, MAX_SAFE_Y, EPSG3857Projection, PROJECTIONS;
var init_epsg3857 = __esm({
  "node_modules/ol/proj/epsg3857.js"() {
    init_Projection();
    RADIUS = 6378137;
    HALF_SIZE = Math.PI * RADIUS;
    EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
    WORLD_EXTENT = [-180, -85, 180, 85];
    MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));
    EPSG3857Projection = class extends Projection_default {
      /**
       * @param {string} code Code.
       */
      constructor(code) {
        super({
          code,
          units: "m",
          extent: EXTENT,
          global: true,
          worldExtent: WORLD_EXTENT,
          getPointResolution: function(resolution, point) {
            return resolution / Math.cosh(point[1] / RADIUS);
          }
        });
      }
    };
    PROJECTIONS = [
      new EPSG3857Projection("EPSG:3857"),
      new EPSG3857Projection("EPSG:102100"),
      new EPSG3857Projection("EPSG:102113"),
      new EPSG3857Projection("EPSG:900913"),
      new EPSG3857Projection("http://www.opengis.net/def/crs/EPSG/0/3857"),
      new EPSG3857Projection("http://www.opengis.net/gml/srs/epsg.xml#3857")
    ];
  }
});

// node_modules/ol/proj/epsg4326.js
var RADIUS2, EXTENT2, METERS_PER_UNIT2, EPSG4326Projection, PROJECTIONS2;
var init_epsg4326 = __esm({
  "node_modules/ol/proj/epsg4326.js"() {
    init_Projection();
    RADIUS2 = 6378137;
    EXTENT2 = [-180, -90, 180, 90];
    METERS_PER_UNIT2 = Math.PI * RADIUS2 / 180;
    EPSG4326Projection = class extends Projection_default {
      /**
       * @param {string} code Code.
       * @param {string} [axisOrientation] Axis orientation.
       */
      constructor(code, axisOrientation) {
        super({
          code,
          units: "degrees",
          extent: EXTENT2,
          axisOrientation,
          global: true,
          metersPerUnit: METERS_PER_UNIT2,
          worldExtent: EXTENT2
        });
      }
    };
    PROJECTIONS2 = [
      new EPSG4326Projection("CRS:84"),
      new EPSG4326Projection("EPSG:4326", "neu"),
      new EPSG4326Projection("urn:ogc:def:crs:OGC:1.3:CRS84"),
      new EPSG4326Projection("urn:ogc:def:crs:OGC:2:84"),
      new EPSG4326Projection("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
      new EPSG4326Projection("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
      new EPSG4326Projection("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
    ];
  }
});

// node_modules/ol/proj/projections.js
function clear2() {
  cache2 = {};
}
function get(code) {
  return cache2[code] || cache2[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
}
function add(code, projection) {
  cache2[code] = projection;
}
var cache2;
var init_projections = __esm({
  "node_modules/ol/proj/projections.js"() {
    cache2 = {};
  }
});

// node_modules/ol/proj/transforms.js
function clear3() {
  transforms = {};
}
function add2(source, destination, transformFn) {
  const sourceCode = source.getCode();
  const destinationCode = destination.getCode();
  if (!(sourceCode in transforms)) {
    transforms[sourceCode] = {};
  }
  transforms[sourceCode][destinationCode] = transformFn;
}
function remove2(source, destination) {
  const sourceCode = source.getCode();
  const destinationCode = destination.getCode();
  const transform2 = transforms[sourceCode][destinationCode];
  delete transforms[sourceCode][destinationCode];
  if (isEmpty(transforms[sourceCode])) {
    delete transforms[sourceCode];
  }
  return transform2;
}
function get2(sourceCode, destinationCode) {
  let transform2;
  if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
    transform2 = transforms[sourceCode][destinationCode];
  }
  return transform2;
}
var transforms;
var init_transforms = __esm({
  "node_modules/ol/proj/transforms.js"() {
    init_obj();
    transforms = {};
  }
});

// node_modules/ol/string.js
function padNumber(number, width, precision) {
  const numberString = precision !== void 0 ? number.toFixed(precision) : "" + number;
  let decimal = numberString.indexOf(".");
  decimal = decimal === -1 ? numberString.length : decimal;
  return decimal > width ? numberString : new Array(1 + width - decimal).join("0") + numberString;
}
function compareVersions(v1, v2) {
  const s1 = ("" + v1).split(".");
  const s2 = ("" + v2).split(".");
  for (let i = 0; i < Math.max(s1.length, s2.length); i++) {
    const n1 = parseInt(s1[i] || "0", 10);
    const n2 = parseInt(s2[i] || "0", 10);
    if (n1 > n2) {
      return 1;
    }
    if (n2 > n1) {
      return -1;
    }
  }
  return 0;
}
var init_string = __esm({
  "node_modules/ol/string.js"() {
  }
});

// node_modules/ol/coordinate.js
function add3(coordinate, delta) {
  coordinate[0] += +delta[0];
  coordinate[1] += +delta[1];
  return coordinate;
}
function closestOnCircle(coordinate, circle) {
  const r = circle.getRadius();
  const center = circle.getCenter();
  const x0 = center[0];
  const y0 = center[1];
  const x1 = coordinate[0];
  const y1 = coordinate[1];
  let dx = x1 - x0;
  const dy = y1 - y0;
  if (dx === 0 && dy === 0) {
    dx = 1;
  }
  const d = Math.sqrt(dx * dx + dy * dy);
  const x = x0 + r * dx / d;
  const y = y0 + r * dy / d;
  return [x, y];
}
function closestOnSegment(coordinate, segment) {
  const x0 = coordinate[0];
  const y0 = coordinate[1];
  const start = segment[0];
  const end = segment[1];
  const x1 = start[0];
  const y1 = start[1];
  const x2 = end[0];
  const y2 = end[1];
  const dx = x2 - x1;
  const dy = y2 - y1;
  const along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
  let x, y;
  if (along <= 0) {
    x = x1;
    y = y1;
  } else if (along >= 1) {
    x = x2;
    y = y2;
  } else {
    x = x1 + along * dx;
    y = y1 + along * dy;
  }
  return [x, y];
}
function createStringXY(fractionDigits) {
  return (
    /**
     * @param {Coordinate} coordinate Coordinate.
     * @return {string} String XY.
     */
    function(coordinate) {
      return toStringXY(coordinate, fractionDigits);
    }
  );
}
function degreesToStringHDMS(hemispheres, degrees, fractionDigits) {
  const normalizedDegrees = modulo(degrees + 180, 360) - 180;
  const x = Math.abs(3600 * normalizedDegrees);
  const decimals = fractionDigits || 0;
  let deg = Math.floor(x / 3600);
  let min = Math.floor((x - deg * 3600) / 60);
  let sec = toFixed(x - deg * 3600 - min * 60, decimals);
  if (sec >= 60) {
    sec = 0;
    min += 1;
  }
  if (min >= 60) {
    min = 0;
    deg += 1;
  }
  let hdms = deg + "\xB0";
  if (min !== 0 || sec !== 0) {
    hdms += " " + padNumber(min, 2) + "\u2032";
  }
  if (sec !== 0) {
    hdms += " " + padNumber(sec, 2, decimals) + "\u2033";
  }
  if (normalizedDegrees !== 0) {
    hdms += " " + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0);
  }
  return hdms;
}
function format(coordinate, template, fractionDigits) {
  if (coordinate) {
    return template.replace("{x}", coordinate[0].toFixed(fractionDigits)).replace("{y}", coordinate[1].toFixed(fractionDigits));
  }
  return "";
}
function equals3(coordinate1, coordinate2) {
  let equals4 = true;
  for (let i = coordinate1.length - 1; i >= 0; --i) {
    if (coordinate1[i] != coordinate2[i]) {
      equals4 = false;
      break;
    }
  }
  return equals4;
}
function rotate2(coordinate, angle) {
  const cosAngle = Math.cos(angle);
  const sinAngle = Math.sin(angle);
  const x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  const y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  coordinate[0] = x;
  coordinate[1] = y;
  return coordinate;
}
function scale2(coordinate, scale5) {
  coordinate[0] *= scale5;
  coordinate[1] *= scale5;
  return coordinate;
}
function squaredDistance2(coord1, coord2) {
  const dx = coord1[0] - coord2[0];
  const dy = coord1[1] - coord2[1];
  return dx * dx + dy * dy;
}
function distance(coord1, coord2) {
  return Math.sqrt(squaredDistance2(coord1, coord2));
}
function squaredDistanceToSegment(coordinate, segment) {
  return squaredDistance2(coordinate, closestOnSegment(coordinate, segment));
}
function toStringHDMS(coordinate, fractionDigits) {
  if (coordinate) {
    return degreesToStringHDMS("NS", coordinate[1], fractionDigits) + " " + degreesToStringHDMS("EW", coordinate[0], fractionDigits);
  }
  return "";
}
function toStringXY(coordinate, fractionDigits) {
  return format(coordinate, "{x}, {y}", fractionDigits);
}
function wrapX2(coordinate, projection) {
  if (projection.canWrapX()) {
    const worldWidth = getWidth(projection.getExtent());
    const worldsAway = getWorldsAway(coordinate, projection, worldWidth);
    if (worldsAway) {
      coordinate[0] -= worldsAway * worldWidth;
    }
  }
  return coordinate;
}
function getWorldsAway(coordinate, projection, sourceExtentWidth) {
  const projectionExtent = projection.getExtent();
  let worldsAway = 0;
  if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
    sourceExtentWidth = sourceExtentWidth || getWidth(projectionExtent);
    worldsAway = Math.floor(
      (coordinate[0] - projectionExtent[0]) / sourceExtentWidth
    );
  }
  return worldsAway;
}
var init_coordinate = __esm({
  "node_modules/ol/coordinate.js"() {
    init_extent();
    init_math();
    init_string();
  }
});

// node_modules/ol/sphere.js
function getDistance(c1, c2, radius) {
  radius = radius || DEFAULT_RADIUS;
  const lat1 = toRadians(c1[1]);
  const lat2 = toRadians(c2[1]);
  const deltaLatBy2 = (lat2 - lat1) / 2;
  const deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;
  const a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
  return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}
function getLengthInternal(coordinates2, radius) {
  let length = 0;
  for (let i = 0, ii = coordinates2.length; i < ii - 1; ++i) {
    length += getDistance(coordinates2[i], coordinates2[i + 1], radius);
  }
  return length;
}
function getLength(geometry, options) {
  options = options || {};
  const radius = options.radius || DEFAULT_RADIUS;
  const projection = options.projection || "EPSG:3857";
  const type = geometry.getType();
  if (type !== "GeometryCollection") {
    geometry = geometry.clone().transform(projection, "EPSG:4326");
  }
  let length = 0;
  let coordinates2, coords, i, ii, j, jj;
  switch (type) {
    case "Point":
    case "MultiPoint": {
      break;
    }
    case "LineString":
    case "LinearRing": {
      coordinates2 = /** @type {import("./geom/SimpleGeometry.js").default} */
      geometry.getCoordinates();
      length = getLengthInternal(coordinates2, radius);
      break;
    }
    case "MultiLineString":
    case "Polygon": {
      coordinates2 = /** @type {import("./geom/SimpleGeometry.js").default} */
      geometry.getCoordinates();
      for (i = 0, ii = coordinates2.length; i < ii; ++i) {
        length += getLengthInternal(coordinates2[i], radius);
      }
      break;
    }
    case "MultiPolygon": {
      coordinates2 = /** @type {import("./geom/SimpleGeometry.js").default} */
      geometry.getCoordinates();
      for (i = 0, ii = coordinates2.length; i < ii; ++i) {
        coords = coordinates2[i];
        for (j = 0, jj = coords.length; j < jj; ++j) {
          length += getLengthInternal(coords[j], radius);
        }
      }
      break;
    }
    case "GeometryCollection": {
      const geometries = (
        /** @type {import("./geom/GeometryCollection.js").default} */
        geometry.getGeometries()
      );
      for (i = 0, ii = geometries.length; i < ii; ++i) {
        length += getLength(geometries[i], options);
      }
      break;
    }
    default: {
      throw new Error("Unsupported geometry type: " + type);
    }
  }
  return length;
}
function getAreaInternal(coordinates2, radius) {
  let area = 0;
  const len = coordinates2.length;
  let x1 = coordinates2[len - 1][0];
  let y1 = coordinates2[len - 1][1];
  for (let i = 0; i < len; i++) {
    const x2 = coordinates2[i][0];
    const y2 = coordinates2[i][1];
    area += toRadians(x2 - x1) * (2 + Math.sin(toRadians(y1)) + Math.sin(toRadians(y2)));
    x1 = x2;
    y1 = y2;
  }
  return area * radius * radius / 2;
}
function getArea2(geometry, options) {
  options = options || {};
  const radius = options.radius || DEFAULT_RADIUS;
  const projection = options.projection || "EPSG:3857";
  const type = geometry.getType();
  if (type !== "GeometryCollection") {
    geometry = geometry.clone().transform(projection, "EPSG:4326");
  }
  let area = 0;
  let coordinates2, coords, i, ii, j, jj;
  switch (type) {
    case "Point":
    case "MultiPoint":
    case "LineString":
    case "MultiLineString":
    case "LinearRing": {
      break;
    }
    case "Polygon": {
      coordinates2 = /** @type {import("./geom/Polygon.js").default} */
      geometry.getCoordinates();
      area = Math.abs(getAreaInternal(coordinates2[0], radius));
      for (i = 1, ii = coordinates2.length; i < ii; ++i) {
        area -= Math.abs(getAreaInternal(coordinates2[i], radius));
      }
      break;
    }
    case "MultiPolygon": {
      coordinates2 = /** @type {import("./geom/SimpleGeometry.js").default} */
      geometry.getCoordinates();
      for (i = 0, ii = coordinates2.length; i < ii; ++i) {
        coords = coordinates2[i];
        area += Math.abs(getAreaInternal(coords[0], radius));
        for (j = 1, jj = coords.length; j < jj; ++j) {
          area -= Math.abs(getAreaInternal(coords[j], radius));
        }
      }
      break;
    }
    case "GeometryCollection": {
      const geometries = (
        /** @type {import("./geom/GeometryCollection.js").default} */
        geometry.getGeometries()
      );
      for (i = 0, ii = geometries.length; i < ii; ++i) {
        area += getArea2(geometries[i], options);
      }
      break;
    }
    default: {
      throw new Error("Unsupported geometry type: " + type);
    }
  }
  return area;
}
function offset(c1, distance2, bearing, radius) {
  radius = radius || DEFAULT_RADIUS;
  const lat1 = toRadians(c1[1]);
  const lon1 = toRadians(c1[0]);
  const dByR = distance2 / radius;
  const lat = Math.asin(
    Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing)
  );
  const lon = lon1 + Math.atan2(
    Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),
    Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat)
  );
  return [toDegrees(lon), toDegrees(lat)];
}
var DEFAULT_RADIUS;
var init_sphere = __esm({
  "node_modules/ol/sphere.js"() {
    init_math();
    DEFAULT_RADIUS = 63710088e-1;
  }
});

// node_modules/ol/console.js
function setLevel(l) {
  level = levels[l];
}
function log(...args) {
  if (level > levels.info) {
    return;
  }
  console.log(...args);
}
function warn(...args) {
  if (level > levels.warn) {
    return;
  }
  console.warn(...args);
}
function error(...args) {
  if (level > levels.error) {
    return;
  }
  console.error(...args);
}
var levels, level;
var init_console = __esm({
  "node_modules/ol/console.js"() {
    levels = {
      info: 1,
      warn: 2,
      error: 3,
      none: 4
    };
    level = levels.info;
  }
});

// node_modules/ol/proj.js
var proj_exports = {};
__export(proj_exports, {
  METERS_PER_UNIT: () => METERS_PER_UNIT,
  Projection: () => Projection_default,
  addCommon: () => addCommon,
  addCoordinateTransforms: () => addCoordinateTransforms,
  addEquivalentProjections: () => addEquivalentProjections,
  addEquivalentTransforms: () => addEquivalentTransforms,
  addProjection: () => addProjection,
  addProjections: () => addProjections,
  clearAllProjections: () => clearAllProjections,
  clearUserProjection: () => clearUserProjection,
  cloneTransform: () => cloneTransform,
  createProjection: () => createProjection,
  createSafeCoordinateTransform: () => createSafeCoordinateTransform,
  createTransformFromCoordinateTransform: () => createTransformFromCoordinateTransform,
  disableCoordinateWarning: () => disableCoordinateWarning,
  equivalent: () => equivalent,
  fromLonLat: () => fromLonLat,
  fromUserCoordinate: () => fromUserCoordinate,
  fromUserExtent: () => fromUserExtent,
  fromUserResolution: () => fromUserResolution,
  get: () => get3,
  getPointResolution: () => getPointResolution,
  getTransform: () => getTransform,
  getTransformFromProjections: () => getTransformFromProjections,
  getUserProjection: () => getUserProjection,
  identityTransform: () => identityTransform,
  setUserProjection: () => setUserProjection,
  toLonLat: () => toLonLat,
  toUserCoordinate: () => toUserCoordinate,
  toUserExtent: () => toUserExtent,
  toUserResolution: () => toUserResolution,
  transform: () => transform,
  transformExtent: () => transformExtent,
  transformWithProjections: () => transformWithProjections,
  useGeographic: () => useGeographic
});
function disableCoordinateWarning(disable2) {
  const hide = disable2 === void 0 ? true : disable2;
  showCoordinateWarning = !hide;
}
function cloneTransform(input, output) {
  if (output !== void 0) {
    for (let i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }
    output = output;
  } else {
    output = input.slice();
  }
  return output;
}
function identityTransform(input, output) {
  if (output !== void 0 && input !== output) {
    for (let i = 0, ii = input.length; i < ii; ++i) {
      output[i] = input[i];
    }
    input = output;
  }
  return input;
}
function addProjection(projection) {
  add(projection.getCode(), projection);
  add2(projection, projection, cloneTransform);
}
function addProjections(projections) {
  projections.forEach(addProjection);
}
function get3(projectionLike) {
  return typeof projectionLike === "string" ? get(
    /** @type {string} */
    projectionLike
  ) : (
    /** @type {Projection} */
    projectionLike || null
  );
}
function getPointResolution(projection, resolution, point, units) {
  projection = get3(projection);
  let pointResolution;
  const getter = projection.getPointResolutionFunc();
  if (getter) {
    pointResolution = getter(resolution, point);
    if (units && units !== projection.getUnits()) {
      const metersPerUnit = projection.getMetersPerUnit();
      if (metersPerUnit) {
        pointResolution = pointResolution * metersPerUnit / METERS_PER_UNIT[units];
      }
    }
  } else {
    const projUnits = projection.getUnits();
    if (projUnits == "degrees" && !units || units == "degrees") {
      pointResolution = resolution;
    } else {
      const toEPSG43262 = getTransformFromProjections(
        projection,
        get3("EPSG:4326")
      );
      if (toEPSG43262 === identityTransform && projUnits !== "degrees") {
        pointResolution = resolution * projection.getMetersPerUnit();
      } else {
        let vertices = [
          point[0] - resolution / 2,
          point[1],
          point[0] + resolution / 2,
          point[1],
          point[0],
          point[1] - resolution / 2,
          point[0],
          point[1] + resolution / 2
        ];
        vertices = toEPSG43262(vertices, vertices, 2);
        const width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));
        const height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));
        pointResolution = (width + height) / 2;
      }
      const metersPerUnit = units ? METERS_PER_UNIT[units] : projection.getMetersPerUnit();
      if (metersPerUnit !== void 0) {
        pointResolution /= metersPerUnit;
      }
    }
  }
  return pointResolution;
}
function addEquivalentProjections(projections) {
  addProjections(projections);
  projections.forEach(function(source) {
    projections.forEach(function(destination) {
      if (source !== destination) {
        add2(source, destination, cloneTransform);
      }
    });
  });
}
function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
  projections1.forEach(function(projection1) {
    projections2.forEach(function(projection2) {
      add2(projection1, projection2, forwardTransform);
      add2(projection2, projection1, inverseTransform);
    });
  });
}
function clearAllProjections() {
  clear2();
  clear3();
}
function createProjection(projection, defaultCode) {
  if (!projection) {
    return get3(defaultCode);
  }
  if (typeof projection === "string") {
    return get3(projection);
  }
  return (
    /** @type {Projection} */
    projection
  );
}
function createTransformFromCoordinateTransform(coordTransform) {
  return (
    /**
     * @param {Array<number>} input Input.
     * @param {Array<number>} [output] Output.
     * @param {number} [dimension] Dimension.
     * @return {Array<number>} Output.
     */
    function(input, output, dimension) {
      const length = input.length;
      dimension = dimension !== void 0 ? dimension : 2;
      output = output !== void 0 ? output : new Array(length);
      for (let i = 0; i < length; i += dimension) {
        const point = coordTransform(input.slice(i, i + dimension));
        const pointLength = point.length;
        for (let j = 0, jj = dimension; j < jj; ++j) {
          output[i + j] = j >= pointLength ? input[i + j] : point[j];
        }
      }
      return output;
    }
  );
}
function addCoordinateTransforms(source, destination, forward, inverse) {
  const sourceProj = get3(source);
  const destProj = get3(destination);
  add2(
    sourceProj,
    destProj,
    createTransformFromCoordinateTransform(forward)
  );
  add2(
    destProj,
    sourceProj,
    createTransformFromCoordinateTransform(inverse)
  );
}
function fromLonLat(coordinate, projection) {
  disableCoordinateWarning();
  return transform(
    coordinate,
    "EPSG:4326",
    projection !== void 0 ? projection : "EPSG:3857"
  );
}
function toLonLat(coordinate, projection) {
  const lonLat = transform(
    coordinate,
    projection !== void 0 ? projection : "EPSG:3857",
    "EPSG:4326"
  );
  const lon = lonLat[0];
  if (lon < -180 || lon > 180) {
    lonLat[0] = modulo(lon + 180, 360) - 180;
  }
  return lonLat;
}
function equivalent(projection1, projection2) {
  if (projection1 === projection2) {
    return true;
  }
  const equalUnits = projection1.getUnits() === projection2.getUnits();
  if (projection1.getCode() === projection2.getCode()) {
    return equalUnits;
  }
  const transformFunc = getTransformFromProjections(projection1, projection2);
  return transformFunc === cloneTransform && equalUnits;
}
function getTransformFromProjections(sourceProjection, destinationProjection) {
  const sourceCode = sourceProjection.getCode();
  const destinationCode = destinationProjection.getCode();
  let transformFunc = get2(sourceCode, destinationCode);
  if (!transformFunc) {
    transformFunc = identityTransform;
  }
  return transformFunc;
}
function getTransform(source, destination) {
  const sourceProjection = get3(source);
  const destinationProjection = get3(destination);
  return getTransformFromProjections(sourceProjection, destinationProjection);
}
function transform(coordinate, source, destination) {
  const transformFunc = getTransform(source, destination);
  return transformFunc(coordinate, void 0, coordinate.length);
}
function transformExtent(extent, source, destination, stops) {
  const transformFunc = getTransform(source, destination);
  return applyTransform(extent, transformFunc, void 0, stops);
}
function transformWithProjections(point, sourceProjection, destinationProjection) {
  const transformFunc = getTransformFromProjections(
    sourceProjection,
    destinationProjection
  );
  return transformFunc(point);
}
function setUserProjection(projection) {
  userProjection = get3(projection);
}
function clearUserProjection() {
  userProjection = null;
}
function getUserProjection() {
  return userProjection;
}
function useGeographic() {
  setUserProjection("EPSG:4326");
}
function toUserCoordinate(coordinate, sourceProjection) {
  if (!userProjection) {
    return coordinate;
  }
  return transform(coordinate, sourceProjection, userProjection);
}
function fromUserCoordinate(coordinate, destProjection) {
  if (!userProjection) {
    if (showCoordinateWarning && !equals3(coordinate, [0, 0]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {
      showCoordinateWarning = false;
      warn(
        "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
      );
    }
    return coordinate;
  }
  return transform(coordinate, userProjection, destProjection);
}
function toUserExtent(extent, sourceProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, sourceProjection, userProjection);
}
function fromUserExtent(extent, destProjection) {
  if (!userProjection) {
    return extent;
  }
  return transformExtent(extent, userProjection, destProjection);
}
function toUserResolution(resolution, sourceProjection) {
  if (!userProjection) {
    return resolution;
  }
  const sourceMetersPerUnit = get3(sourceProjection).getMetersPerUnit();
  const userMetersPerUnit = userProjection.getMetersPerUnit();
  return sourceMetersPerUnit && userMetersPerUnit ? resolution * sourceMetersPerUnit / userMetersPerUnit : resolution;
}
function fromUserResolution(resolution, destProjection) {
  if (!userProjection) {
    return resolution;
  }
  const destMetersPerUnit = get3(destProjection).getMetersPerUnit();
  const userMetersPerUnit = userProjection.getMetersPerUnit();
  return destMetersPerUnit && userMetersPerUnit ? resolution * userMetersPerUnit / destMetersPerUnit : resolution;
}
function createSafeCoordinateTransform(sourceProj, destProj, transform2) {
  return function(coord) {
    let transformed, worldsAway;
    if (sourceProj.canWrapX()) {
      const sourceExtent = sourceProj.getExtent();
      const sourceExtentWidth = getWidth(sourceExtent);
      coord = coord.slice(0);
      worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);
      if (worldsAway) {
        coord[0] = coord[0] - worldsAway * sourceExtentWidth;
      }
      coord[0] = clamp(coord[0], sourceExtent[0], sourceExtent[2]);
      coord[1] = clamp(coord[1], sourceExtent[1], sourceExtent[3]);
      transformed = transform2(coord);
    } else {
      transformed = transform2(coord);
    }
    if (worldsAway && destProj.canWrapX()) {
      transformed[0] += worldsAway * getWidth(destProj.getExtent());
    }
    return transformed;
  };
}
function addCommon() {
  addEquivalentProjections(PROJECTIONS);
  addEquivalentProjections(PROJECTIONS2);
  addEquivalentTransforms(
    PROJECTIONS2,
    PROJECTIONS,
    fromEPSG4326,
    toEPSG4326
  );
}
var showCoordinateWarning, userProjection;
var init_proj = __esm({
  "node_modules/ol/proj.js"() {
    init_Projection();
    init_epsg3857();
    init_epsg4326();
    init_Units();
    init_projections();
    init_transforms();
    init_extent();
    init_math();
    init_coordinate();
    init_sphere();
    init_console();
    showCoordinateWarning = true;
    userProjection = null;
    addCommon();
  }
});

// node_modules/ol/centerconstraint.js
function createExtent(extent, onlyCenter, smooth) {
  return (
    /**
     * @param {import("./coordinate.js").Coordinate|undefined} center Center.
     * @param {number|undefined} resolution Resolution.
     * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @param {Array<number>} [centerShift] Shift between map center and viewport center.
     * @return {import("./coordinate.js").Coordinate|undefined} Center.
     */
    function(center, resolution, size, isMoving, centerShift) {
      if (!center) {
        return void 0;
      }
      if (!resolution && !onlyCenter) {
        return center;
      }
      const viewWidth = onlyCenter ? 0 : size[0] * resolution;
      const viewHeight = onlyCenter ? 0 : size[1] * resolution;
      const shiftX = centerShift ? centerShift[0] : 0;
      const shiftY = centerShift ? centerShift[1] : 0;
      let minX = extent[0] + viewWidth / 2 + shiftX;
      let maxX = extent[2] - viewWidth / 2 + shiftX;
      let minY = extent[1] + viewHeight / 2 + shiftY;
      let maxY = extent[3] - viewHeight / 2 + shiftY;
      if (minX > maxX) {
        minX = (maxX + minX) / 2;
        maxX = minX;
      }
      if (minY > maxY) {
        minY = (maxY + minY) / 2;
        maxY = minY;
      }
      let x = clamp(center[0], minX, maxX);
      let y = clamp(center[1], minY, maxY);
      if (isMoving && smooth && resolution) {
        const ratio = 30 * resolution;
        x += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
        y += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
      }
      return [x, y];
    }
  );
}
function none(center) {
  return center;
}
var init_centerconstraint = __esm({
  "node_modules/ol/centerconstraint.js"() {
    init_math();
  }
});

// node_modules/ol/resolutionconstraint.js
function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
  const xResolution = getWidth(maxExtent) / viewportSize[0];
  const yResolution = getHeight(maxExtent) / viewportSize[1];
  if (showFullExtent) {
    return Math.min(resolution, Math.max(xResolution, yResolution));
  }
  return Math.min(resolution, Math.min(xResolution, yResolution));
}
function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
  let result = Math.min(resolution, maxResolution);
  const ratio = 50;
  result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;
  if (minResolution) {
    result = Math.max(result, minResolution);
    result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
  }
  return clamp(result, minResolution / 2, maxResolution * 2);
}
function createSnapToResolutions(resolutions, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const maxResolution = resolutions[0];
        const minResolution = resolutions[resolutions.length - 1];
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (isMoving) {
          if (!smooth) {
            return clamp(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution
          );
        }
        const capped = Math.min(cappedMaxRes, resolution);
        const z = Math.floor(linearFindNearest(resolutions, capped, direction));
        if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
          return resolutions[z + 1];
        }
        return resolutions[z];
      }
      return void 0;
    }
  );
}
function createSnapToPower(power, maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  minResolution = minResolution !== void 0 ? minResolution : 0;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (isMoving) {
          if (!smooth) {
            return clamp(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution
          );
        }
        const tolerance = 1e-9;
        const minZoomLevel = Math.ceil(
          Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance
        );
        const offset2 = -direction * (0.5 - tolerance) + 0.5;
        const capped = Math.min(cappedMaxRes, resolution);
        const cappedZoomLevel = Math.floor(
          Math.log(maxResolution / capped) / Math.log(power) + offset2
        );
        const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
        const newResolution = maxResolution / Math.pow(power, zoomLevel);
        return clamp(newResolution, minResolution, cappedMaxRes);
      }
      return void 0;
    }
  );
}
function createMinMaxResolution(maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
  smooth = smooth !== void 0 ? smooth : true;
  return (
    /**
     * @param {number|undefined} resolution Resolution.
     * @param {number} direction Direction.
     * @param {import("./size.js").Size} size Viewport size.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Resolution.
     */
    function(resolution, direction, size, isMoving) {
      if (resolution !== void 0) {
        const cappedMaxRes = maxExtent ? getViewportClampedResolution(
          maxResolution,
          maxExtent,
          size,
          showFullExtent
        ) : maxResolution;
        if (!smooth || !isMoving) {
          return clamp(resolution, minResolution, cappedMaxRes);
        }
        return getSmoothClampedResolution(
          resolution,
          cappedMaxRes,
          minResolution
        );
      }
      return void 0;
    }
  );
}
var init_resolutionconstraint = __esm({
  "node_modules/ol/resolutionconstraint.js"() {
    init_math();
    init_extent();
    init_array();
  }
});

// node_modules/ol/rotationconstraint.js
function disable(rotation) {
  if (rotation !== void 0) {
    return 0;
  }
  return void 0;
}
function none2(rotation) {
  if (rotation !== void 0) {
    return rotation;
  }
  return void 0;
}
function createSnapToN(n) {
  const theta = 2 * Math.PI / n;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(rotation, isMoving) {
      if (isMoving) {
        return rotation;
      }
      if (rotation !== void 0) {
        rotation = Math.floor(rotation / theta + 0.5) * theta;
        return rotation;
      }
      return void 0;
    }
  );
}
function createSnapToZero(tolerance) {
  const t = tolerance === void 0 ? toRadians(5) : tolerance;
  return (
    /**
     * @param {number|undefined} rotation Rotation.
     * @param {boolean} [isMoving] True if an interaction or animation is in progress.
     * @return {number|undefined} Rotation.
     */
    function(rotation, isMoving) {
      if (isMoving || rotation === void 0) {
        return rotation;
      }
      if (Math.abs(rotation) <= t) {
        return 0;
      }
      return rotation;
    }
  );
}
var init_rotationconstraint = __esm({
  "node_modules/ol/rotationconstraint.js"() {
    init_math();
  }
});

// node_modules/ol/easing.js
function easeIn(t) {
  return Math.pow(t, 3);
}
function easeOut(t) {
  return 1 - easeIn(1 - t);
}
function inAndOut(t) {
  return 3 * t * t - 2 * t * t * t;
}
function linear(t) {
  return t;
}
function upAndDown(t) {
  if (t < 0.5) {
    return inAndOut(2 * t);
  }
  return 1 - inAndOut(2 * (t - 0.5));
}
var init_easing = __esm({
  "node_modules/ol/easing.js"() {
  }
});

// node_modules/ol/geom/flat/transform.js
function transform2D(flatCoordinates, offset2, end, stride, transform2, dest) {
  dest = dest ? dest : [];
  let i = 0;
  for (let j = offset2; j < end; j += stride) {
    const x = flatCoordinates[j];
    const y = flatCoordinates[j + 1];
    dest[i++] = transform2[0] * x + transform2[2] * y + transform2[4];
    dest[i++] = transform2[1] * x + transform2[3] * y + transform2[5];
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function rotate3(flatCoordinates, offset2, end, stride, angle, anchor, dest) {
  dest = dest ? dest : [];
  const cos = Math.cos(angle);
  const sin = Math.sin(angle);
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset2; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + deltaX * cos - deltaY * sin;
    dest[i++] = anchorY + deltaX * sin + deltaY * cos;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function scale3(flatCoordinates, offset2, end, stride, sx, sy, anchor, dest) {
  dest = dest ? dest : [];
  const anchorX = anchor[0];
  const anchorY = anchor[1];
  let i = 0;
  for (let j = offset2; j < end; j += stride) {
    const deltaX = flatCoordinates[j] - anchorX;
    const deltaY = flatCoordinates[j + 1] - anchorY;
    dest[i++] = anchorX + sx * deltaX;
    dest[i++] = anchorY + sy * deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
function translate2(flatCoordinates, offset2, end, stride, deltaX, deltaY, dest) {
  dest = dest ? dest : [];
  let i = 0;
  for (let j = offset2; j < end; j += stride) {
    dest[i++] = flatCoordinates[j] + deltaX;
    dest[i++] = flatCoordinates[j + 1] + deltaY;
    for (let k = j + 2; k < j + stride; ++k) {
      dest[i++] = flatCoordinates[k];
    }
  }
  if (dest && dest.length != i) {
    dest.length = i;
  }
  return dest;
}
var init_transform2 = __esm({
  "node_modules/ol/geom/flat/transform.js"() {
  }
});

// node_modules/ol/geom/Geometry.js
var tmpTransform, Geometry, Geometry_default;
var init_Geometry = __esm({
  "node_modules/ol/geom/Geometry.js"() {
    init_Object();
    init_util();
    init_transform();
    init_extent();
    init_proj();
    init_functions();
    init_transform2();
    tmpTransform = create();
    Geometry = class extends Object_default {
      constructor() {
        super();
        this.extent_ = createEmpty();
        this.extentRevision_ = -1;
        this.simplifiedGeometryMaxMinSquaredTolerance = 0;
        this.simplifiedGeometryRevision = 0;
        this.simplifyTransformedInternal = memoizeOne(
          (revision, squaredTolerance, transform2) => {
            if (!transform2) {
              return this.getSimplifiedGeometry(squaredTolerance);
            }
            const clone2 = this.clone();
            clone2.applyTransform(transform2);
            return clone2.getSimplifiedGeometry(squaredTolerance);
          }
        );
      }
      /**
       * Get a transformed and simplified version of the geometry.
       * @abstract
       * @param {number} squaredTolerance Squared tolerance.
       * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
       * @return {Geometry} Simplified geometry.
       */
      simplifyTransformed(squaredTolerance, transform2) {
        return this.simplifyTransformedInternal(
          this.getRevision(),
          squaredTolerance,
          transform2
        );
      }
      /**
       * Make a complete copy of the geometry.
       * @abstract
       * @return {!Geometry} Clone.
       */
      clone() {
        return abstract();
      }
      /**
       * @abstract
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        return abstract();
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */
      containsXY(x, y) {
        const coord = this.getClosestPoint([x, y]);
        return coord[0] === x && coord[1] === y;
      }
      /**
       * Return the closest point of the geometry to the passed point as
       * {@link module:ol/coordinate~Coordinate coordinate}.
       * @param {import("../coordinate.js").Coordinate} point Point.
       * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
       * @return {import("../coordinate.js").Coordinate} Closest point.
       * @api
       */
      getClosestPoint(point, closestPoint) {
        closestPoint = closestPoint ? closestPoint : [NaN, NaN];
        this.closestPointXY(point[0], point[1], closestPoint, Infinity);
        return closestPoint;
      }
      /**
       * Returns true if this geometry includes the specified coordinate. If the
       * coordinate is on the boundary of the geometry, returns false.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @return {boolean} Contains coordinate.
       * @api
       */
      intersectsCoordinate(coordinate) {
        return this.containsXY(coordinate[0], coordinate[1]);
      }
      /**
       * @abstract
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      computeExtent(extent) {
        return abstract();
      }
      /**
       * Get the extent of the geometry.
       * @param {import("../extent.js").Extent} [extent] Extent.
       * @return {import("../extent.js").Extent} extent Extent.
       * @api
       */
      getExtent(extent) {
        if (this.extentRevision_ != this.getRevision()) {
          const extent2 = this.computeExtent(this.extent_);
          if (isNaN(extent2[0]) || isNaN(extent2[1])) {
            createOrUpdateEmpty(extent2);
          }
          this.extentRevision_ = this.getRevision();
        }
        return returnOrUpdate(this.extent_, extent);
      }
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} angle Rotation angle in radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       */
      rotate(angle, anchor) {
        abstract();
      }
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       */
      scale(sx, sy, anchor) {
        abstract();
      }
      /**
       * Create a simplified version of this geometry.  For linestrings, this uses
       * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
       * algorithm.  For polygons, a quantization-based
       * simplification is used to preserve topology.
       * @param {number} tolerance The tolerance distance for simplification.
       * @return {Geometry} A new, simplified version of the original geometry.
       * @api
       */
      simplify(tolerance) {
        return this.getSimplifiedGeometry(tolerance * tolerance);
      }
      /**
       * Create a simplified version of this geometry using the Douglas Peucker
       * algorithm.
       * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
       * @abstract
       * @param {number} squaredTolerance Squared tolerance.
       * @return {Geometry} Simplified geometry.
       */
      getSimplifiedGeometry(squaredTolerance) {
        return abstract();
      }
      /**
       * Get the type of this geometry.
       * @abstract
       * @return {Type} Geometry type.
       */
      getType() {
        return abstract();
      }
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @abstract
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       */
      applyTransform(transformFn) {
        abstract();
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @abstract
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       */
      intersectsExtent(extent) {
        return abstract();
      }
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @abstract
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       */
      translate(deltaX, deltaY) {
        abstract();
      }
      /**
       * Transform each coordinate of the geometry from one coordinate reference
       * system to another. The geometry is modified in place.
       * For example, a line will be transformed to a line and a circle to a circle.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       *
       * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
       *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
       * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
       *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
       * @return {Geometry} This geometry.  Note that original geometry is
       *     modified in place.
       * @api
       */
      transform(source, destination) {
        const sourceProj = get3(source);
        const transformFn = sourceProj.getUnits() == "tile-pixels" ? function(inCoordinates, outCoordinates, stride) {
          const pixelExtent = sourceProj.getExtent();
          const projectedExtent = sourceProj.getWorldExtent();
          const scale5 = getHeight(projectedExtent) / getHeight(pixelExtent);
          compose(
            tmpTransform,
            projectedExtent[0],
            projectedExtent[3],
            scale5,
            -scale5,
            0,
            0,
            0
          );
          transform2D(
            inCoordinates,
            0,
            inCoordinates.length,
            stride,
            tmpTransform,
            outCoordinates
          );
          return getTransform(sourceProj, destination)(
            inCoordinates,
            outCoordinates,
            stride
          );
        } : getTransform(sourceProj, destination);
        this.applyTransform(transformFn);
        return this;
      }
    };
    Geometry_default = Geometry;
  }
});

// node_modules/ol/geom/SimpleGeometry.js
function getLayoutForStride(stride) {
  let layout;
  if (stride == 2) {
    layout = "XY";
  } else if (stride == 3) {
    layout = "XYZ";
  } else if (stride == 4) {
    layout = "XYZM";
  }
  return (
    /** @type {import("./Geometry.js").GeometryLayout} */
    layout
  );
}
function getStrideForLayout(layout) {
  let stride;
  if (layout == "XY") {
    stride = 2;
  } else if (layout == "XYZ" || layout == "XYM") {
    stride = 3;
  } else if (layout == "XYZM") {
    stride = 4;
  }
  return (
    /** @type {number} */
    stride
  );
}
function transformGeom2D(simpleGeometry, transform2, dest) {
  const flatCoordinates = simpleGeometry.getFlatCoordinates();
  if (!flatCoordinates) {
    return null;
  }
  const stride = simpleGeometry.getStride();
  return transform2D(
    flatCoordinates,
    0,
    flatCoordinates.length,
    stride,
    transform2,
    dest
  );
}
var SimpleGeometry, SimpleGeometry_default;
var init_SimpleGeometry = __esm({
  "node_modules/ol/geom/SimpleGeometry.js"() {
    init_Geometry();
    init_util();
    init_extent();
    init_transform2();
    SimpleGeometry = class extends Geometry_default {
      constructor() {
        super();
        this.layout = "XY";
        this.stride = 2;
        this.flatCoordinates;
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      computeExtent(extent) {
        return createOrUpdateFromFlatCoordinates(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          extent
        );
      }
      /**
       * @abstract
       * @return {Array<*> | null} Coordinates.
       */
      getCoordinates() {
        return abstract();
      }
      /**
       * Return the first coordinate of the geometry.
       * @return {import("../coordinate.js").Coordinate} First coordinate.
       * @api
       */
      getFirstCoordinate() {
        return this.flatCoordinates.slice(0, this.stride);
      }
      /**
       * @return {Array<number>} Flat coordinates.
       */
      getFlatCoordinates() {
        return this.flatCoordinates;
      }
      /**
       * Return the last coordinate of the geometry.
       * @return {import("../coordinate.js").Coordinate} Last point.
       * @api
       */
      getLastCoordinate() {
        return this.flatCoordinates.slice(
          this.flatCoordinates.length - this.stride
        );
      }
      /**
       * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
       * @return {import("./Geometry.js").GeometryLayout} Layout.
       * @api
       */
      getLayout() {
        return this.layout;
      }
      /**
       * Create a simplified version of this geometry using the Douglas Peucker algorithm.
       * @param {number} squaredTolerance Squared tolerance.
       * @return {SimpleGeometry} Simplified geometry.
       */
      getSimplifiedGeometry(squaredTolerance) {
        if (this.simplifiedGeometryRevision !== this.getRevision()) {
          this.simplifiedGeometryMaxMinSquaredTolerance = 0;
          this.simplifiedGeometryRevision = this.getRevision();
        }
        if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
          return this;
        }
        const simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
        const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
        if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
          return simplifiedGeometry;
        }
        this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
        return this;
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {SimpleGeometry} Simplified geometry.
       * @protected
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        return this;
      }
      /**
       * @return {number} Stride.
       */
      getStride() {
        return this.stride;
      }
      /**
       * @param {import("./Geometry.js").GeometryLayout} layout Layout.
       * @param {Array<number>} flatCoordinates Flat coordinates.
       */
      setFlatCoordinates(layout, flatCoordinates) {
        this.stride = getStrideForLayout(layout);
        this.layout = layout;
        this.flatCoordinates = flatCoordinates;
      }
      /**
       * @abstract
       * @param {!Array<*>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      setCoordinates(coordinates2, layout) {
        abstract();
      }
      /**
       * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
       * @param {Array<*>} coordinates Coordinates.
       * @param {number} nesting Nesting.
       * @protected
       */
      setLayout(layout, coordinates2, nesting) {
        let stride;
        if (layout) {
          stride = getStrideForLayout(layout);
        } else {
          for (let i = 0; i < nesting; ++i) {
            if (coordinates2.length === 0) {
              this.layout = "XY";
              this.stride = 2;
              return;
            }
            coordinates2 = /** @type {Array<unknown>} */
            coordinates2[0];
          }
          stride = coordinates2.length;
          layout = getLayoutForStride(stride);
        }
        this.layout = layout;
        this.stride = stride;
      }
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       * @api
       */
      applyTransform(transformFn) {
        if (this.flatCoordinates) {
          transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
          this.changed();
        }
      }
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @param {number} angle Rotation angle in counter-clockwise radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       */
      rotate(angle, anchor) {
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
          const stride = this.getStride();
          rotate3(
            flatCoordinates,
            0,
            flatCoordinates.length,
            stride,
            angle,
            anchor,
            flatCoordinates
          );
          this.changed();
        }
      }
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       */
      scale(sx, sy, anchor) {
        if (sy === void 0) {
          sy = sx;
        }
        if (!anchor) {
          anchor = getCenter(this.getExtent());
        }
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
          const stride = this.getStride();
          scale3(
            flatCoordinates,
            0,
            flatCoordinates.length,
            stride,
            sx,
            sy,
            anchor,
            flatCoordinates
          );
          this.changed();
        }
      }
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       */
      translate(deltaX, deltaY) {
        const flatCoordinates = this.getFlatCoordinates();
        if (flatCoordinates) {
          const stride = this.getStride();
          translate2(
            flatCoordinates,
            0,
            flatCoordinates.length,
            stride,
            deltaX,
            deltaY,
            flatCoordinates
          );
          this.changed();
        }
      }
    };
    SimpleGeometry_default = SimpleGeometry;
  }
});

// node_modules/ol/geom/flat/closest.js
function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
  const x1 = flatCoordinates[offset1];
  const y1 = flatCoordinates[offset1 + 1];
  const dx = flatCoordinates[offset2] - x1;
  const dy = flatCoordinates[offset2 + 1] - y1;
  let offset3;
  if (dx === 0 && dy === 0) {
    offset3 = offset1;
  } else {
    const t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      offset3 = offset2;
    } else if (t > 0) {
      for (let i = 0; i < stride; ++i) {
        closestPoint[i] = lerp(
          flatCoordinates[offset1 + i],
          flatCoordinates[offset2 + i],
          t
        );
      }
      closestPoint.length = stride;
      return;
    } else {
      offset3 = offset1;
    }
  }
  for (let i = 0; i < stride; ++i) {
    closestPoint[i] = flatCoordinates[offset3 + i];
  }
  closestPoint.length = stride;
}
function maxSquaredDelta(flatCoordinates, offset2, end, stride, max) {
  let x1 = flatCoordinates[offset2];
  let y1 = flatCoordinates[offset2 + 1];
  for (offset2 += stride; offset2 < end; offset2 += stride) {
    const x2 = flatCoordinates[offset2];
    const y2 = flatCoordinates[offset2 + 1];
    const squaredDelta = squaredDistance(x1, y1, x2, y2);
    if (squaredDelta > max) {
      max = squaredDelta;
    }
    x1 = x2;
    y1 = y2;
  }
  return max;
}
function arrayMaxSquaredDelta(flatCoordinates, offset2, ends, stride, max) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    max = maxSquaredDelta(flatCoordinates, offset2, end, stride, max);
    offset2 = end;
  }
  return max;
}
function multiArrayMaxSquaredDelta(flatCoordinates, offset2, endss, stride, max) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    max = arrayMaxSquaredDelta(flatCoordinates, offset2, ends, stride, max);
    offset2 = ends[ends.length - 1];
  }
  return max;
}
function assignClosestPoint(flatCoordinates, offset2, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  if (offset2 == end) {
    return minSquaredDistance;
  }
  let i, squaredDistance3;
  if (maxDelta === 0) {
    squaredDistance3 = squaredDistance(
      x,
      y,
      flatCoordinates[offset2],
      flatCoordinates[offset2 + 1]
    );
    if (squaredDistance3 < minSquaredDistance) {
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = flatCoordinates[offset2 + i];
      }
      closestPoint.length = stride;
      return squaredDistance3;
    }
    return minSquaredDistance;
  }
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  let index = offset2 + stride;
  while (index < end) {
    assignClosest(
      flatCoordinates,
      index - stride,
      index,
      stride,
      x,
      y,
      tmpPoint
    );
    squaredDistance3 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance3 < minSquaredDistance) {
      minSquaredDistance = squaredDistance3;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
      index += stride;
    } else {
      index += stride * Math.max(
        (Math.sqrt(squaredDistance3) - Math.sqrt(minSquaredDistance)) / maxDelta | 0,
        1
      );
    }
  }
  if (isRing) {
    assignClosest(
      flatCoordinates,
      end - stride,
      offset2,
      stride,
      x,
      y,
      tmpPoint
    );
    squaredDistance3 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
    if (squaredDistance3 < minSquaredDistance) {
      minSquaredDistance = squaredDistance3;
      for (i = 0; i < stride; ++i) {
        closestPoint[i] = tmpPoint[i];
      }
      closestPoint.length = stride;
    }
  }
  return minSquaredDistance;
}
function assignClosestArrayPoint(flatCoordinates, offset2, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    minSquaredDistance = assignClosestPoint(
      flatCoordinates,
      offset2,
      end,
      stride,
      maxDelta,
      isRing,
      x,
      y,
      closestPoint,
      minSquaredDistance,
      tmpPoint
    );
    offset2 = end;
  }
  return minSquaredDistance;
}
function assignClosestMultiArrayPoint(flatCoordinates, offset2, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint) {
  tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    minSquaredDistance = assignClosestArrayPoint(
      flatCoordinates,
      offset2,
      ends,
      stride,
      maxDelta,
      isRing,
      x,
      y,
      closestPoint,
      minSquaredDistance,
      tmpPoint
    );
    offset2 = ends[ends.length - 1];
  }
  return minSquaredDistance;
}
var init_closest = __esm({
  "node_modules/ol/geom/flat/closest.js"() {
    init_math();
  }
});

// node_modules/ol/geom/flat/deflate.js
function deflateCoordinate(flatCoordinates, offset2, coordinate, stride) {
  for (let i = 0, ii = coordinate.length; i < ii; ++i) {
    flatCoordinates[offset2++] = coordinate[i];
  }
  return offset2;
}
function deflateCoordinates(flatCoordinates, offset2, coordinates2, stride) {
  for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
    const coordinate = coordinates2[i];
    for (let j = 0; j < stride; ++j) {
      flatCoordinates[offset2++] = coordinate[j];
    }
  }
  return offset2;
}
function deflateCoordinatesArray(flatCoordinates, offset2, coordinatess, stride, ends) {
  ends = ends ? ends : [];
  let i = 0;
  for (let j = 0, jj = coordinatess.length; j < jj; ++j) {
    const end = deflateCoordinates(
      flatCoordinates,
      offset2,
      coordinatess[j],
      stride
    );
    ends[i++] = end;
    offset2 = end;
  }
  ends.length = i;
  return ends;
}
function deflateMultiCoordinatesArray(flatCoordinates, offset2, coordinatesss, stride, endss) {
  endss = endss ? endss : [];
  let i = 0;
  for (let j = 0, jj = coordinatesss.length; j < jj; ++j) {
    const ends = deflateCoordinatesArray(
      flatCoordinates,
      offset2,
      coordinatesss[j],
      stride,
      endss[i]
    );
    if (ends.length === 0) {
      ends[0] = offset2;
    }
    endss[i++] = ends;
    offset2 = ends[ends.length - 1];
  }
  endss.length = i;
  return endss;
}
var init_deflate = __esm({
  "node_modules/ol/geom/flat/deflate.js"() {
  }
});

// node_modules/ol/geom/flat/simplify.js
function simplifyLineString(flatCoordinates, offset2, end, stride, squaredTolerance, highQuality, simplifiedFlatCoordinates) {
  simplifiedFlatCoordinates = simplifiedFlatCoordinates !== void 0 ? simplifiedFlatCoordinates : [];
  if (!highQuality) {
    end = radialDistance(
      flatCoordinates,
      offset2,
      end,
      stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      0
    );
    flatCoordinates = simplifiedFlatCoordinates;
    offset2 = 0;
    stride = 2;
  }
  simplifiedFlatCoordinates.length = douglasPeucker(
    flatCoordinates,
    offset2,
    end,
    stride,
    squaredTolerance,
    simplifiedFlatCoordinates,
    0
  );
  return simplifiedFlatCoordinates;
}
function douglasPeucker(flatCoordinates, offset2, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  const n = (end - offset2) / stride;
  if (n < 3) {
    for (; offset2 < end; offset2 += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + 1];
    }
    return simplifiedOffset;
  }
  const markers = new Array(n);
  markers[0] = 1;
  markers[n - 1] = 1;
  const stack = [offset2, end - stride];
  let index = 0;
  while (stack.length > 0) {
    const last = stack.pop();
    const first = stack.pop();
    let maxSquaredDistance = 0;
    const x1 = flatCoordinates[first];
    const y1 = flatCoordinates[first + 1];
    const x2 = flatCoordinates[last];
    const y2 = flatCoordinates[last + 1];
    for (let i = first + stride; i < last; i += stride) {
      const x = flatCoordinates[i];
      const y = flatCoordinates[i + 1];
      const squaredDistance3 = squaredSegmentDistance(x, y, x1, y1, x2, y2);
      if (squaredDistance3 > maxSquaredDistance) {
        index = i;
        maxSquaredDistance = squaredDistance3;
      }
    }
    if (maxSquaredDistance > squaredTolerance) {
      markers[(index - offset2) / stride] = 1;
      if (first + stride < index) {
        stack.push(first, index);
      }
      if (index + stride < last) {
        stack.push(index, last);
      }
    }
  }
  for (let i = 0; i < n; ++i) {
    if (markers[i]) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + i * stride];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + i * stride + 1];
    }
  }
  return simplifiedOffset;
}
function douglasPeuckerArray(flatCoordinates, offset2, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    simplifiedOffset = douglasPeucker(
      flatCoordinates,
      offset2,
      end,
      stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset
    );
    simplifiedEnds.push(simplifiedOffset);
    offset2 = end;
  }
  return simplifiedOffset;
}
function douglasPeuckerMultiArray(flatCoordinates, offset2, endss, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    const simplifiedEnds = [];
    simplifiedOffset = douglasPeuckerArray(
      flatCoordinates,
      offset2,
      ends,
      stride,
      squaredTolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset,
      simplifiedEnds
    );
    simplifiedEndss.push(simplifiedEnds);
    offset2 = ends[ends.length - 1];
  }
  return simplifiedOffset;
}
function radialDistance(flatCoordinates, offset2, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (end <= offset2 + stride) {
    for (; offset2 < end; offset2 += stride) {
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2];
      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + 1];
    }
    return simplifiedOffset;
  }
  let x1 = flatCoordinates[offset2];
  let y1 = flatCoordinates[offset2 + 1];
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  let x2 = x1;
  let y2 = y1;
  for (offset2 += stride; offset2 < end; offset2 += stride) {
    x2 = flatCoordinates[offset2];
    y2 = flatCoordinates[offset2 + 1];
    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      x1 = x2;
      y1 = y2;
    }
  }
  if (x2 != x1 || y2 != y1) {
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  }
  return simplifiedOffset;
}
function snap(value, tolerance) {
  return tolerance * Math.round(value / tolerance);
}
function quantize(flatCoordinates, offset2, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
  if (offset2 == end) {
    return simplifiedOffset;
  }
  let x1 = snap(flatCoordinates[offset2], tolerance);
  let y1 = snap(flatCoordinates[offset2 + 1], tolerance);
  offset2 += stride;
  simplifiedFlatCoordinates[simplifiedOffset++] = x1;
  simplifiedFlatCoordinates[simplifiedOffset++] = y1;
  let x2, y2;
  do {
    x2 = snap(flatCoordinates[offset2], tolerance);
    y2 = snap(flatCoordinates[offset2 + 1], tolerance);
    offset2 += stride;
    if (offset2 == end) {
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
    }
  } while (x2 == x1 && y2 == y1);
  while (offset2 < end) {
    const x3 = snap(flatCoordinates[offset2], tolerance);
    const y3 = snap(flatCoordinates[offset2 + 1], tolerance);
    offset2 += stride;
    if (x3 == x2 && y3 == y2) {
      continue;
    }
    const dx1 = x2 - x1;
    const dy1 = y2 - y1;
    const dx2 = x3 - x1;
    const dy2 = y3 - y1;
    if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
      x2 = x3;
      y2 = y3;
      continue;
    }
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    x1 = x2;
    y1 = y2;
    x2 = x3;
    y2 = y3;
  }
  simplifiedFlatCoordinates[simplifiedOffset++] = x2;
  simplifiedFlatCoordinates[simplifiedOffset++] = y2;
  return simplifiedOffset;
}
function quantizeArray(flatCoordinates, offset2, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    simplifiedOffset = quantize(
      flatCoordinates,
      offset2,
      end,
      stride,
      tolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset
    );
    simplifiedEnds.push(simplifiedOffset);
    offset2 = end;
  }
  return simplifiedOffset;
}
function quantizeMultiArray(flatCoordinates, offset2, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    const simplifiedEnds = [];
    simplifiedOffset = quantizeArray(
      flatCoordinates,
      offset2,
      ends,
      stride,
      tolerance,
      simplifiedFlatCoordinates,
      simplifiedOffset,
      simplifiedEnds
    );
    simplifiedEndss.push(simplifiedEnds);
    offset2 = ends[ends.length - 1];
  }
  return simplifiedOffset;
}
var init_simplify = __esm({
  "node_modules/ol/geom/flat/simplify.js"() {
    init_math();
  }
});

// node_modules/ol/geom/flat/inflate.js
function inflateCoordinates(flatCoordinates, offset2, end, stride, coordinates2) {
  coordinates2 = coordinates2 !== void 0 ? coordinates2 : [];
  let i = 0;
  for (let j = offset2; j < end; j += stride) {
    coordinates2[i++] = flatCoordinates.slice(j, j + stride);
  }
  coordinates2.length = i;
  return coordinates2;
}
function inflateCoordinatesArray(flatCoordinates, offset2, ends, stride, coordinatess) {
  coordinatess = coordinatess !== void 0 ? coordinatess : [];
  let i = 0;
  for (let j = 0, jj = ends.length; j < jj; ++j) {
    const end = ends[j];
    coordinatess[i++] = inflateCoordinates(
      flatCoordinates,
      offset2,
      end,
      stride,
      coordinatess[i]
    );
    offset2 = end;
  }
  coordinatess.length = i;
  return coordinatess;
}
function inflateMultiCoordinatesArray(flatCoordinates, offset2, endss, stride, coordinatesss) {
  coordinatesss = coordinatesss !== void 0 ? coordinatesss : [];
  let i = 0;
  for (let j = 0, jj = endss.length; j < jj; ++j) {
    const ends = endss[j];
    coordinatesss[i++] = ends.length === 1 && ends[0] === offset2 ? [] : inflateCoordinatesArray(
      flatCoordinates,
      offset2,
      ends,
      stride,
      coordinatesss[i]
    );
    offset2 = ends[ends.length - 1];
  }
  coordinatesss.length = i;
  return coordinatesss;
}
var init_inflate = __esm({
  "node_modules/ol/geom/flat/inflate.js"() {
  }
});

// node_modules/ol/geom/flat/area.js
function linearRing(flatCoordinates, offset2, end, stride) {
  let twiceArea = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset2 < end; offset2 += stride) {
    const x2 = flatCoordinates[offset2];
    const y2 = flatCoordinates[offset2 + 1];
    twiceArea += y1 * x2 - x1 * y2;
    x1 = x2;
    y1 = y2;
  }
  return twiceArea / 2;
}
function linearRings(flatCoordinates, offset2, ends, stride) {
  let area = 0;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    area += linearRing(flatCoordinates, offset2, end, stride);
    offset2 = end;
  }
  return area;
}
function linearRingss(flatCoordinates, offset2, endss, stride) {
  let area = 0;
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    area += linearRings(flatCoordinates, offset2, ends, stride);
    offset2 = ends[ends.length - 1];
  }
  return area;
}
var init_area = __esm({
  "node_modules/ol/geom/flat/area.js"() {
  }
});

// node_modules/ol/geom/LinearRing.js
var LinearRing, LinearRing_default;
var init_LinearRing = __esm({
  "node_modules/ol/geom/LinearRing.js"() {
    init_SimpleGeometry();
    init_closest();
    init_extent();
    init_deflate();
    init_simplify();
    init_inflate();
    init_area();
    LinearRing = class _LinearRing extends SimpleGeometry_default {
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `layout` are also accepted.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(coordinates2, layout) {
        super();
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        if (layout !== void 0 && !Array.isArray(coordinates2[0])) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
        } else {
          this.setCoordinates(
            /** @type {Array<import("../coordinate.js").Coordinate>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!LinearRing} Clone.
       * @api
       */
      clone() {
        return new _LinearRing(this.flatCoordinates.slice(), this.layout);
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            maxSquaredDelta(
              this.flatCoordinates,
              0,
              this.flatCoordinates.length,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestPoint(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          this.maxDelta_,
          true,
          x,
          y,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * Return the area of the linear ring on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      getArea() {
        return linearRing(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * Return the coordinates of the linear ring.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       */
      getCoordinates() {
        return inflateCoordinates(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {LinearRing} Simplified LinearRing.
       * @protected
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = douglasPeucker(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          squaredTolerance,
          simplifiedFlatCoordinates,
          0
        );
        return new _LinearRing(simplifiedFlatCoordinates, "XY");
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */
      getType() {
        return "LinearRing";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      intersectsExtent(extent) {
        return false;
      }
      /**
       * Set the coordinates of the linear ring.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 1);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinates(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride
        );
        this.changed();
      }
    };
    LinearRing_default = LinearRing;
  }
});

// node_modules/ol/geom/Point.js
var Point_exports = {};
__export(Point_exports, {
  default: () => Point_default
});
var Point, Point_default;
var init_Point = __esm({
  "node_modules/ol/geom/Point.js"() {
    init_SimpleGeometry();
    init_extent();
    init_deflate();
    init_math();
    Point = class _Point extends SimpleGeometry_default {
      /**
       * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(coordinates2, layout) {
        super();
        this.setCoordinates(coordinates2, layout);
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!Point} Clone.
       * @api
       */
      clone() {
        const point = new _Point(this.flatCoordinates.slice(), this.layout);
        point.applyProperties(this);
        return point;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        const flatCoordinates = this.flatCoordinates;
        const squaredDistance3 = squaredDistance(
          x,
          y,
          flatCoordinates[0],
          flatCoordinates[1]
        );
        if (squaredDistance3 < minSquaredDistance) {
          const stride = this.stride;
          for (let i = 0; i < stride; ++i) {
            closestPoint[i] = flatCoordinates[i];
          }
          closestPoint.length = stride;
          return squaredDistance3;
        }
        return minSquaredDistance;
      }
      /**
       * Return the coordinate of the point.
       * @return {import("../coordinate.js").Coordinate} Coordinates.
       * @api
       */
      getCoordinates() {
        return this.flatCoordinates.slice();
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      computeExtent(extent) {
        return createOrUpdateFromCoordinate(this.flatCoordinates, extent);
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */
      getType() {
        return "Point";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      intersectsExtent(extent) {
        return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
      }
      /**
       * @param {!Array<*>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 0);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinate(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride
        );
        this.changed();
      }
    };
    Point_default = Point;
  }
});

// node_modules/ol/geom/flat/contains.js
function linearRingContainsExtent(flatCoordinates, offset2, end, stride, extent) {
  const outside = forEachCorner(
    extent,
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains (x, y).
     */
    function(coordinate) {
      return !linearRingContainsXY(
        flatCoordinates,
        offset2,
        end,
        stride,
        coordinate[0],
        coordinate[1]
      );
    }
  );
  return !outside;
}
function linearRingContainsXY(flatCoordinates, offset2, end, stride, x, y) {
  let wn = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset2 < end; offset2 += stride) {
    const x2 = flatCoordinates[offset2];
    const y2 = flatCoordinates[offset2 + 1];
    if (y1 <= y) {
      if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
        wn++;
      }
    } else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
      wn--;
    }
    x1 = x2;
    y1 = y2;
  }
  return wn !== 0;
}
function linearRingsContainsXY(flatCoordinates, offset2, ends, stride, x, y) {
  if (ends.length === 0) {
    return false;
  }
  if (!linearRingContainsXY(flatCoordinates, offset2, ends[0], stride, x, y)) {
    return false;
  }
  for (let i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
      return false;
    }
  }
  return true;
}
function linearRingssContainsXY(flatCoordinates, offset2, endss, stride, x, y) {
  if (endss.length === 0) {
    return false;
  }
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    if (linearRingsContainsXY(flatCoordinates, offset2, ends, stride, x, y)) {
      return true;
    }
    offset2 = ends[ends.length - 1];
  }
  return false;
}
var init_contains = __esm({
  "node_modules/ol/geom/flat/contains.js"() {
    init_extent();
  }
});

// node_modules/ol/geom/flat/interiorpoint.js
function getInteriorPointOfArray(flatCoordinates, offset2, ends, stride, flatCenters, flatCentersOffset, dest) {
  let i, ii, x, x1, x2, y1, y2;
  const y = flatCenters[flatCentersOffset + 1];
  const intersections = [];
  for (let r = 0, rr = ends.length; r < rr; ++r) {
    const end = ends[r];
    x1 = flatCoordinates[end - stride];
    y1 = flatCoordinates[end - stride + 1];
    for (i = offset2; i < end; i += stride) {
      x2 = flatCoordinates[i];
      y2 = flatCoordinates[i + 1];
      if (y <= y1 && y2 <= y || y1 <= y && y <= y2) {
        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;
        intersections.push(x);
      }
      x1 = x2;
      y1 = y2;
    }
  }
  let pointX = NaN;
  let maxSegmentLength = -Infinity;
  intersections.sort(ascending);
  x1 = intersections[0];
  for (i = 1, ii = intersections.length; i < ii; ++i) {
    x2 = intersections[i];
    const segmentLength = Math.abs(x2 - x1);
    if (segmentLength > maxSegmentLength) {
      x = (x1 + x2) / 2;
      if (linearRingsContainsXY(flatCoordinates, offset2, ends, stride, x, y)) {
        pointX = x;
        maxSegmentLength = segmentLength;
      }
    }
    x1 = x2;
  }
  if (isNaN(pointX)) {
    pointX = flatCenters[flatCentersOffset];
  }
  if (dest) {
    dest.push(pointX, y, maxSegmentLength);
    return dest;
  }
  return [pointX, y, maxSegmentLength];
}
function getInteriorPointsOfMultiArray(flatCoordinates, offset2, endss, stride, flatCenters) {
  let interiorPoints = [];
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    interiorPoints = getInteriorPointOfArray(
      flatCoordinates,
      offset2,
      ends,
      stride,
      flatCenters,
      2 * i,
      interiorPoints
    );
    offset2 = ends[ends.length - 1];
  }
  return interiorPoints;
}
var init_interiorpoint = __esm({
  "node_modules/ol/geom/flat/interiorpoint.js"() {
    init_array();
    init_contains();
  }
});

// node_modules/ol/geom/flat/segments.js
function forEach(flatCoordinates, offset2, end, stride, callback) {
  let ret;
  offset2 += stride;
  for (; offset2 < end; offset2 += stride) {
    ret = callback(
      flatCoordinates.slice(offset2 - stride, offset2),
      flatCoordinates.slice(offset2, offset2 + stride)
    );
    if (ret) {
      return ret;
    }
  }
  return false;
}
var init_segments = __esm({
  "node_modules/ol/geom/flat/segments.js"() {
  }
});

// node_modules/ol/geom/flat/intersectsextent.js
function intersectsLineString(flatCoordinates, offset2, end, stride, extent) {
  const coordinatesExtent = extendFlatCoordinates(
    createEmpty(),
    flatCoordinates,
    offset2,
    end,
    stride
  );
  if (!intersects(extent, coordinatesExtent)) {
    return false;
  }
  if (containsExtent(extent, coordinatesExtent)) {
    return true;
  }
  if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
    return true;
  }
  if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
    return true;
  }
  return forEach(
    flatCoordinates,
    offset2,
    end,
    stride,
    /**
     * @param {import("../../coordinate.js").Coordinate} point1 Start point.
     * @param {import("../../coordinate.js").Coordinate} point2 End point.
     * @return {boolean} `true` if the segment and the extent intersect,
     *     `false` otherwise.
     */
    function(point1, point2) {
      return intersectsSegment(extent, point1, point2);
    }
  );
}
function intersectsLineStringArray(flatCoordinates, offset2, ends, stride, extent) {
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    if (intersectsLineString(flatCoordinates, offset2, ends[i], stride, extent)) {
      return true;
    }
    offset2 = ends[i];
  }
  return false;
}
function intersectsLinearRing(flatCoordinates, offset2, end, stride, extent) {
  if (intersectsLineString(flatCoordinates, offset2, end, stride, extent)) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset2,
    end,
    stride,
    extent[0],
    extent[1]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset2,
    end,
    stride,
    extent[0],
    extent[3]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset2,
    end,
    stride,
    extent[2],
    extent[1]
  )) {
    return true;
  }
  if (linearRingContainsXY(
    flatCoordinates,
    offset2,
    end,
    stride,
    extent[2],
    extent[3]
  )) {
    return true;
  }
  return false;
}
function intersectsLinearRingArray(flatCoordinates, offset2, ends, stride, extent) {
  if (!intersectsLinearRing(flatCoordinates, offset2, ends[0], stride, extent)) {
    return false;
  }
  if (ends.length === 1) {
    return true;
  }
  for (let i = 1, ii = ends.length; i < ii; ++i) {
    if (linearRingContainsExtent(
      flatCoordinates,
      ends[i - 1],
      ends[i],
      stride,
      extent
    )) {
      if (!intersectsLineString(
        flatCoordinates,
        ends[i - 1],
        ends[i],
        stride,
        extent
      )) {
        return false;
      }
    }
  }
  return true;
}
function intersectsLinearRingMultiArray(flatCoordinates, offset2, endss, stride, extent) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    if (intersectsLinearRingArray(flatCoordinates, offset2, ends, stride, extent)) {
      return true;
    }
    offset2 = ends[ends.length - 1];
  }
  return false;
}
var init_intersectsextent = __esm({
  "node_modules/ol/geom/flat/intersectsextent.js"() {
    init_extent();
    init_segments();
    init_contains();
  }
});

// node_modules/ol/geom/flat/reverse.js
function coordinates(flatCoordinates, offset2, end, stride) {
  while (offset2 < end - stride) {
    for (let i = 0; i < stride; ++i) {
      const tmp = flatCoordinates[offset2 + i];
      flatCoordinates[offset2 + i] = flatCoordinates[end - stride + i];
      flatCoordinates[end - stride + i] = tmp;
    }
    offset2 += stride;
    end -= stride;
  }
}
var init_reverse = __esm({
  "node_modules/ol/geom/flat/reverse.js"() {
  }
});

// node_modules/ol/geom/flat/orient.js
function linearRingIsClockwise(flatCoordinates, offset2, end, stride) {
  let edge = 0;
  let x1 = flatCoordinates[end - stride];
  let y1 = flatCoordinates[end - stride + 1];
  for (; offset2 < end; offset2 += stride) {
    const x2 = flatCoordinates[offset2];
    const y2 = flatCoordinates[offset2 + 1];
    edge += (x2 - x1) * (y2 + y1);
    x1 = x2;
    y1 = y2;
  }
  return edge === 0 ? void 0 : edge > 0;
}
function linearRingsAreOriented(flatCoordinates, offset2, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset2,
      end,
      stride
    );
    if (i === 0) {
      if (right && isClockwise || !right && !isClockwise) {
        return false;
      }
    } else {
      if (right && !isClockwise || !right && isClockwise) {
        return false;
      }
    }
    offset2 = end;
  }
  return true;
}
function linearRingssAreOriented(flatCoordinates, offset2, endss, stride, right) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    if (!linearRingsAreOriented(flatCoordinates, offset2, ends, stride, right)) {
      return false;
    }
    if (ends.length) {
      offset2 = ends[ends.length - 1];
    }
  }
  return true;
}
function orientLinearRings(flatCoordinates, offset2, ends, stride, right) {
  right = right !== void 0 ? right : false;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const isClockwise = linearRingIsClockwise(
      flatCoordinates,
      offset2,
      end,
      stride
    );
    const reverse = i === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
    if (reverse) {
      coordinates(flatCoordinates, offset2, end, stride);
    }
    offset2 = end;
  }
  return offset2;
}
function orientLinearRingsArray(flatCoordinates, offset2, endss, stride, right) {
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    offset2 = orientLinearRings(
      flatCoordinates,
      offset2,
      endss[i],
      stride,
      right
    );
  }
  return offset2;
}
function inflateEnds(flatCoordinates, ends) {
  const endss = [];
  let offset2 = 0;
  let prevEndIndex = 0;
  let startOrientation;
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    const orientation = linearRingIsClockwise(flatCoordinates, offset2, end, 2);
    if (startOrientation === void 0) {
      startOrientation = orientation;
    }
    if (orientation === startOrientation) {
      endss.push(ends.slice(prevEndIndex, i + 1));
    } else {
      if (endss.length === 0) {
        continue;
      }
      endss[endss.length - 1].push(ends[prevEndIndex]);
    }
    prevEndIndex = i + 1;
    offset2 = end;
  }
  return endss;
}
var init_orient = __esm({
  "node_modules/ol/geom/flat/orient.js"() {
    init_reverse();
  }
});

// node_modules/ol/geom/Polygon.js
function circular(center, radius, n, sphereRadius) {
  n = n ? n : 32;
  const flatCoordinates = [];
  for (let i = 0; i < n; ++i) {
    extend(
      flatCoordinates,
      offset(center, radius, 2 * Math.PI * i / n, sphereRadius)
    );
  }
  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
  return new Polygon(flatCoordinates, "XY", [flatCoordinates.length]);
}
function fromExtent(extent) {
  if (isEmpty2(extent)) {
    throw new Error("Cannot create polygon from empty extent");
  }
  const minX = extent[0];
  const minY = extent[1];
  const maxX = extent[2];
  const maxY = extent[3];
  const flatCoordinates = [
    minX,
    minY,
    minX,
    maxY,
    maxX,
    maxY,
    maxX,
    minY,
    minX,
    minY
  ];
  return new Polygon(flatCoordinates, "XY", [flatCoordinates.length]);
}
function fromCircle(circle, sides, angle) {
  sides = sides ? sides : 32;
  const stride = circle.getStride();
  const layout = circle.getLayout();
  const center = circle.getCenter();
  const arrayLength = stride * (sides + 1);
  const flatCoordinates = new Array(arrayLength);
  for (let i = 0; i < arrayLength; i += stride) {
    flatCoordinates[i] = 0;
    flatCoordinates[i + 1] = 0;
    for (let j = 2; j < stride; j++) {
      flatCoordinates[i + j] = center[j];
    }
  }
  const ends = [flatCoordinates.length];
  const polygon = new Polygon(flatCoordinates, layout, ends);
  makeRegular(polygon, center, circle.getRadius(), angle);
  return polygon;
}
function makeRegular(polygon, center, radius, angle) {
  const flatCoordinates = polygon.getFlatCoordinates();
  const stride = polygon.getStride();
  const sides = flatCoordinates.length / stride - 1;
  const startAngle = angle ? angle : 0;
  for (let i = 0; i <= sides; ++i) {
    const offset2 = i * stride;
    const angle2 = startAngle + modulo(i, sides) * 2 * Math.PI / sides;
    flatCoordinates[offset2] = center[0] + radius * Math.cos(angle2);
    flatCoordinates[offset2 + 1] = center[1] + radius * Math.sin(angle2);
  }
  polygon.changed();
}
var Polygon, Polygon_default;
var init_Polygon = __esm({
  "node_modules/ol/geom/Polygon.js"() {
    init_LinearRing();
    init_Point();
    init_SimpleGeometry();
    init_closest();
    init_extent();
    init_deflate();
    init_array();
    init_interiorpoint();
    init_inflate();
    init_intersectsextent();
    init_orient();
    init_area();
    init_contains();
    init_math();
    init_simplify();
    init_sphere();
    Polygon = class _Polygon extends SimpleGeometry_default {
      /**
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
       *     Array of linear rings that define the polygon. The first linear ring of the
       *     array defines the outer-boundary or surface of the polygon. Each subsequent
       *     linear ring defines a hole in the surface of the polygon. A linear ring is
       *     an array of vertices' coordinates where the first coordinate and the last are
       *     equivalent. (For internal use, flat coordinates in combination with
       *     `layout` and `ends` are also accepted.)
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
       */
      constructor(coordinates2, layout, ends) {
        super();
        this.ends_ = [];
        this.flatInteriorPointRevision_ = -1;
        this.flatInteriorPoint_ = null;
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        this.orientedRevision_ = -1;
        this.orientedFlatCoordinates_ = null;
        if (layout !== void 0 && ends) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
          this.ends_ = ends;
        } else {
          this.setCoordinates(
            /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Append the passed linear ring to this polygon.
       * @param {LinearRing} linearRing Linear ring.
       * @api
       */
      appendLinearRing(linearRing2) {
        if (!this.flatCoordinates) {
          this.flatCoordinates = linearRing2.getFlatCoordinates().slice();
        } else {
          extend(this.flatCoordinates, linearRing2.getFlatCoordinates());
        }
        this.ends_.push(this.flatCoordinates.length);
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!Polygon} Clone.
       * @api
       */
      clone() {
        const polygon = new _Polygon(
          this.flatCoordinates.slice(),
          this.layout,
          this.ends_.slice()
        );
        polygon.applyProperties(this);
        return polygon;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            arrayMaxSquaredDelta(
              this.flatCoordinates,
              0,
              this.ends_,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestArrayPoint(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          this.maxDelta_,
          true,
          x,
          y,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */
      containsXY(x, y) {
        return linearRingsContainsXY(
          this.getOrientedFlatCoordinates(),
          0,
          this.ends_,
          this.stride,
          x,
          y
        );
      }
      /**
       * Return the area of the polygon on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      getArea() {
        return linearRings(
          this.getOrientedFlatCoordinates(),
          0,
          this.ends_,
          this.stride
        );
      }
      /**
       * Get the coordinate array for this geometry.  This array has the structure
       * of a GeoJSON coordinate array for polygons.
       *
       * @param {boolean} [right] Orient coordinates according to the right-hand
       *     rule (counter-clockwise for exterior and clockwise for interior rings).
       *     If `false`, coordinates will be oriented according to the left-hand rule
       *     (clockwise for exterior and counter-clockwise for interior rings).
       *     By default, coordinate orientation will depend on how the geometry was
       *     constructed.
       * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
       * @api
       */
      getCoordinates(right) {
        let flatCoordinates;
        if (right !== void 0) {
          flatCoordinates = this.getOrientedFlatCoordinates().slice();
          orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, right);
        } else {
          flatCoordinates = this.flatCoordinates;
        }
        return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
      }
      /**
       * @return {Array<number>} Ends.
       */
      getEnds() {
        return this.ends_;
      }
      /**
       * @return {Array<number>} Interior point.
       */
      getFlatInteriorPoint() {
        if (this.flatInteriorPointRevision_ != this.getRevision()) {
          const flatCenter = getCenter(this.getExtent());
          this.flatInteriorPoint_ = getInteriorPointOfArray(
            this.getOrientedFlatCoordinates(),
            0,
            this.ends_,
            this.stride,
            flatCenter,
            0
          );
          this.flatInteriorPointRevision_ = this.getRevision();
        }
        return (
          /** @type {import("../coordinate.js").Coordinate} */
          this.flatInteriorPoint_
        );
      }
      /**
       * Return an interior point of the polygon.
       * @return {Point} Interior point as XYM coordinate, where M is the
       * length of the horizontal intersection that the point belongs to.
       * @api
       */
      getInteriorPoint() {
        return new Point_default(this.getFlatInteriorPoint(), "XYM");
      }
      /**
       * Return the number of rings of the polygon,  this includes the exterior
       * ring and any interior rings.
       *
       * @return {number} Number of rings.
       * @api
       */
      getLinearRingCount() {
        return this.ends_.length;
      }
      /**
       * Return the Nth linear ring of the polygon geometry. Return `null` if the
       * given index is out of range.
       * The exterior linear ring is available at index `0` and the interior rings
       * at index `1` and beyond.
       *
       * @param {number} index Index.
       * @return {LinearRing|null} Linear ring.
       * @api
       */
      getLinearRing(index) {
        if (index < 0 || this.ends_.length <= index) {
          return null;
        }
        return new LinearRing_default(
          this.flatCoordinates.slice(
            index === 0 ? 0 : this.ends_[index - 1],
            this.ends_[index]
          ),
          this.layout
        );
      }
      /**
       * Return the linear rings of the polygon.
       * @return {Array<LinearRing>} Linear rings.
       * @api
       */
      getLinearRings() {
        const layout = this.layout;
        const flatCoordinates = this.flatCoordinates;
        const ends = this.ends_;
        const linearRings2 = [];
        let offset2 = 0;
        for (let i = 0, ii = ends.length; i < ii; ++i) {
          const end = ends[i];
          const linearRing2 = new LinearRing_default(
            flatCoordinates.slice(offset2, end),
            layout
          );
          linearRings2.push(linearRing2);
          offset2 = end;
        }
        return linearRings2;
      }
      /**
       * @return {Array<number>} Oriented flat coordinates.
       */
      getOrientedFlatCoordinates() {
        if (this.orientedRevision_ != this.getRevision()) {
          const flatCoordinates = this.flatCoordinates;
          if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
            this.orientedFlatCoordinates_ = flatCoordinates;
          } else {
            this.orientedFlatCoordinates_ = flatCoordinates.slice();
            this.orientedFlatCoordinates_.length = orientLinearRings(
              this.orientedFlatCoordinates_,
              0,
              this.ends_,
              this.stride
            );
          }
          this.orientedRevision_ = this.getRevision();
        }
        return (
          /** @type {Array<number>} */
          this.orientedFlatCoordinates_
        );
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {Polygon} Simplified Polygon.
       * @protected
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        const simplifiedEnds = [];
        simplifiedFlatCoordinates.length = quantizeArray(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          Math.sqrt(squaredTolerance),
          simplifiedFlatCoordinates,
          0,
          simplifiedEnds
        );
        return new _Polygon(simplifiedFlatCoordinates, "XY", simplifiedEnds);
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */
      getType() {
        return "Polygon";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      intersectsExtent(extent) {
        return intersectsLinearRingArray(
          this.getOrientedFlatCoordinates(),
          0,
          this.ends_,
          this.stride,
          extent
        );
      }
      /**
       * Set the coordinates of the polygon.
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 2);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        const ends = deflateCoordinatesArray(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride,
          this.ends_
        );
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
      }
    };
    Polygon_default = Polygon;
  }
});

// node_modules/ol/View.js
function animationCallback(callback, returnValue) {
  setTimeout(function() {
    callback(returnValue);
  }, 0);
}
function createCenterConstraint(options) {
  if (options.extent !== void 0) {
    const smooth = options.smoothExtentConstraint !== void 0 ? options.smoothExtentConstraint : true;
    return createExtent(options.extent, options.constrainOnlyCenter, smooth);
  }
  const projection = createProjection(options.projection, "EPSG:3857");
  if (options.multiWorld !== true && projection.isGlobal()) {
    const extent = projection.getExtent().slice();
    extent[0] = -Infinity;
    extent[2] = Infinity;
    return createExtent(extent, false, false);
  }
  return none;
}
function createResolutionConstraint(options) {
  let resolutionConstraint;
  let maxResolution;
  let minResolution;
  const defaultMaxZoom = 28;
  const defaultZoomFactor = 2;
  let minZoom = options.minZoom !== void 0 ? options.minZoom : DEFAULT_MIN_ZOOM;
  let maxZoom = options.maxZoom !== void 0 ? options.maxZoom : defaultMaxZoom;
  const zoomFactor = options.zoomFactor !== void 0 ? options.zoomFactor : defaultZoomFactor;
  const multiWorld = options.multiWorld !== void 0 ? options.multiWorld : false;
  const smooth = options.smoothResolutionConstraint !== void 0 ? options.smoothResolutionConstraint : true;
  const showFullExtent = options.showFullExtent !== void 0 ? options.showFullExtent : false;
  const projection = createProjection(options.projection, "EPSG:3857");
  const projExtent = projection.getExtent();
  let constrainOnlyCenter = options.constrainOnlyCenter;
  let extent = options.extent;
  if (!multiWorld && !extent && projection.isGlobal()) {
    constrainOnlyCenter = false;
    extent = projExtent;
  }
  if (options.resolutions !== void 0) {
    const resolutions = options.resolutions;
    maxResolution = resolutions[minZoom];
    minResolution = resolutions[maxZoom] !== void 0 ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToResolutions(
        resolutions,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    } else {
      resolutionConstraint = createMinMaxResolution(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    }
  } else {
    const size = !projExtent ? (
      // use an extent that can fit the whole world if need be
      360 * METERS_PER_UNIT.degrees / projection.getMetersPerUnit()
    ) : Math.max(getWidth(projExtent), getHeight(projExtent));
    const defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
    const defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
    maxResolution = options.maxResolution;
    if (maxResolution !== void 0) {
      minZoom = 0;
    } else {
      maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
    }
    minResolution = options.minResolution;
    if (minResolution === void 0) {
      if (options.maxZoom !== void 0) {
        if (options.maxResolution !== void 0) {
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
        } else {
          minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
        }
      } else {
        minResolution = defaultMinResolution;
      }
    }
    maxZoom = minZoom + Math.floor(
      Math.log(maxResolution / minResolution) / Math.log(zoomFactor)
    );
    minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
    if (options.constrainResolution) {
      resolutionConstraint = createSnapToPower(
        zoomFactor,
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    } else {
      resolutionConstraint = createMinMaxResolution(
        maxResolution,
        minResolution,
        smooth,
        !constrainOnlyCenter && extent,
        showFullExtent
      );
    }
  }
  return {
    constraint: resolutionConstraint,
    maxResolution,
    minResolution,
    minZoom,
    zoomFactor
  };
}
function createRotationConstraint(options) {
  const enableRotation = options.enableRotation !== void 0 ? options.enableRotation : true;
  if (enableRotation) {
    const constrainRotation = options.constrainRotation;
    if (constrainRotation === void 0 || constrainRotation === true) {
      return createSnapToZero();
    }
    if (constrainRotation === false) {
      return none2;
    }
    if (typeof constrainRotation === "number") {
      return createSnapToN(constrainRotation);
    }
    return none2;
  }
  return disable;
}
function isNoopAnimation(animation) {
  if (animation.sourceCenter && animation.targetCenter) {
    if (!equals3(animation.sourceCenter, animation.targetCenter)) {
      return false;
    }
  }
  if (animation.sourceResolution !== animation.targetResolution) {
    return false;
  }
  if (animation.sourceRotation !== animation.targetRotation) {
    return false;
  }
  return true;
}
function calculateCenterOn(coordinate, size, position, resolution, rotation) {
  const cosAngle = Math.cos(-rotation);
  let sinAngle = Math.sin(-rotation);
  let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
  let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
  rotX += (size[0] / 2 - position[0]) * resolution;
  rotY += (position[1] - size[1] / 2) * resolution;
  sinAngle = -sinAngle;
  const centerX = rotX * cosAngle - rotY * sinAngle;
  const centerY = rotY * cosAngle + rotX * sinAngle;
  return [centerX, centerY];
}
var DEFAULT_MIN_ZOOM, View, View_default;
var init_View = __esm({
  "node_modules/ol/View.js"() {
    init_Object();
    init_ViewHint();
    init_ViewProperty();
    init_common();
    init_proj();
    init_functions();
    init_coordinate();
    init_asserts();
    init_centerconstraint();
    init_math();
    init_resolutionconstraint();
    init_rotationconstraint();
    init_easing();
    init_extent();
    init_array();
    init_Polygon();
    DEFAULT_MIN_ZOOM = 0;
    View = class extends Object_default {
      /**
       * @param {ViewOptions} [options] View options.
       */
      constructor(options) {
        super();
        this.on;
        this.once;
        this.un;
        options = Object.assign({}, options);
        this.hints_ = [0, 0];
        this.animations_ = [];
        this.updateAnimationKey_;
        this.projection_ = createProjection(options.projection, "EPSG:3857");
        this.viewportSize_ = [100, 100];
        this.targetCenter_ = null;
        this.targetResolution_;
        this.targetRotation_;
        this.nextCenter_ = null;
        this.nextResolution_;
        this.nextRotation_;
        this.cancelAnchor_ = void 0;
        if (options.projection) {
          disableCoordinateWarning();
        }
        if (options.center) {
          options.center = fromUserCoordinate(options.center, this.projection_);
        }
        if (options.extent) {
          options.extent = fromUserExtent(options.extent, this.projection_);
        }
        this.applyOptions_(options);
      }
      /**
       * Set up the view with the given options.
       * @param {ViewOptions} options View options.
       */
      applyOptions_(options) {
        const properties = Object.assign({}, options);
        for (const key in ViewProperty_default) {
          delete properties[key];
        }
        this.setProperties(properties, true);
        const resolutionConstraintInfo = createResolutionConstraint(options);
        this.maxResolution_ = resolutionConstraintInfo.maxResolution;
        this.minResolution_ = resolutionConstraintInfo.minResolution;
        this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
        this.resolutions_ = options.resolutions;
        this.padding_ = options.padding;
        this.minZoom_ = resolutionConstraintInfo.minZoom;
        const centerConstraint = createCenterConstraint(options);
        const resolutionConstraint = resolutionConstraintInfo.constraint;
        const rotationConstraint = createRotationConstraint(options);
        this.constraints_ = {
          center: centerConstraint,
          resolution: resolutionConstraint,
          rotation: rotationConstraint
        };
        this.setRotation(options.rotation !== void 0 ? options.rotation : 0);
        this.setCenterInternal(
          options.center !== void 0 ? options.center : null
        );
        if (options.resolution !== void 0) {
          this.setResolution(options.resolution);
        } else if (options.zoom !== void 0) {
          this.setZoom(options.zoom);
        }
      }
      /**
       * Padding (in css pixels).
       * If the map viewport is partially covered with other content (overlays) along
       * its edges, this setting allows to shift the center of the viewport away from that
       * content. The order of the values in the array is top, right, bottom, left.
       * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
       * @type {Array<number>|undefined}
       * @api
       */
      get padding() {
        return this.padding_;
      }
      set padding(padding) {
        let oldPadding = this.padding_;
        this.padding_ = padding;
        const center = this.getCenterInternal();
        if (center) {
          const newPadding = padding || [0, 0, 0, 0];
          oldPadding = oldPadding || [0, 0, 0, 0];
          const resolution = this.getResolution();
          const offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
          const offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
          this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
        }
      }
      /**
       * Get an updated version of the view options used to construct the view.  The
       * current resolution (or zoom), center, and rotation are applied to any stored
       * options.  The provided options can be used to apply new min/max zoom or
       * resolution limits.
       * @param {ViewOptions} newOptions New options to be applied.
       * @return {ViewOptions} New options updated with the current view state.
       */
      getUpdatedOptions_(newOptions) {
        const options = this.getProperties();
        if (options.resolution !== void 0) {
          options.resolution = this.getResolution();
        } else {
          options.zoom = this.getZoom();
        }
        options.center = this.getCenterInternal();
        options.rotation = this.getRotation();
        return Object.assign({}, options, newOptions);
      }
      /**
       * Animate the view.  The view's center, zoom (or resolution), and rotation
       * can be animated for smooth transitions between view states.  For example,
       * to animate the view to a new zoom level:
       *
       *     view.animate({zoom: view.getZoom() + 1});
       *
       * By default, the animation lasts one second and uses in-and-out easing.  You
       * can customize this behavior by including `duration` (in milliseconds) and
       * `easing` options (see {@link module:ol/easing}).
       *
       * To chain together multiple animations, call the method with multiple
       * animation objects.  For example, to first zoom and then pan:
       *
       *     view.animate({zoom: 10}, {center: [0, 0]});
       *
       * If you provide a function as the last argument to the animate method, it
       * will get called at the end of an animation series.  The callback will be
       * called with `true` if the animation series completed on its own or `false`
       * if it was cancelled.
       *
       * Animations are cancelled by user interactions (e.g. dragging the map) or by
       * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
       * (or another method that calls one of these).
       *
       * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
       *     options.  Multiple animations can be run in series by passing multiple
       *     options objects.  To run multiple animations in parallel, call the method
       *     multiple times.  An optional callback can be provided as a final
       *     argument.  The callback will be called with a boolean indicating whether
       *     the animation completed without being cancelled.
       * @api
       */
      animate(var_args) {
        if (this.isDef() && !this.getAnimating()) {
          this.resolveConstraints(0);
        }
        const args = new Array(arguments.length);
        for (let i = 0; i < args.length; ++i) {
          let options = arguments[i];
          if (options.center) {
            options = Object.assign({}, options);
            options.center = fromUserCoordinate(
              options.center,
              this.getProjection()
            );
          }
          if (options.anchor) {
            options = Object.assign({}, options);
            options.anchor = fromUserCoordinate(
              options.anchor,
              this.getProjection()
            );
          }
          args[i] = options;
        }
        this.animateInternal.apply(this, args);
      }
      /**
       * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
       */
      animateInternal(var_args) {
        let animationCount = arguments.length;
        let callback;
        if (animationCount > 1 && typeof arguments[animationCount - 1] === "function") {
          callback = arguments[animationCount - 1];
          --animationCount;
        }
        let i = 0;
        for (; i < animationCount && !this.isDef(); ++i) {
          const state = arguments[i];
          if (state.center) {
            this.setCenterInternal(state.center);
          }
          if (state.zoom !== void 0) {
            this.setZoom(state.zoom);
          } else if (state.resolution) {
            this.setResolution(state.resolution);
          }
          if (state.rotation !== void 0) {
            this.setRotation(state.rotation);
          }
        }
        if (i === animationCount) {
          if (callback) {
            animationCallback(callback, true);
          }
          return;
        }
        let start = Date.now();
        let center = this.targetCenter_.slice();
        let resolution = this.targetResolution_;
        let rotation = this.targetRotation_;
        const series = [];
        for (; i < animationCount; ++i) {
          const options = (
            /** @type {AnimationOptions} */
            arguments[i]
          );
          const animation = {
            start,
            complete: false,
            anchor: options.anchor,
            duration: options.duration !== void 0 ? options.duration : 1e3,
            easing: options.easing || inAndOut,
            callback
          };
          if (options.center) {
            animation.sourceCenter = center;
            animation.targetCenter = options.center.slice();
            center = animation.targetCenter;
          }
          if (options.zoom !== void 0) {
            animation.sourceResolution = resolution;
            animation.targetResolution = this.getResolutionForZoom(options.zoom);
            resolution = animation.targetResolution;
          } else if (options.resolution) {
            animation.sourceResolution = resolution;
            animation.targetResolution = options.resolution;
            resolution = animation.targetResolution;
          }
          if (options.rotation !== void 0) {
            animation.sourceRotation = rotation;
            const delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
            animation.targetRotation = rotation + delta;
            rotation = animation.targetRotation;
          }
          if (isNoopAnimation(animation)) {
            animation.complete = true;
          } else {
            start += animation.duration;
          }
          series.push(animation);
        }
        this.animations_.push(series);
        this.setHint(ViewHint_default.ANIMATING, 1);
        this.updateAnimations_();
      }
      /**
       * Determine if the view is being animated.
       * @return {boolean} The view is being animated.
       * @api
       */
      getAnimating() {
        return this.hints_[ViewHint_default.ANIMATING] > 0;
      }
      /**
       * Determine if the user is interacting with the view, such as panning or zooming.
       * @return {boolean} The view is being interacted with.
       * @api
       */
      getInteracting() {
        return this.hints_[ViewHint_default.INTERACTING] > 0;
      }
      /**
       * Cancel any ongoing animations.
       * @api
       */
      cancelAnimations() {
        this.setHint(ViewHint_default.ANIMATING, -this.hints_[ViewHint_default.ANIMATING]);
        let anchor;
        for (let i = 0, ii = this.animations_.length; i < ii; ++i) {
          const series = this.animations_[i];
          if (series[0].callback) {
            animationCallback(series[0].callback, false);
          }
          if (!anchor) {
            for (let j = 0, jj = series.length; j < jj; ++j) {
              const animation = series[j];
              if (!animation.complete) {
                anchor = animation.anchor;
                break;
              }
            }
          }
        }
        this.animations_.length = 0;
        this.cancelAnchor_ = anchor;
        this.nextCenter_ = null;
        this.nextResolution_ = NaN;
        this.nextRotation_ = NaN;
      }
      /**
       * Update all animations.
       */
      updateAnimations_() {
        if (this.updateAnimationKey_ !== void 0) {
          cancelAnimationFrame(this.updateAnimationKey_);
          this.updateAnimationKey_ = void 0;
        }
        if (!this.getAnimating()) {
          return;
        }
        const now = Date.now();
        let more = false;
        for (let i = this.animations_.length - 1; i >= 0; --i) {
          const series = this.animations_[i];
          let seriesComplete = true;
          for (let j = 0, jj = series.length; j < jj; ++j) {
            const animation = series[j];
            if (animation.complete) {
              continue;
            }
            const elapsed = now - animation.start;
            let fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
            if (fraction >= 1) {
              animation.complete = true;
              fraction = 1;
            } else {
              seriesComplete = false;
            }
            const progress = animation.easing(fraction);
            if (animation.sourceCenter) {
              const x0 = animation.sourceCenter[0];
              const y0 = animation.sourceCenter[1];
              const x1 = animation.targetCenter[0];
              const y1 = animation.targetCenter[1];
              this.nextCenter_ = animation.targetCenter;
              const x = x0 + progress * (x1 - x0);
              const y = y0 + progress * (y1 - y0);
              this.targetCenter_ = [x, y];
            }
            if (animation.sourceResolution && animation.targetResolution) {
              const resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
              if (animation.anchor) {
                const size = this.getViewportSize_(this.getRotation());
                const constrainedResolution = this.constraints_.resolution(
                  resolution,
                  0,
                  size,
                  true
                );
                this.targetCenter_ = this.calculateCenterZoom(
                  constrainedResolution,
                  animation.anchor
                );
              }
              this.nextResolution_ = animation.targetResolution;
              this.targetResolution_ = resolution;
              this.applyTargetState_(true);
            }
            if (animation.sourceRotation !== void 0 && animation.targetRotation !== void 0) {
              const rotation = progress === 1 ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
              if (animation.anchor) {
                const constrainedRotation = this.constraints_.rotation(
                  rotation,
                  true
                );
                this.targetCenter_ = this.calculateCenterRotate(
                  constrainedRotation,
                  animation.anchor
                );
              }
              this.nextRotation_ = animation.targetRotation;
              this.targetRotation_ = rotation;
            }
            this.applyTargetState_(true);
            more = true;
            if (!animation.complete) {
              break;
            }
          }
          if (seriesComplete) {
            this.animations_[i] = null;
            this.setHint(ViewHint_default.ANIMATING, -1);
            this.nextCenter_ = null;
            this.nextResolution_ = NaN;
            this.nextRotation_ = NaN;
            const callback = series[0].callback;
            if (callback) {
              animationCallback(callback, true);
            }
          }
        }
        this.animations_ = this.animations_.filter(Boolean);
        if (more && this.updateAnimationKey_ === void 0) {
          this.updateAnimationKey_ = requestAnimationFrame(
            this.updateAnimations_.bind(this)
          );
        }
      }
      /**
       * @param {number} rotation Target rotation.
       * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
       * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
       */
      calculateCenterRotate(rotation, anchor) {
        let center;
        const currentCenter = this.getCenterInternal();
        if (currentCenter !== void 0) {
          center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
          rotate2(center, rotation - this.getRotation());
          add3(center, anchor);
        }
        return center;
      }
      /**
       * @param {number} resolution Target resolution.
       * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
       * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
       */
      calculateCenterZoom(resolution, anchor) {
        let center;
        const currentCenter = this.getCenterInternal();
        const currentResolution = this.getResolution();
        if (currentCenter !== void 0 && currentResolution !== void 0) {
          const x = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
          const y = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
          center = [x, y];
        }
        return center;
      }
      /**
       * Returns the current viewport size.
       * @private
       * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
       * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
       */
      getViewportSize_(rotation) {
        const size = this.viewportSize_;
        if (rotation) {
          const w = size[0];
          const h = size[1];
          return [
            Math.abs(w * Math.cos(rotation)) + Math.abs(h * Math.sin(rotation)),
            Math.abs(w * Math.sin(rotation)) + Math.abs(h * Math.cos(rotation))
          ];
        }
        return size;
      }
      /**
       * Stores the viewport size on the view. The viewport size is not read every time from the DOM
       * to avoid performance hit and layout reflow.
       * This should be done on map size change.
       * Note: the constraints are not resolved during an animation to avoid stopping it
       * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
       */
      setViewportSize(size) {
        this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];
        if (!this.getAnimating()) {
          this.resolveConstraints(0);
        }
      }
      /**
       * Get the view center.
       * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
       * @observable
       * @api
       */
      getCenter() {
        const center = this.getCenterInternal();
        if (!center) {
          return center;
        }
        return toUserCoordinate(center, this.getProjection());
      }
      /**
       * Get the view center without transforming to user projection.
       * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
       */
      getCenterInternal() {
        return (
          /** @type {import("./coordinate.js").Coordinate|undefined} */
          this.get(ViewProperty_default.CENTER)
        );
      }
      /**
       * @return {Constraints} Constraints.
       */
      getConstraints() {
        return this.constraints_;
      }
      /**
       * @return {boolean} Resolution constraint is set
       */
      getConstrainResolution() {
        return this.get("constrainResolution");
      }
      /**
       * @param {Array<number>} [hints] Destination array.
       * @return {Array<number>} Hint.
       */
      getHints(hints) {
        if (hints !== void 0) {
          hints[0] = this.hints_[0];
          hints[1] = this.hints_[1];
          return hints;
        }
        return this.hints_.slice();
      }
      /**
       * Calculate the extent for the current view state and the passed box size.
       * @param {import("./size.js").Size} [size] The pixel dimensions of the box
       * into which the calculated extent should fit. Defaults to the size of the
       * map the view is associated with.
       * If no map or multiple maps are connected to the view, provide the desired
       * box size (e.g. `map.getSize()`).
       * @return {import("./extent.js").Extent} Extent.
       * @api
       */
      calculateExtent(size) {
        const extent = this.calculateExtentInternal(size);
        return toUserExtent(extent, this.getProjection());
      }
      /**
       * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
       * the map's last known viewport size will be used.
       * @return {import("./extent.js").Extent} Extent.
       */
      calculateExtentInternal(size) {
        size = size || this.getViewportSizeMinusPadding_();
        const center = (
          /** @type {!import("./coordinate.js").Coordinate} */
          this.getCenterInternal()
        );
        assert(center, "The view center is not defined");
        const resolution = (
          /** @type {!number} */
          this.getResolution()
        );
        assert(resolution !== void 0, "The view resolution is not defined");
        const rotation = (
          /** @type {!number} */
          this.getRotation()
        );
        assert(rotation !== void 0, "The view rotation is not defined");
        return getForViewAndSize(center, resolution, rotation, size);
      }
      /**
       * Get the maximum resolution of the view.
       * @return {number} The maximum resolution of the view.
       * @api
       */
      getMaxResolution() {
        return this.maxResolution_;
      }
      /**
       * Get the minimum resolution of the view.
       * @return {number} The minimum resolution of the view.
       * @api
       */
      getMinResolution() {
        return this.minResolution_;
      }
      /**
       * Get the maximum zoom level for the view.
       * @return {number} The maximum zoom level.
       * @api
       */
      getMaxZoom() {
        return (
          /** @type {number} */
          this.getZoomForResolution(this.minResolution_)
        );
      }
      /**
       * Set a new maximum zoom level for the view.
       * @param {number} zoom The maximum zoom level.
       * @api
       */
      setMaxZoom(zoom) {
        this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
      }
      /**
       * Get the minimum zoom level for the view.
       * @return {number} The minimum zoom level.
       * @api
       */
      getMinZoom() {
        return (
          /** @type {number} */
          this.getZoomForResolution(this.maxResolution_)
        );
      }
      /**
       * Set a new minimum zoom level for the view.
       * @param {number} zoom The minimum zoom level.
       * @api
       */
      setMinZoom(zoom) {
        this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
      }
      /**
       * Set whether the view should allow intermediary zoom levels.
       * @param {boolean} enabled Whether the resolution is constrained.
       * @api
       */
      setConstrainResolution(enabled) {
        this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));
      }
      /**
       * Get the view projection.
       * @return {import("./proj/Projection.js").default} The projection of the view.
       * @api
       */
      getProjection() {
        return this.projection_;
      }
      /**
       * Get the view resolution.
       * @return {number|undefined} The resolution of the view.
       * @observable
       * @api
       */
      getResolution() {
        return (
          /** @type {number|undefined} */
          this.get(ViewProperty_default.RESOLUTION)
        );
      }
      /**
       * Get the resolutions for the view. This returns the array of resolutions
       * passed to the constructor of the View, or undefined if none were given.
       * @return {Array<number>|undefined} The resolutions of the view.
       * @api
       */
      getResolutions() {
        return this.resolutions_;
      }
      /**
       * Get the resolution for a provided extent (in map units) and size (in pixels).
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {import("./size.js").Size} [size] Box pixel size.
       * @return {number} The resolution at which the provided extent will render at
       *     the given size.
       * @api
       */
      getResolutionForExtent(extent, size) {
        return this.getResolutionForExtentInternal(
          fromUserExtent(extent, this.getProjection()),
          size
        );
      }
      /**
       * Get the resolution for a provided extent (in map units) and size (in pixels).
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {import("./size.js").Size} [size] Box pixel size.
       * @return {number} The resolution at which the provided extent will render at
       *     the given size.
       */
      getResolutionForExtentInternal(extent, size) {
        size = size || this.getViewportSizeMinusPadding_();
        const xResolution = getWidth(extent) / size[0];
        const yResolution = getHeight(extent) / size[1];
        return Math.max(xResolution, yResolution);
      }
      /**
       * Return a function that returns a value between 0 and 1 for a
       * resolution. Exponential scaling is assumed.
       * @param {number} [power] Power.
       * @return {function(number): number} Resolution for value function.
       */
      getResolutionForValueFunction(power) {
        power = power || 2;
        const maxResolution = this.getConstrainedResolution(this.maxResolution_);
        const minResolution = this.minResolution_;
        const max = Math.log(maxResolution / minResolution) / Math.log(power);
        return (
          /**
           * @param {number} value Value.
           * @return {number} Resolution.
           */
          function(value) {
            const resolution = maxResolution / Math.pow(power, value * max);
            return resolution;
          }
        );
      }
      /**
       * Get the view rotation.
       * @return {number} The rotation of the view in radians.
       * @observable
       * @api
       */
      getRotation() {
        return (
          /** @type {number} */
          this.get(ViewProperty_default.ROTATION)
        );
      }
      /**
       * Return a function that returns a resolution for a value between
       * 0 and 1. Exponential scaling is assumed.
       * @param {number} [power] Power.
       * @return {function(number): number} Value for resolution function.
       */
      getValueForResolutionFunction(power) {
        const logPower = Math.log(power || 2);
        const maxResolution = this.getConstrainedResolution(this.maxResolution_);
        const minResolution = this.minResolution_;
        const max = Math.log(maxResolution / minResolution) / logPower;
        return (
          /**
           * @param {number} resolution Resolution.
           * @return {number} Value.
           */
          function(resolution) {
            const value = Math.log(maxResolution / resolution) / logPower / max;
            return value;
          }
        );
      }
      /**
       * Returns the size of the viewport minus padding.
       * @private
       * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
       * @return {import("./size.js").Size} Viewport size reduced by the padding.
       */
      getViewportSizeMinusPadding_(rotation) {
        let size = this.getViewportSize_(rotation);
        const padding = this.padding_;
        if (padding) {
          size = [
            size[0] - padding[1] - padding[3],
            size[1] - padding[0] - padding[2]
          ];
        }
        return size;
      }
      /**
       * @return {State} View state.
       */
      getState() {
        const projection = this.getProjection();
        const resolution = this.getResolution();
        const rotation = this.getRotation();
        let center = (
          /** @type {import("./coordinate.js").Coordinate} */
          this.getCenterInternal()
        );
        const padding = this.padding_;
        if (padding) {
          const reducedSize = this.getViewportSizeMinusPadding_();
          center = calculateCenterOn(
            center,
            this.getViewportSize_(),
            [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
            resolution,
            rotation
          );
        }
        return {
          center: center.slice(0),
          projection: projection !== void 0 ? projection : null,
          resolution,
          nextCenter: this.nextCenter_,
          nextResolution: this.nextResolution_,
          nextRotation: this.nextRotation_,
          rotation,
          zoom: this.getZoom()
        };
      }
      /**
       * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
       */
      getViewStateAndExtent() {
        return {
          viewState: this.getState(),
          extent: this.calculateExtent()
        };
      }
      /**
       * Get the current zoom level. This method may return non-integer zoom levels
       * if the view does not constrain the resolution, or if an interaction or
       * animation is underway.
       * @return {number|undefined} Zoom.
       * @api
       */
      getZoom() {
        let zoom;
        const resolution = this.getResolution();
        if (resolution !== void 0) {
          zoom = this.getZoomForResolution(resolution);
        }
        return zoom;
      }
      /**
       * Get the zoom level for a resolution.
       * @param {number} resolution The resolution.
       * @return {number|undefined} The zoom level for the provided resolution.
       * @api
       */
      getZoomForResolution(resolution) {
        let offset2 = this.minZoom_ || 0;
        let max, zoomFactor;
        if (this.resolutions_) {
          const nearest = linearFindNearest(this.resolutions_, resolution, 1);
          offset2 = nearest;
          max = this.resolutions_[nearest];
          if (nearest == this.resolutions_.length - 1) {
            zoomFactor = 2;
          } else {
            zoomFactor = max / this.resolutions_[nearest + 1];
          }
        } else {
          max = this.maxResolution_;
          zoomFactor = this.zoomFactor_;
        }
        return offset2 + Math.log(max / resolution) / Math.log(zoomFactor);
      }
      /**
       * Get the resolution for a zoom level.
       * @param {number} zoom Zoom level.
       * @return {number} The view resolution for the provided zoom level.
       * @api
       */
      getResolutionForZoom(zoom) {
        if (this.resolutions_) {
          if (this.resolutions_.length <= 1) {
            return 0;
          }
          const baseLevel = clamp(
            Math.floor(zoom),
            0,
            this.resolutions_.length - 2
          );
          const zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
          return this.resolutions_[baseLevel] / Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1));
        }
        return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
      }
      /**
       * Fit the given geometry or extent based on the given map size and border.
       * The size is pixel dimensions of the box to fit the extent into.
       * In most cases you will want to use the map size, that is `map.getSize()`.
       * Takes care of the map angle.
       * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
       *     extent to fit the view to.
       * @param {FitOptions} [options] Options.
       * @api
       */
      fit(geometryOrExtent, options) {
        let geometry;
        assert(
          Array.isArray(geometryOrExtent) || typeof /** @type {?} */
          geometryOrExtent.getSimplifiedGeometry === "function",
          "Invalid extent or geometry provided as `geometry`"
        );
        if (Array.isArray(geometryOrExtent)) {
          assert(
            !isEmpty2(geometryOrExtent),
            "Cannot fit empty extent provided as `geometry`"
          );
          const extent = fromUserExtent(geometryOrExtent, this.getProjection());
          geometry = fromExtent(extent);
        } else if (geometryOrExtent.getType() === "Circle") {
          const extent = fromUserExtent(
            geometryOrExtent.getExtent(),
            this.getProjection()
          );
          geometry = fromExtent(extent);
          geometry.rotate(this.getRotation(), getCenter(extent));
        } else {
          const userProjection2 = getUserProjection();
          if (userProjection2) {
            geometry = /** @type {import("./geom/SimpleGeometry.js").default} */
            geometryOrExtent.clone().transform(userProjection2, this.getProjection());
          } else {
            geometry = geometryOrExtent;
          }
        }
        this.fitInternal(geometry, options);
      }
      /**
       * Calculate rotated extent
       * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
       * @return {import("./extent").Extent} The rotated extent for the geometry.
       */
      rotatedExtentForGeometry(geometry) {
        const rotation = this.getRotation();
        const cosAngle = Math.cos(rotation);
        const sinAngle = Math.sin(-rotation);
        const coords = geometry.getFlatCoordinates();
        const stride = geometry.getStride();
        let minRotX = Infinity;
        let minRotY = Infinity;
        let maxRotX = -Infinity;
        let maxRotY = -Infinity;
        for (let i = 0, ii = coords.length; i < ii; i += stride) {
          const rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
          const rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
          minRotX = Math.min(minRotX, rotX);
          minRotY = Math.min(minRotY, rotY);
          maxRotX = Math.max(maxRotX, rotX);
          maxRotY = Math.max(maxRotY, rotY);
        }
        return [minRotX, minRotY, maxRotX, maxRotY];
      }
      /**
       * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
       * @param {FitOptions} [options] Options.
       */
      fitInternal(geometry, options) {
        options = options || {};
        let size = options.size;
        if (!size) {
          size = this.getViewportSizeMinusPadding_();
        }
        const padding = options.padding !== void 0 ? options.padding : [0, 0, 0, 0];
        const nearest = options.nearest !== void 0 ? options.nearest : false;
        let minResolution;
        if (options.minResolution !== void 0) {
          minResolution = options.minResolution;
        } else if (options.maxZoom !== void 0) {
          minResolution = this.getResolutionForZoom(options.maxZoom);
        } else {
          minResolution = 0;
        }
        const rotatedExtent = this.rotatedExtentForGeometry(geometry);
        let resolution = this.getResolutionForExtentInternal(rotatedExtent, [
          size[0] - padding[1] - padding[3],
          size[1] - padding[0] - padding[2]
        ]);
        resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
        resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
        const rotation = this.getRotation();
        const sinAngle = Math.sin(rotation);
        const cosAngle = Math.cos(rotation);
        const centerRot = getCenter(rotatedExtent);
        centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
        centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
        const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
        const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
        const center = this.getConstrainedCenter([centerX, centerY], resolution);
        const callback = options.callback ? options.callback : VOID;
        if (options.duration !== void 0) {
          this.animateInternal(
            {
              resolution,
              center,
              duration: options.duration,
              easing: options.easing
            },
            callback
          );
        } else {
          this.targetResolution_ = resolution;
          this.targetCenter_ = center;
          this.applyTargetState_(false, true);
          animationCallback(callback, true);
        }
      }
      /**
       * Center on coordinate and view position.
       * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("./size.js").Size} size Box pixel size.
       * @param {import("./pixel.js").Pixel} position Position on the view to center on.
       * @api
       */
      centerOn(coordinate, size, position) {
        this.centerOnInternal(
          fromUserCoordinate(coordinate, this.getProjection()),
          size,
          position
        );
      }
      /**
       * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("./size.js").Size} size Box pixel size.
       * @param {import("./pixel.js").Pixel} position Position on the view to center on.
       */
      centerOnInternal(coordinate, size, position) {
        this.setCenterInternal(
          calculateCenterOn(
            coordinate,
            size,
            position,
            this.getResolution(),
            this.getRotation()
          )
        );
      }
      /**
       * Calculates the shift between map and viewport center.
       * @param {import("./coordinate.js").Coordinate} center Center.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {import("./size.js").Size} size Size.
       * @return {Array<number>|undefined} Center shift.
       */
      calculateCenterShift(center, resolution, rotation, size) {
        let centerShift;
        const padding = this.padding_;
        if (padding && center) {
          const reducedSize = this.getViewportSizeMinusPadding_(-rotation);
          const shiftedCenter = calculateCenterOn(
            center,
            size,
            [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
            resolution,
            rotation
          );
          centerShift = [
            center[0] - shiftedCenter[0],
            center[1] - shiftedCenter[1]
          ];
        }
        return centerShift;
      }
      /**
       * @return {boolean} Is defined.
       */
      isDef() {
        return !!this.getCenterInternal() && this.getResolution() !== void 0;
      }
      /**
       * Adds relative coordinates to the center of the view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
       * @api
       */
      adjustCenter(deltaCoordinates) {
        const center = toUserCoordinate(this.targetCenter_, this.getProjection());
        this.setCenter([
          center[0] + deltaCoordinates[0],
          center[1] + deltaCoordinates[1]
        ]);
      }
      /**
       * Adds relative coordinates to the center of the view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
       */
      adjustCenterInternal(deltaCoordinates) {
        const center = this.targetCenter_;
        this.setCenterInternal([
          center[0] + deltaCoordinates[0],
          center[1] + deltaCoordinates[1]
        ]);
      }
      /**
       * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} ratio The ratio to apply on the view resolution.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       * @api
       */
      adjustResolution(ratio, anchor) {
        anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
        this.adjustResolutionInternal(ratio, anchor);
      }
      /**
       * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} ratio The ratio to apply on the view resolution.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       */
      adjustResolutionInternal(ratio, anchor) {
        const isMoving = this.getAnimating() || this.getInteracting();
        const size = this.getViewportSize_(this.getRotation());
        const newResolution = this.constraints_.resolution(
          this.targetResolution_ * ratio,
          0,
          size,
          isMoving
        );
        if (anchor) {
          this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);
        }
        this.targetResolution_ *= ratio;
        this.applyTargetState_();
      }
      /**
       * Adds a value to the view zoom level, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} delta Relative value to add to the zoom level.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       * @api
       */
      adjustZoom(delta, anchor) {
        this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);
      }
      /**
       * Adds a value to the view rotation, optionally using an anchor. Any rotation
       * constraint will apply.
       * @param {number} delta Relative value to add to the zoom rotation, in radians.
       * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
       * @api
       */
      adjustRotation(delta, anchor) {
        if (anchor) {
          anchor = fromUserCoordinate(anchor, this.getProjection());
        }
        this.adjustRotationInternal(delta, anchor);
      }
      /**
       * @param {number} delta Relative value to add to the zoom rotation, in radians.
       * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
       */
      adjustRotationInternal(delta, anchor) {
        const isMoving = this.getAnimating() || this.getInteracting();
        const newRotation = this.constraints_.rotation(
          this.targetRotation_ + delta,
          isMoving
        );
        if (anchor) {
          this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);
        }
        this.targetRotation_ += delta;
        this.applyTargetState_();
      }
      /**
       * Set the center of the current view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
       * @observable
       * @api
       */
      setCenter(center) {
        this.setCenterInternal(
          center ? fromUserCoordinate(center, this.getProjection()) : center
        );
      }
      /**
       * Set the center using the view projection (not the user projection).
       * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
       */
      setCenterInternal(center) {
        this.targetCenter_ = center;
        this.applyTargetState_();
      }
      /**
       * @param {import("./ViewHint.js").default} hint Hint.
       * @param {number} delta Delta.
       * @return {number} New value.
       */
      setHint(hint, delta) {
        this.hints_[hint] += delta;
        this.changed();
        return this.hints_[hint];
      }
      /**
       * Set the resolution for this view. Any resolution constraint will apply.
       * @param {number|undefined} resolution The resolution of the view.
       * @observable
       * @api
       */
      setResolution(resolution) {
        this.targetResolution_ = resolution;
        this.applyTargetState_();
      }
      /**
       * Set the rotation for this view. Any rotation constraint will apply.
       * @param {number} rotation The rotation of the view in radians.
       * @observable
       * @api
       */
      setRotation(rotation) {
        this.targetRotation_ = rotation;
        this.applyTargetState_();
      }
      /**
       * Zoom to a specific zoom level. Any resolution constrain will apply.
       * @param {number} zoom Zoom level.
       * @api
       */
      setZoom(zoom) {
        this.setResolution(this.getResolutionForZoom(zoom));
      }
      /**
       * Recompute rotation/resolution/center based on target values.
       * Note: we have to compute rotation first, then resolution and center considering that
       * parameters can influence one another in case a view extent constraint is present.
       * @param {boolean} [doNotCancelAnims] Do not cancel animations.
       * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
       * @private
       */
      applyTargetState_(doNotCancelAnims, forceMoving) {
        const isMoving = this.getAnimating() || this.getInteracting() || forceMoving;
        const newRotation = this.constraints_.rotation(
          this.targetRotation_,
          isMoving
        );
        const size = this.getViewportSize_(newRotation);
        const newResolution = this.constraints_.resolution(
          this.targetResolution_,
          0,
          size,
          isMoving
        );
        const newCenter = this.constraints_.center(
          this.targetCenter_,
          newResolution,
          size,
          isMoving,
          this.calculateCenterShift(
            this.targetCenter_,
            newResolution,
            newRotation,
            size
          )
        );
        if (this.get(ViewProperty_default.ROTATION) !== newRotation) {
          this.set(ViewProperty_default.ROTATION, newRotation);
        }
        if (this.get(ViewProperty_default.RESOLUTION) !== newResolution) {
          this.set(ViewProperty_default.RESOLUTION, newResolution);
          this.set("zoom", this.getZoom(), true);
        }
        if (!newCenter || !this.get(ViewProperty_default.CENTER) || !equals3(this.get(ViewProperty_default.CENTER), newCenter)) {
          this.set(ViewProperty_default.CENTER, newCenter);
        }
        if (this.getAnimating() && !doNotCancelAnims) {
          this.cancelAnimations();
        }
        this.cancelAnchor_ = void 0;
      }
      /**
       * If any constraints need to be applied, an animation will be triggered.
       * This is typically done on interaction end.
       * Note: calling this with a duration of 0 will apply the constrained values straight away,
       * without animation.
       * @param {number} [duration] The animation duration in ms.
       * @param {number} [resolutionDirection] Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       */
      resolveConstraints(duration, resolutionDirection, anchor) {
        duration = duration !== void 0 ? duration : 200;
        const direction = resolutionDirection || 0;
        const newRotation = this.constraints_.rotation(this.targetRotation_);
        const size = this.getViewportSize_(newRotation);
        const newResolution = this.constraints_.resolution(
          this.targetResolution_,
          direction,
          size
        );
        const newCenter = this.constraints_.center(
          this.targetCenter_,
          newResolution,
          size,
          false,
          this.calculateCenterShift(
            this.targetCenter_,
            newResolution,
            newRotation,
            size
          )
        );
        if (duration === 0 && !this.cancelAnchor_) {
          this.targetResolution_ = newResolution;
          this.targetRotation_ = newRotation;
          this.targetCenter_ = newCenter;
          this.applyTargetState_();
          return;
        }
        anchor = anchor || (duration === 0 ? this.cancelAnchor_ : void 0);
        this.cancelAnchor_ = void 0;
        if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !equals3(this.getCenterInternal(), newCenter)) {
          if (this.getAnimating()) {
            this.cancelAnimations();
          }
          this.animateInternal({
            rotation: newRotation,
            center: newCenter,
            resolution: newResolution,
            duration,
            easing: easeOut,
            anchor
          });
        }
      }
      /**
       * Notify the View that an interaction has started.
       * The view state will be resolved to a stable one if needed
       * (depending on its constraints).
       * @api
       */
      beginInteraction() {
        this.resolveConstraints(0);
        this.setHint(ViewHint_default.INTERACTING, 1);
      }
      /**
       * Notify the View that an interaction has ended. The view state will be resolved
       * to a stable one if needed (depending on its constraints).
       * @param {number} [duration] Animation duration in ms.
       * @param {number} [resolutionDirection] Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       * @api
       */
      endInteraction(duration, resolutionDirection, anchor) {
        anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
        this.endInteractionInternal(duration, resolutionDirection, anchor);
      }
      /**
       * Notify the View that an interaction has ended. The view state will be resolved
       * to a stable one if needed (depending on its constraints).
       * @param {number} [duration] Animation duration in ms.
       * @param {number} [resolutionDirection] Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
       */
      endInteractionInternal(duration, resolutionDirection, anchor) {
        if (!this.getInteracting()) {
          return;
        }
        this.setHint(ViewHint_default.INTERACTING, -1);
        this.resolveConstraints(duration, resolutionDirection, anchor);
      }
      /**
       * Get a valid position for the view center according to the current constraints.
       * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
       * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
       * This is useful to guess a valid center position at a different zoom level.
       * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
       */
      getConstrainedCenter(targetCenter, targetResolution) {
        const size = this.getViewportSize_(this.getRotation());
        return this.constraints_.center(
          targetCenter,
          targetResolution || this.getResolution(),
          size
        );
      }
      /**
       * Get a valid zoom level according to the current view constraints.
       * @param {number|undefined} targetZoom Target zoom.
       * @param {number} [direction=0] Indicate which resolution should be used
       * by a renderer if the view resolution does not match any resolution of the tile source.
       * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
       * will be used. If -1, the nearest higher resolution will be used.
       * @return {number|undefined} Valid zoom level.
       */
      getConstrainedZoom(targetZoom, direction) {
        const targetRes = this.getResolutionForZoom(targetZoom);
        return this.getZoomForResolution(
          this.getConstrainedResolution(targetRes, direction)
        );
      }
      /**
       * Get a valid resolution according to the current view constraints.
       * @param {number|undefined} targetResolution Target resolution.
       * @param {number} [direction=0] Indicate which resolution should be used
       * by a renderer if the view resolution does not match any resolution of the tile source.
       * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
       * will be used. If -1, the nearest higher resolution will be used.
       * @return {number|undefined} Valid resolution.
       */
      getConstrainedResolution(targetResolution, direction) {
        direction = direction || 0;
        const size = this.getViewportSize_(this.getRotation());
        return this.constraints_.resolution(targetResolution, direction, size);
      }
    };
    View_default = View;
  }
});

// node_modules/ol/layer/Layer.js
function inView(layerState, viewState) {
  if (!layerState.visible) {
    return false;
  }
  const resolution = viewState.resolution;
  if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) {
    return false;
  }
  const zoom = viewState.zoom;
  return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
}
var Layer, Layer_default;
var init_Layer = __esm({
  "node_modules/ol/layer/Layer.js"() {
    init_Base();
    init_EventType();
    init_Property();
    init_EventType2();
    init_View();
    init_asserts();
    init_extent();
    init_events();
    Layer = class extends Base_default {
      /**
       * @param {Options<SourceType>} options Layer options.
       */
      constructor(options) {
        const baseOptions = Object.assign({}, options);
        delete baseOptions.source;
        super(baseOptions);
        this.on;
        this.once;
        this.un;
        this.mapPrecomposeKey_ = null;
        this.mapRenderKey_ = null;
        this.sourceChangeKey_ = null;
        this.renderer_ = null;
        this.sourceReady_ = false;
        this.rendered = false;
        if (options.render) {
          this.render = options.render;
        }
        if (options.map) {
          this.setMap(options.map);
        }
        this.addChangeListener(
          Property_default.SOURCE,
          this.handleSourcePropertyChange_
        );
        const source = options.source ? (
          /** @type {SourceType} */
          options.source
        ) : null;
        this.setSource(source);
      }
      /**
       * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       */
      getLayersArray(array) {
        array = array ? array : [];
        array.push(this);
        return array;
      }
      /**
       * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       */
      getLayerStatesArray(states) {
        states = states ? states : [];
        states.push(this.getLayerState());
        return states;
      }
      /**
       * Get the layer source.
       * @return {SourceType|null} The layer source (or `null` if not yet set).
       * @observable
       * @api
       */
      getSource() {
        return (
          /** @type {SourceType} */
          this.get(Property_default.SOURCE) || null
        );
      }
      /**
       * @return {SourceType|null} The source being rendered.
       */
      getRenderSource() {
        return this.getSource();
      }
      /**
       * @return {import("../source/Source.js").State} Source state.
       */
      getSourceState() {
        const source = this.getSource();
        return !source ? "undefined" : source.getState();
      }
      /**
       * @private
       */
      handleSourceChange_() {
        this.changed();
        if (this.sourceReady_ || this.getSource().getState() !== "ready") {
          return;
        }
        this.sourceReady_ = true;
        this.dispatchEvent("sourceready");
      }
      /**
       * @private
       */
      handleSourcePropertyChange_() {
        if (this.sourceChangeKey_) {
          unlistenByKey(this.sourceChangeKey_);
          this.sourceChangeKey_ = null;
        }
        this.sourceReady_ = false;
        const source = this.getSource();
        if (source) {
          this.sourceChangeKey_ = listen(
            source,
            EventType_default.CHANGE,
            this.handleSourceChange_,
            this
          );
          if (source.getState() === "ready") {
            this.sourceReady_ = true;
            setTimeout(() => {
              this.dispatchEvent("sourceready");
            }, 0);
          }
        }
        this.changed();
      }
      /**
       * @param {import("../pixel").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
       * an array of features.
       */
      getFeatures(pixel) {
        if (!this.renderer_) {
          return Promise.resolve([]);
        }
        return this.renderer_.getFeatures(pixel);
      }
      /**
       * @param {import("../pixel").Pixel} pixel Pixel.
       * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
       */
      getData(pixel) {
        if (!this.renderer_ || !this.rendered) {
          return null;
        }
        return this.renderer_.getData(pixel);
      }
      /**
       * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
       * extent, not set to `visible: false`, and not inside a layer group that is set
       * to `visible: false`.
       * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
       * Only required when the layer is not added to a map.
       * @return {boolean} The layer is visible in the map view.
       * @api
       */
      isVisible(view) {
        let frameState;
        const map = this.getMapInternal();
        if (!view && map) {
          view = map.getView();
        }
        if (view instanceof View_default) {
          frameState = {
            viewState: view.getState(),
            extent: view.calculateExtent()
          };
        } else {
          frameState = view;
        }
        if (!frameState.layerStatesArray && map) {
          frameState.layerStatesArray = map.getLayerGroup().getLayerStatesArray();
        }
        let layerState;
        if (frameState.layerStatesArray) {
          layerState = frameState.layerStatesArray.find(
            (layerState2) => layerState2.layer === this
          );
        } else {
          layerState = this.getLayerState();
        }
        const layerExtent = this.getExtent();
        return inView(layerState, frameState.viewState) && (!layerExtent || intersects(layerExtent, frameState.extent));
      }
      /**
       * Get the attributions of the source of this layer for the given view.
       * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
       * Only required when the layer is not added to a map.
       * @return {Array<string>} Attributions for this layer at the given view.
       * @api
       */
      getAttributions(view) {
        if (!this.isVisible(view)) {
          return [];
        }
        let getAttributions;
        const source = this.getSource();
        if (source) {
          getAttributions = source.getAttributions();
        }
        if (!getAttributions) {
          return [];
        }
        const frameState = view instanceof View_default ? view.getViewStateAndExtent() : view;
        let attributions = getAttributions(frameState);
        if (!Array.isArray(attributions)) {
          attributions = [attributions];
        }
        return attributions;
      }
      /**
       * In charge to manage the rendering of the layer. One layer type is
       * bounded with one layer renderer.
       * @param {?import("../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target which the renderer may (but need not) use
       * for rendering its content.
       * @return {HTMLElement|null} The rendered element.
       */
      render(frameState, target) {
        const layerRenderer = this.getRenderer();
        if (layerRenderer.prepareFrame(frameState)) {
          this.rendered = true;
          return layerRenderer.renderFrame(frameState, target);
        }
        return null;
      }
      /**
       * Called when a layer is not visible during a map render.
       */
      unrender() {
        this.rendered = false;
      }
      /**
       * For use inside the library only.
       * @param {import("../Map.js").default|null} map Map.
       */
      setMapInternal(map) {
        if (!map) {
          this.unrender();
        }
        this.set(Property_default.MAP, map);
      }
      /**
       * For use inside the library only.
       * @return {import("../Map.js").default|null} Map.
       */
      getMapInternal() {
        return this.get(Property_default.MAP);
      }
      /**
       * Sets the layer to be rendered on top of other layers on a map. The map will
       * not manage this layer in its layers collection. This
       * is useful for temporary layers. To remove an unmanaged layer from the map,
       * use `#setMap(null)`.
       *
       * To add the layer to a map and have it managed by the map, use
       * {@link module:ol/Map~Map#addLayer} instead.
       * @param {import("../Map.js").default|null} map Map.
       * @api
       */
      setMap(map) {
        if (this.mapPrecomposeKey_) {
          unlistenByKey(this.mapPrecomposeKey_);
          this.mapPrecomposeKey_ = null;
        }
        if (!map) {
          this.changed();
        }
        if (this.mapRenderKey_) {
          unlistenByKey(this.mapRenderKey_);
          this.mapRenderKey_ = null;
        }
        if (map) {
          this.mapPrecomposeKey_ = listen(
            map,
            EventType_default2.PRECOMPOSE,
            function(evt) {
              const renderEvent = (
                /** @type {import("../render/Event.js").default} */
                evt
              );
              const layerStatesArray = renderEvent.frameState.layerStatesArray;
              const layerState = this.getLayerState(false);
              assert(
                !layerStatesArray.some(function(arrayLayerState) {
                  return arrayLayerState.layer === layerState.layer;
                }),
                "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
              );
              layerStatesArray.push(layerState);
            },
            this
          );
          this.mapRenderKey_ = listen(this, EventType_default.CHANGE, map.render, map);
          this.changed();
        }
      }
      /**
       * Set the layer source.
       * @param {SourceType|null} source The layer source.
       * @observable
       * @api
       */
      setSource(source) {
        this.set(Property_default.SOURCE, source);
      }
      /**
       * Get the renderer for this layer.
       * @return {RendererType|null} The layer renderer.
       */
      getRenderer() {
        if (!this.renderer_) {
          this.renderer_ = this.createRenderer();
        }
        return this.renderer_;
      }
      /**
       * @return {boolean} The layer has a renderer.
       */
      hasRenderer() {
        return !!this.renderer_;
      }
      /**
       * Create a renderer for this layer.
       * @return {RendererType} A layer renderer.
       * @protected
       */
      createRenderer() {
        return null;
      }
      /**
       * Clean up.
       */
      disposeInternal() {
        if (this.renderer_) {
          this.renderer_.dispose();
          delete this.renderer_;
        }
        this.setSource(null);
        super.disposeInternal();
      }
    };
    Layer_default = Layer;
  }
});

// node_modules/ol/render/Event.js
var RenderEvent, Event_default2;
var init_Event2 = __esm({
  "node_modules/ol/render/Event.js"() {
    init_Event();
    RenderEvent = class extends Event_default {
      /**
       * @param {import("./EventType.js").default} type Type.
       * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
       *     CSS pixels to rendered pixels.
       * @param {import("../Map.js").FrameState} [frameState] Frame state.
       * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
       */
      constructor(type, inversePixelTransform, frameState, context) {
        super(type);
        this.inversePixelTransform = inversePixelTransform;
        this.frameState = frameState;
        this.context = context;
      }
    };
    Event_default2 = RenderEvent;
  }
});

// node_modules/ol/css.js
var CLASS_HIDDEN, CLASS_SELECTABLE, CLASS_UNSELECTABLE, CLASS_UNSUPPORTED, CLASS_CONTROL, CLASS_COLLAPSED, fontRegEx, fontRegExMatchIndex, getFontParameters;
var init_css = __esm({
  "node_modules/ol/css.js"() {
    CLASS_HIDDEN = "ol-hidden";
    CLASS_SELECTABLE = "ol-selectable";
    CLASS_UNSELECTABLE = "ol-unselectable";
    CLASS_UNSUPPORTED = "ol-unsupported";
    CLASS_CONTROL = "ol-control";
    CLASS_COLLAPSED = "ol-collapsed";
    fontRegEx = new RegExp(
      [
        "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
        "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
        "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
        "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
        "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
        "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
        `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
      ].join(""),
      "i"
    );
    fontRegExMatchIndex = [
      "style",
      "variant",
      "weight",
      "size",
      "lineHeight",
      "family"
    ];
    getFontParameters = function(fontSpec) {
      const match = fontSpec.match(fontRegEx);
      if (!match) {
        return null;
      }
      const style = (
        /** @type {FontParameters} */
        {
          lineHeight: "normal",
          size: "1.2em",
          style: "normal",
          weight: "normal",
          variant: "normal"
        }
      );
      for (let i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {
        const value = match[i + 1];
        if (value !== void 0) {
          style[fontRegExMatchIndex[i]] = value;
        }
      }
      style.families = style.family.split(/,\s?/);
      return style;
    };
  }
});

// node_modules/ol/dom.js
function createCanvasContext2D(width, height, canvasPool3, settings) {
  let canvas;
  if (canvasPool3 && canvasPool3.length) {
    canvas = /** @type {HTMLCanvasElement} */
    canvasPool3.shift();
  } else if (WORKER_OFFSCREEN_CANVAS) {
    canvas = new OffscreenCanvas(width || 300, height || 300);
  } else {
    canvas = document.createElement("canvas");
  }
  if (width) {
    canvas.width = width;
  }
  if (height) {
    canvas.height = height;
  }
  return (
    /** @type {CanvasRenderingContext2D} */
    canvas.getContext("2d", settings)
  );
}
function releaseCanvas(context) {
  const canvas = context.canvas;
  canvas.width = 1;
  canvas.height = 1;
  context.clearRect(0, 0, 1, 1);
}
function outerWidth(element) {
  let width = element.offsetWidth;
  const style = getComputedStyle(element);
  width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
  return width;
}
function outerHeight(element) {
  let height = element.offsetHeight;
  const style = getComputedStyle(element);
  height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
  return height;
}
function replaceNode(newNode, oldNode) {
  const parent = oldNode.parentNode;
  if (parent) {
    parent.replaceChild(newNode, oldNode);
  }
}
function removeNode(node) {
  return node && node.parentNode ? node.parentNode.removeChild(node) : null;
}
function removeChildren(node) {
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
}
function replaceChildren(node, children) {
  const oldChildren = node.childNodes;
  for (let i = 0; true; ++i) {
    const oldChild = oldChildren[i];
    const newChild = children[i];
    if (!oldChild && !newChild) {
      break;
    }
    if (oldChild === newChild) {
      continue;
    }
    if (!oldChild) {
      node.appendChild(newChild);
      continue;
    }
    if (!newChild) {
      node.removeChild(oldChild);
      --i;
      continue;
    }
    node.insertBefore(newChild, oldChild);
  }
}
var init_dom = __esm({
  "node_modules/ol/dom.js"() {
    init_has();
  }
});

// node_modules/ol/render/canvas.js
function measureText(font, text) {
  if (!measureContext) {
    measureContext = createCanvasContext2D(1, 1);
  }
  if (font != measureFont) {
    measureContext.font = font;
    measureFont = measureContext.font;
  }
  return measureContext.measureText(text);
}
function measureTextWidth(font, text) {
  return measureText(font, text).width;
}
function measureAndCacheTextWidth(font, text, cache3) {
  if (text in cache3) {
    return cache3[text];
  }
  const width = text.split("\n").reduce((prev, curr) => Math.max(prev, measureTextWidth(font, curr)), 0);
  cache3[text] = width;
  return width;
}
function getTextDimensions(baseStyle, chunks) {
  const widths = [];
  const heights = [];
  const lineWidths = [];
  let width = 0;
  let lineWidth = 0;
  let height = 0;
  let lineHeight = 0;
  for (let i = 0, ii = chunks.length; i <= ii; i += 2) {
    const text = chunks[i];
    if (text === "\n" || i === ii) {
      width = Math.max(width, lineWidth);
      lineWidths.push(lineWidth);
      lineWidth = 0;
      height += lineHeight;
      continue;
    }
    const font = chunks[i + 1] || baseStyle.font;
    const currentWidth = measureTextWidth(font, text);
    widths.push(currentWidth);
    lineWidth += currentWidth;
    const currentHeight = measureTextHeight(font);
    heights.push(currentHeight);
    lineHeight = Math.max(lineHeight, currentHeight);
  }
  return { width, height, widths, heights, lineWidths };
}
function rotateAtOffset(context, rotation, offsetX, offsetY) {
  if (rotation !== 0) {
    context.translate(offsetX, offsetY);
    context.rotate(rotation);
    context.translate(-offsetX, -offsetY);
  }
}
function drawImageOrLabel(context, transform2, opacity, labelOrImage, originX, originY, w, h, x, y, scale5) {
  context.save();
  if (opacity !== 1) {
    context.globalAlpha *= opacity;
  }
  if (transform2) {
    context.transform.apply(context, transform2);
  }
  if (
    /** @type {*} */
    labelOrImage.contextInstructions
  ) {
    context.translate(x, y);
    context.scale(scale5[0], scale5[1]);
    executeLabelInstructions(
      /** @type {Label} */
      labelOrImage,
      context
    );
  } else if (scale5[0] < 0 || scale5[1] < 0) {
    context.translate(x, y);
    context.scale(scale5[0], scale5[1]);
    context.drawImage(
      /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
      labelOrImage,
      originX,
      originY,
      w,
      h,
      0,
      0,
      w,
      h
    );
  } else {
    context.drawImage(
      /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
      labelOrImage,
      originX,
      originY,
      w,
      h,
      x,
      y,
      w * scale5[0],
      h * scale5[1]
    );
  }
  context.restore();
}
function executeLabelInstructions(label, context) {
  const contextInstructions = label.contextInstructions;
  for (let i = 0, ii = contextInstructions.length; i < ii; i += 2) {
    if (Array.isArray(contextInstructions[i + 1])) {
      context[contextInstructions[i]].apply(
        context,
        contextInstructions[i + 1]
      );
    } else {
      context[contextInstructions[i]] = contextInstructions[i + 1];
    }
  }
}
var defaultFont, defaultFillStyle, defaultLineCap, defaultLineDash, defaultLineDashOffset, defaultLineJoin, defaultMiterLimit, defaultStrokeStyle, defaultTextAlign, defaultTextBaseline, defaultPadding, defaultLineWidth, checkedFonts, measureContext, measureFont, textHeights, registerFont, measureTextHeight;
var init_canvas = __esm({
  "node_modules/ol/render/canvas.js"() {
    init_Object();
    init_has();
    init_obj();
    init_dom();
    init_css();
    defaultFont = "10px sans-serif";
    defaultFillStyle = "#000";
    defaultLineCap = "round";
    defaultLineDash = [];
    defaultLineDashOffset = 0;
    defaultLineJoin = "round";
    defaultMiterLimit = 10;
    defaultStrokeStyle = "#000";
    defaultTextAlign = "center";
    defaultTextBaseline = "middle";
    defaultPadding = [0, 0, 0, 0];
    defaultLineWidth = 1;
    checkedFonts = new Object_default();
    measureContext = null;
    textHeights = {};
    registerFont = function() {
      const retries = 100;
      const size = "32px ";
      const referenceFonts = ["monospace", "serif"];
      const len = referenceFonts.length;
      const text = "wmytzilWMYTZIL@#/&?$%10\uF013";
      let interval, referenceWidth;
      function isAvailable(fontStyle, fontWeight, fontFamily) {
        let available = true;
        for (let i = 0; i < len; ++i) {
          const referenceFont = referenceFonts[i];
          referenceWidth = measureTextWidth(
            fontStyle + " " + fontWeight + " " + size + referenceFont,
            text
          );
          if (fontFamily != referenceFont) {
            const width = measureTextWidth(
              fontStyle + " " + fontWeight + " " + size + fontFamily + "," + referenceFont,
              text
            );
            available = available && width != referenceWidth;
          }
        }
        if (available) {
          return true;
        }
        return false;
      }
      function check() {
        let done = true;
        const fonts = checkedFonts.getKeys();
        for (let i = 0, ii = fonts.length; i < ii; ++i) {
          const font = fonts[i];
          if (checkedFonts.get(font) < retries) {
            if (isAvailable.apply(this, font.split("\n"))) {
              clear(textHeights);
              measureContext = null;
              measureFont = void 0;
              checkedFonts.set(font, retries);
            } else {
              checkedFonts.set(font, checkedFonts.get(font) + 1, true);
              done = false;
            }
          }
        }
        if (done) {
          clearInterval(interval);
          interval = void 0;
        }
      }
      return function(fontSpec) {
        const font = getFontParameters(fontSpec);
        if (!font) {
          return;
        }
        const families = font.families;
        for (let i = 0, ii = families.length; i < ii; ++i) {
          const family = families[i];
          const key = font.style + "\n" + font.weight + "\n" + family;
          if (checkedFonts.get(key) === void 0) {
            checkedFonts.set(key, retries, true);
            if (!isAvailable(font.style, font.weight, family)) {
              checkedFonts.set(key, 0, true);
              if (interval === void 0) {
                interval = setInterval(check, 32);
              }
            }
          }
        }
      };
    }();
    measureTextHeight = /* @__PURE__ */ function() {
      let measureElement;
      return function(fontSpec) {
        let height = textHeights[fontSpec];
        if (height == void 0) {
          if (WORKER_OFFSCREEN_CANVAS) {
            const font = getFontParameters(fontSpec);
            const metrics = measureText(fontSpec, "\u017Dg");
            const lineHeight = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);
            height = lineHeight * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
          } else {
            if (!measureElement) {
              measureElement = document.createElement("div");
              measureElement.innerHTML = "M";
              measureElement.style.minHeight = "0";
              measureElement.style.maxHeight = "none";
              measureElement.style.height = "auto";
              measureElement.style.padding = "0";
              measureElement.style.border = "none";
              measureElement.style.position = "absolute";
              measureElement.style.display = "block";
              measureElement.style.left = "-99999px";
            }
            measureElement.style.font = fontSpec;
            document.body.appendChild(measureElement);
            height = measureElement.offsetHeight;
            document.body.removeChild(measureElement);
          }
          textHeights[fontSpec] = height;
        }
        return height;
      };
    }();
  }
});

// node_modules/ol/MapEventType.js
var MapEventType_default;
var init_MapEventType = __esm({
  "node_modules/ol/MapEventType.js"() {
    MapEventType_default = {
      /**
       * Triggered after a map frame is rendered.
       * @event module:ol/MapEvent~MapEvent#postrender
       * @api
       */
      POSTRENDER: "postrender",
      /**
       * Triggered when the map starts moving.
       * @event module:ol/MapEvent~MapEvent#movestart
       * @api
       */
      MOVESTART: "movestart",
      /**
       * Triggered after the map is moved.
       * @event module:ol/MapEvent~MapEvent#moveend
       * @api
       */
      MOVEEND: "moveend",
      /**
       * Triggered when loading of additional map data (tiles, images, features) starts.
       * @event module:ol/MapEvent~MapEvent#loadstart
       * @api
       */
      LOADSTART: "loadstart",
      /**
       * Triggered when loading of additional map data has completed.
       * @event module:ol/MapEvent~MapEvent#loadend
       * @api
       */
      LOADEND: "loadend"
    };
  }
});

// node_modules/ol/control/Control.js
var Control_exports = {};
__export(Control_exports, {
  default: () => Control_default
});
var Control, Control_default;
var init_Control = __esm({
  "node_modules/ol/control/Control.js"() {
    init_Object();
    init_MapEventType();
    init_functions();
    init_events();
    init_dom();
    Control = class extends Object_default {
      /**
       * @param {Options} options Control options.
       */
      constructor(options) {
        super();
        const element = options.element;
        if (element && !options.target && !element.style.pointerEvents) {
          element.style.pointerEvents = "auto";
        }
        this.element = element ? element : null;
        this.target_ = null;
        this.map_ = null;
        this.listenerKeys = [];
        if (options.render) {
          this.render = options.render;
        }
        if (options.target) {
          this.setTarget(options.target);
        }
      }
      /**
       * Clean up.
       */
      disposeInternal() {
        removeNode(this.element);
        super.disposeInternal();
      }
      /**
       * Get the map associated with this control.
       * @return {import("../Map.js").default|null} Map.
       * @api
       */
      getMap() {
        return this.map_;
      }
      /**
       * Remove the control from its current map and attach it to the new map.
       * Pass `null` to just remove the control from the current map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../Map.js").default|null} map Map.
       * @api
       */
      setMap(map) {
        if (this.map_) {
          removeNode(this.element);
        }
        for (let i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
          unlistenByKey(this.listenerKeys[i]);
        }
        this.listenerKeys.length = 0;
        this.map_ = map;
        if (map) {
          const target = this.target_ ? this.target_ : map.getOverlayContainerStopEvent();
          target.appendChild(this.element);
          if (this.render !== VOID) {
            this.listenerKeys.push(
              listen(map, MapEventType_default.POSTRENDER, this.render, this)
            );
          }
          map.render();
        }
      }
      /**
       * Renders the control.
       * @param {import("../MapEvent.js").default} mapEvent Map event.
       * @api
       */
      render(mapEvent) {
      }
      /**
       * This function is used to set a target element for the control. It has no
       * effect if it is called after the control has been added to the map (i.e.
       * after `setMap` is called on the control). If no `target` is set in the
       * options passed to the control constructor and if `setTarget` is not called
       * then the control is added to the map's overlay container.
       * @param {HTMLElement|string} target Target.
       * @api
       */
      setTarget(target) {
        this.target_ = typeof target === "string" ? document.getElementById(target) : target;
      }
    };
    Control_default = Control;
  }
});

// node_modules/ol/size.js
function buffer2(size, num, dest) {
  if (dest === void 0) {
    dest = [0, 0];
  }
  dest[0] = size[0] + 2 * num;
  dest[1] = size[1] + 2 * num;
  return dest;
}
function hasArea(size) {
  return size[0] > 0 && size[1] > 0;
}
function scale4(size, ratio, dest) {
  if (dest === void 0) {
    dest = [0, 0];
  }
  dest[0] = size[0] * ratio + 0.5 | 0;
  dest[1] = size[1] * ratio + 0.5 | 0;
  return dest;
}
function toSize(size, dest) {
  if (Array.isArray(size)) {
    return size;
  }
  if (dest === void 0) {
    dest = [size, size];
  } else {
    dest[0] = size;
    dest[1] = size;
  }
  return dest;
}
var init_size = __esm({
  "node_modules/ol/size.js"() {
  }
});

// node_modules/ol/ImageState.js
var ImageState_default;
var init_ImageState = __esm({
  "node_modules/ol/ImageState.js"() {
    ImageState_default = {
      IDLE: 0,
      LOADING: 1,
      LOADED: 2,
      ERROR: 3,
      EMPTY: 4
    };
  }
});

// node_modules/ol/Image.js
function listenImage(image, loadHandler, errorHandler) {
  const img = (
    /** @type {HTMLImageElement} */
    image
  );
  let listening = true;
  let decoding = false;
  let loaded = false;
  const listenerKeys = [
    listenOnce(img, EventType_default.LOAD, function() {
      loaded = true;
      if (!decoding) {
        loadHandler();
      }
    })
  ];
  if (img.src && IMAGE_DECODE) {
    decoding = true;
    img.decode().then(function() {
      if (listening) {
        loadHandler();
      }
    }).catch(function(error2) {
      if (listening) {
        if (loaded) {
          loadHandler();
        } else {
          errorHandler();
        }
      }
    });
  } else {
    listenerKeys.push(listenOnce(img, EventType_default.ERROR, errorHandler));
  }
  return function unlisten() {
    listening = false;
    listenerKeys.forEach(unlistenByKey);
  };
}
function load(image, src) {
  return new Promise((resolve, reject) => {
    function handleLoad() {
      unlisten();
      resolve(image);
    }
    function handleError() {
      unlisten();
      reject(new Error("Image load error"));
    }
    function unlisten() {
      image.removeEventListener("load", handleLoad);
      image.removeEventListener("error", handleError);
    }
    image.addEventListener("load", handleLoad);
    image.addEventListener("error", handleError);
    if (src) {
      image.src = src;
    }
  });
}
function decodeFallback(image, src) {
  if (src) {
    image.src = src;
  }
  return image.src && IMAGE_DECODE ? new Promise(
    (resolve, reject) => image.decode().then(() => resolve(image)).catch(
      (e) => image.complete && image.width ? resolve(image) : reject(e)
    )
  ) : load(image);
}
function decode(image, src) {
  if (src) {
    image.src = src;
  }
  return image.src && IMAGE_DECODE && CREATE_IMAGE_BITMAP ? image.decode().then(() => createImageBitmap(image)).catch((e) => {
    if (image.complete && image.width) {
      return image;
    }
    throw e;
  }) : decodeFallback(image);
}
var ImageWrapper, Image_default;
var init_Image = __esm({
  "node_modules/ol/Image.js"() {
    init_Target();
    init_EventType();
    init_ImageState();
    init_has();
    init_events();
    init_functions();
    ImageWrapper = class extends Target_default {
      /**
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {number|Array<number>|undefined} resolution Resolution. If provided as array, x and y
       * resolution will be assumed.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("./ImageState.js").default|import("./Image.js").Loader} stateOrLoader State.
       */
      constructor(extent, resolution, pixelRatio, stateOrLoader) {
        super();
        this.extent = extent;
        this.pixelRatio_ = pixelRatio;
        this.resolution = resolution;
        this.state = typeof stateOrLoader === "function" ? ImageState_default.IDLE : stateOrLoader;
        this.image_ = null;
        this.loader = typeof stateOrLoader === "function" ? stateOrLoader : null;
      }
      /**
       * @protected
       */
      changed() {
        this.dispatchEvent(EventType_default.CHANGE);
      }
      /**
       * @return {import("./extent.js").Extent} Extent.
       */
      getExtent() {
        return this.extent;
      }
      /**
       * @return {import('./DataTile.js').ImageLike} Image.
       */
      getImage() {
        return this.image_;
      }
      /**
       * @return {number} PixelRatio.
       */
      getPixelRatio() {
        return this.pixelRatio_;
      }
      /**
       * @return {number|Array<number>} Resolution.
       */
      getResolution() {
        return (
          /** @type {number} */
          this.resolution
        );
      }
      /**
       * @return {import("./ImageState.js").default} State.
       */
      getState() {
        return this.state;
      }
      /**
       * Load not yet loaded URI.
       */
      load() {
        if (this.state == ImageState_default.IDLE) {
          if (this.loader) {
            this.state = ImageState_default.LOADING;
            this.changed();
            const resolution = this.getResolution();
            const requestResolution = Array.isArray(resolution) ? resolution[0] : resolution;
            toPromise(
              () => this.loader(this.getExtent(), requestResolution, this.getPixelRatio())
            ).then((image) => {
              if ("image" in image) {
                this.image_ = image.image;
              }
              if ("extent" in image) {
                this.extent = image.extent;
              }
              if ("resolution" in image) {
                this.resolution = image.resolution;
              }
              if ("pixelRatio" in image) {
                this.pixelRatio_ = image.pixelRatio;
              }
              if (image instanceof HTMLImageElement || image instanceof ImageBitmap || image instanceof HTMLCanvasElement || image instanceof HTMLVideoElement) {
                this.image_ = image;
              }
              this.state = ImageState_default.LOADED;
            }).catch((error2) => {
              this.state = ImageState_default.ERROR;
              console.error(error2);
            }).finally(() => this.changed());
          }
        }
      }
      /**
       * @param {import('./DataTile.js').ImageLike} image The image.
       */
      setImage(image) {
        this.image_ = image;
      }
      /**
       * @param {number|Array<number>} resolution Resolution.
       */
      setResolution(resolution) {
        this.resolution = resolution;
      }
    };
    Image_default = ImageWrapper;
  }
});

// node_modules/ol/source/Source.js
function adaptAttributions(attributionLike) {
  if (!attributionLike) {
    return null;
  }
  if (Array.isArray(attributionLike)) {
    return function(frameState) {
      return attributionLike;
    };
  }
  if (typeof attributionLike === "function") {
    return attributionLike;
  }
  return function(frameState) {
    return [attributionLike];
  };
}
var Source, Source_default;
var init_Source = __esm({
  "node_modules/ol/source/Source.js"() {
    init_Object();
    init_proj();
    Source = class extends Object_default {
      /**
       * @param {Options} options Source options.
       */
      constructor(options) {
        super();
        this.projection = get3(options.projection);
        this.attributions_ = adaptAttributions(options.attributions);
        this.attributionsCollapsible_ = options.attributionsCollapsible !== void 0 ? options.attributionsCollapsible : true;
        this.loading = false;
        this.state_ = options.state !== void 0 ? options.state : "ready";
        this.wrapX_ = options.wrapX !== void 0 ? options.wrapX : false;
        this.interpolate_ = !!options.interpolate;
        this.viewResolver = null;
        this.viewRejector = null;
        const self2 = this;
        this.viewPromise_ = new Promise(function(resolve, reject) {
          self2.viewResolver = resolve;
          self2.viewRejector = reject;
        });
      }
      /**
       * Get the attribution function for the source.
       * @return {?Attribution} Attribution function.
       * @api
       */
      getAttributions() {
        return this.attributions_;
      }
      /**
       * @return {boolean} Attributions are collapsible.
       * @api
       */
      getAttributionsCollapsible() {
        return this.attributionsCollapsible_;
      }
      /**
       * Get the projection of the source.
       * @return {import("../proj/Projection.js").default|null} Projection.
       * @api
       */
      getProjection() {
        return this.projection;
      }
      /**
       * @param {import("../proj/Projection").default} [projection] Projection.
       * @return {Array<number>|null} Resolutions.
       */
      getResolutions(projection) {
        return null;
      }
      /**
       * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
       */
      getView() {
        return this.viewPromise_;
      }
      /**
       * Get the state of the source, see {@link import("./Source.js").State} for possible states.
       * @return {import("./Source.js").State} State.
       * @api
       */
      getState() {
        return this.state_;
      }
      /**
       * @return {boolean|undefined} Wrap X.
       */
      getWrapX() {
        return this.wrapX_;
      }
      /**
       * @return {boolean} Use linear interpolation when resampling.
       */
      getInterpolate() {
        return this.interpolate_;
      }
      /**
       * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
       * @api
       */
      refresh() {
        this.changed();
      }
      /**
       * Set the attributions of the source.
       * @param {AttributionLike|undefined} attributions Attributions.
       *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
       *     or `undefined`.
       * @api
       */
      setAttributions(attributions) {
        this.attributions_ = adaptAttributions(attributions);
        this.changed();
      }
      /**
       * Set the state of the source.
       * @param {import("./Source.js").State} state State.
       */
      setState(state) {
        this.state_ = state;
        this.changed();
      }
    };
    Source_default = Source;
  }
});

// node_modules/ol/renderer/Layer.js
var LayerRenderer, Layer_default2;
var init_Layer2 = __esm({
  "node_modules/ol/renderer/Layer.js"() {
    init_EventType();
    init_ImageState();
    init_Observable();
    init_util();
    LayerRenderer = class extends Observable_default {
      /**
       * @param {LayerType} layer Layer.
       */
      constructor(layer) {
        super();
        this.ready = true;
        this.boundHandleImageChange_ = this.handleImageChange_.bind(this);
        this.layer_ = layer;
        this.declutterExecutorGroup = null;
      }
      /**
       * Asynchronous layer level hit detection.
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
       * an array of features.
       */
      getFeatures(pixel) {
        return abstract();
      }
      /**
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
       */
      getData(pixel) {
        return null;
      }
      /**
       * Determine whether render should be called.
       * @abstract
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       */
      prepareFrame(frameState) {
        return abstract();
      }
      /**
       * Render the layer.
       * @abstract
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement|null} target Target that may be used to render content to.
       * @return {HTMLElement|null} The rendered element.
       */
      renderFrame(frameState, target) {
        return abstract();
      }
      /**
       * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
       * @param {number} zoom Zoom level.
       * @param {import("../Tile.js").default} tile Tile.
       * @return {boolean|void} If `false`, the tile will not be considered loaded.
       */
      loadedTileCallback(tiles, zoom, tile2) {
        if (!tiles[zoom]) {
          tiles[zoom] = {};
        }
        tiles[zoom][tile2.tileCoord.toString()] = tile2;
        return void 0;
      }
      /**
       * Create a function that adds loaded tiles to the tile lookup.
       * @param {import("../source/Tile.js").default} source Tile source.
       * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
       * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
       * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
       *     called with a zoom level and a tile range to add loaded tiles to the lookup.
       * @protected
       */
      createLoadedTileFinder(source, projection, tiles) {
        return (
          /**
           * @param {number} zoom Zoom level.
           * @param {import("../TileRange.js").default} tileRange Tile range.
           * @return {boolean} The tile range is fully loaded.
           */
          (zoom, tileRange) => {
            const callback = this.loadedTileCallback.bind(this, tiles, zoom);
            return source.forEachLoadedTile(projection, zoom, tileRange, callback);
          }
        );
      }
      /**
       * @abstract
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("../Map.js").FrameState} frameState Frame state.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
       * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
       * @return {T|undefined} Callback result.
       * @template T
       */
      forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
        return void 0;
      }
      /**
       * @return {LayerType} Layer.
       */
      getLayer() {
        return this.layer_;
      }
      /**
       * Perform action necessary to get the layer rendered after new fonts have loaded
       * @abstract
       */
      handleFontsChanged() {
      }
      /**
       * Handle changes in image state.
       * @param {import("../events/Event.js").default} event Image change event.
       * @private
       */
      handleImageChange_(event) {
        const image = (
          /** @type {import("../Image.js").default} */
          event.target
        );
        if (image.getState() === ImageState_default.LOADED || image.getState() === ImageState_default.ERROR) {
          this.renderIfReadyAndVisible();
        }
      }
      /**
       * Load the image if not already loaded, and register the image change
       * listener if needed.
       * @param {import("../Image.js").default} image Image.
       * @return {boolean} `true` if the image is already loaded, `false` otherwise.
       * @protected
       */
      loadImage(image) {
        let imageState = image.getState();
        if (imageState != ImageState_default.LOADED && imageState != ImageState_default.ERROR) {
          image.addEventListener(EventType_default.CHANGE, this.boundHandleImageChange_);
        }
        if (imageState == ImageState_default.IDLE) {
          image.load();
          imageState = image.getState();
        }
        return imageState == ImageState_default.LOADED;
      }
      /**
       * @protected
       */
      renderIfReadyAndVisible() {
        const layer = this.getLayer();
        if (layer && layer.getVisible() && layer.getSourceState() === "ready") {
          layer.changed();
        }
      }
      /**
       * Clean up.
       */
      disposeInternal() {
        delete this.layer_;
        super.disposeInternal();
      }
    };
    Layer_default2 = LayerRenderer;
  }
});

// node_modules/ol/renderer/canvas/Layer.js
function createPixelContext() {
  pixelContext = createCanvasContext2D(1, 1, void 0, {
    willReadFrequently: true
  });
}
var canvasPool2, pixelContext, CanvasLayerRenderer, Layer_default3;
var init_Layer3 = __esm({
  "node_modules/ol/renderer/canvas/Layer.js"() {
    init_Layer2();
    init_Event2();
    init_EventType2();
    init_transform();
    init_color();
    init_dom();
    init_array();
    init_extent();
    canvasPool2 = [];
    pixelContext = null;
    CanvasLayerRenderer = class extends Layer_default2 {
      /**
       * @param {LayerType} layer Layer.
       */
      constructor(layer) {
        super(layer);
        this.container = null;
        this.renderedResolution;
        this.tempTransform = create();
        this.pixelTransform = create();
        this.inversePixelTransform = create();
        this.context = null;
        this.containerReused = false;
        this.pixelContext_ = null;
        this.frameState = null;
      }
      /**
       * @param {import('../../DataTile.js').ImageLike} image Image.
       * @param {number} col The column index.
       * @param {number} row The row index.
       * @return {Uint8ClampedArray|null} The image data.
       */
      getImageData(image, col, row) {
        if (!pixelContext) {
          createPixelContext();
        }
        pixelContext.clearRect(0, 0, 1, 1);
        let data;
        try {
          pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
          data = pixelContext.getImageData(0, 0, 1, 1).data;
        } catch (err) {
          pixelContext = null;
          return null;
        }
        return data;
      }
      /**
       * @param {import('../../Map.js').FrameState} frameState Frame state.
       * @return {string} Background color.
       */
      getBackground(frameState) {
        const layer = this.getLayer();
        let background = layer.getBackground();
        if (typeof background === "function") {
          background = background(frameState.viewState.resolution);
        }
        return background || void 0;
      }
      /**
       * Get a rendering container from an existing target, if compatible.
       * @param {HTMLElement} target Potential render target.
       * @param {string} transform CSS Transform.
       * @param {string} [backgroundColor] Background color.
       */
      useContainer(target, transform2, backgroundColor) {
        const layerClassName = this.getLayer().getClassName();
        let container, context;
        if (target && target.className === layerClassName && (!backgroundColor || target && target.style.backgroundColor && equals(
          asArray(target.style.backgroundColor),
          asArray(backgroundColor)
        ))) {
          const canvas = target.firstElementChild;
          if (canvas instanceof HTMLCanvasElement) {
            context = canvas.getContext("2d");
          }
        }
        if (context && context.canvas.style.transform === transform2) {
          this.container = target;
          this.context = context;
          this.containerReused = true;
        } else if (this.containerReused) {
          this.container = null;
          this.context = null;
          this.containerReused = false;
        } else if (this.container) {
          this.container.style.backgroundColor = null;
        }
        if (!this.container) {
          container = document.createElement("div");
          container.className = layerClassName;
          let style = container.style;
          style.position = "absolute";
          style.width = "100%";
          style.height = "100%";
          context = createCanvasContext2D();
          const canvas = context.canvas;
          container.appendChild(canvas);
          style = canvas.style;
          style.position = "absolute";
          style.left = "0";
          style.transformOrigin = "top left";
          this.container = container;
          this.context = context;
        }
        if (!this.containerReused && backgroundColor && !this.container.style.backgroundColor) {
          this.container.style.backgroundColor = backgroundColor;
        }
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {import("../../extent.js").Extent} extent Clip extent.
       * @protected
       */
      clipUnrotated(context, frameState, extent) {
        const topLeft = getTopLeft(extent);
        const topRight = getTopRight(extent);
        const bottomRight = getBottomRight(extent);
        const bottomLeft = getBottomLeft(extent);
        apply(frameState.coordinateToPixelTransform, topLeft);
        apply(frameState.coordinateToPixelTransform, topRight);
        apply(frameState.coordinateToPixelTransform, bottomRight);
        apply(frameState.coordinateToPixelTransform, bottomLeft);
        const inverted = this.inversePixelTransform;
        apply(inverted, topLeft);
        apply(inverted, topRight);
        apply(inverted, bottomRight);
        apply(inverted, bottomLeft);
        context.save();
        context.beginPath();
        context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
        context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
        context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
        context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
        context.clip();
      }
      /**
       * @param {import("../../render/EventType.js").default} type Event type.
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @private
       */
      dispatchRenderEvent_(type, context, frameState) {
        const layer = this.getLayer();
        if (layer.hasListener(type)) {
          const event = new Event_default2(
            type,
            this.inversePixelTransform,
            frameState,
            context
          );
          layer.dispatchEvent(event);
        }
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @protected
       */
      preRender(context, frameState) {
        this.frameState = frameState;
        this.dispatchRenderEvent_(EventType_default2.PRERENDER, context, frameState);
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @protected
       */
      postRender(context, frameState) {
        this.dispatchRenderEvent_(EventType_default2.POSTRENDER, context, frameState);
      }
      /**
       * Creates a transform for rendering to an element that will be rotated after rendering.
       * @param {import("../../coordinate.js").Coordinate} center Center.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {number} pixelRatio Pixel ratio.
       * @param {number} width Width of the rendered element (in pixels).
       * @param {number} height Height of the rendered element (in pixels).
       * @param {number} offsetX Offset on the x-axis in view coordinates.
       * @protected
       * @return {!import("../../transform.js").Transform} Transform.
       */
      getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX) {
        const dx1 = width / 2;
        const dy1 = height / 2;
        const sx = pixelRatio / resolution;
        const sy = -sx;
        const dx2 = -center[0] + offsetX;
        const dy2 = -center[1];
        return compose(
          this.tempTransform,
          dx1,
          dy1,
          sx,
          sy,
          -rotation,
          dx2,
          dy2
        );
      }
      /**
       * Clean up.
       */
      disposeInternal() {
        delete this.frameState;
        super.disposeInternal();
      }
    };
    Layer_default3 = CanvasLayerRenderer;
  }
});

// node_modules/ol/Feature.js
var Feature_exports = {};
__export(Feature_exports, {
  createStyleFunction: () => createStyleFunction,
  default: () => Feature_default
});
function createStyleFunction(obj) {
  if (typeof obj === "function") {
    return obj;
  }
  let styles;
  if (Array.isArray(obj)) {
    styles = obj;
  } else {
    assert(
      typeof /** @type {?} */
      obj.getZIndex === "function",
      "Expected an `ol/style/Style` or an array of `ol/style/Style.js`"
    );
    const style = (
      /** @type {import("./style/Style.js").default} */
      obj
    );
    styles = [style];
  }
  return function() {
    return styles;
  };
}
var Feature, Feature_default;
var init_Feature = __esm({
  "node_modules/ol/Feature.js"() {
    init_Object();
    init_EventType();
    init_asserts();
    init_events();
    Feature = class _Feature extends Object_default {
      /**
       * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
       *     You may pass a Geometry object directly, or an object literal containing
       *     properties. If you pass an object literal, you may include a Geometry
       *     associated with a `geometry` key.
       */
      constructor(geometryOrProperties) {
        super();
        this.on;
        this.once;
        this.un;
        this.id_ = void 0;
        this.geometryName_ = "geometry";
        this.style_ = null;
        this.styleFunction_ = void 0;
        this.geometryChangeKey_ = null;
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
        if (geometryOrProperties) {
          if (typeof /** @type {?} */
          geometryOrProperties.getSimplifiedGeometry === "function") {
            const geometry = (
              /** @type {Geometry} */
              geometryOrProperties
            );
            this.setGeometry(geometry);
          } else {
            const properties = geometryOrProperties;
            this.setProperties(properties);
          }
        }
      }
      /**
       * Clone this feature. If the original feature has a geometry it
       * is also cloned. The feature id is not set in the clone.
       * @return {Feature<Geometry>} The clone.
       * @api
       */
      clone() {
        const clone2 = (
          /** @type {Feature<Geometry>} */
          new _Feature(this.hasProperties() ? this.getProperties() : null)
        );
        clone2.setGeometryName(this.getGeometryName());
        const geometry = this.getGeometry();
        if (geometry) {
          clone2.setGeometry(
            /** @type {Geometry} */
            geometry.clone()
          );
        }
        const style = this.getStyle();
        if (style) {
          clone2.setStyle(style);
        }
        return clone2;
      }
      /**
       * Get the feature's default geometry.  A feature may have any number of named
       * geometries.  The "default" geometry (the one that is rendered by default) is
       * set when calling {@link module:ol/Feature~Feature#setGeometry}.
       * @return {Geometry|undefined} The default geometry for the feature.
       * @api
       * @observable
       */
      getGeometry() {
        return (
          /** @type {Geometry|undefined} */
          this.get(this.geometryName_)
        );
      }
      /**
       * Get the feature identifier.  This is a stable identifier for the feature and
       * is either set when reading data from a remote source or set explicitly by
       * calling {@link module:ol/Feature~Feature#setId}.
       * @return {number|string|undefined} Id.
       * @api
       */
      getId() {
        return this.id_;
      }
      /**
       * Get the name of the feature's default geometry.  By default, the default
       * geometry is named `geometry`.
       * @return {string} Get the property name associated with the default geometry
       *     for this feature.
       * @api
       */
      getGeometryName() {
        return this.geometryName_;
      }
      /**
       * Get the feature's style. Will return what was provided to the
       * {@link module:ol/Feature~Feature#setStyle} method.
       * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
       * @api
       */
      getStyle() {
        return this.style_;
      }
      /**
       * Get the feature's style function.
       * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
       * representing the current style of this feature.
       * @api
       */
      getStyleFunction() {
        return this.styleFunction_;
      }
      /**
       * @private
       */
      handleGeometryChange_() {
        this.changed();
      }
      /**
       * @private
       */
      handleGeometryChanged_() {
        if (this.geometryChangeKey_) {
          unlistenByKey(this.geometryChangeKey_);
          this.geometryChangeKey_ = null;
        }
        const geometry = this.getGeometry();
        if (geometry) {
          this.geometryChangeKey_ = listen(
            geometry,
            EventType_default.CHANGE,
            this.handleGeometryChange_,
            this
          );
        }
        this.changed();
      }
      /**
       * Set the default geometry for the feature.  This will update the property
       * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
       * @param {Geometry|undefined} geometry The new geometry.
       * @api
       * @observable
       */
      setGeometry(geometry) {
        this.set(this.geometryName_, geometry);
      }
      /**
       * Set the style for the feature to override the layer style.  This can be a
       * single style object, an array of styles, or a function that takes a
       * resolution and returns an array of styles. To unset the feature style, call
       * `setStyle()` without arguments or a falsey value.
       * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
       * @api
       * @fires module:ol/events/Event~BaseEvent#event:change
       */
      setStyle(style) {
        this.style_ = style;
        this.styleFunction_ = !style ? void 0 : createStyleFunction(style);
        this.changed();
      }
      /**
       * Set the feature id.  The feature id is considered stable and may be used when
       * requesting features or comparing identifiers returned from a remote source.
       * The feature id can be used with the
       * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
       * @param {number|string|undefined} id The feature id.
       * @api
       * @fires module:ol/events/Event~BaseEvent#event:change
       */
      setId(id) {
        this.id_ = id;
        this.changed();
      }
      /**
       * Set the property name to be used when getting the feature's default geometry.
       * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
       * this name will be returned.
       * @param {string} name The property name of the default geometry.
       * @api
       */
      setGeometryName(name) {
        this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.geometryName_ = name;
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
        this.handleGeometryChanged_();
      }
    };
    Feature_default = Feature;
  }
});

// node_modules/ol/style/Fill.js
var Fill, Fill_default;
var init_Fill = __esm({
  "node_modules/ol/style/Fill.js"() {
    Fill = class _Fill {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options) {
        options = options || {};
        this.color_ = options.color !== void 0 ? options.color : null;
      }
      /**
       * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
       * @return {Fill} The cloned style.
       * @api
       */
      clone() {
        const color = this.getColor();
        return new _Fill({
          color: Array.isArray(color) ? color.slice() : color || void 0
        });
      }
      /**
       * Get the fill color.
       * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|null} Color.
       * @api
       */
      getColor() {
        return this.color_;
      }
      /**
       * Set the color.
       *
       * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|null} color Color.
       * @api
       */
      setColor(color) {
        this.color_ = color;
      }
    };
    Fill_default = Fill;
  }
});

// node_modules/ol/geom/flat/interpolate.js
function interpolatePoint(flatCoordinates, offset2, end, stride, fraction, dest, dimension) {
  let o, t;
  const n = (end - offset2) / stride;
  if (n === 1) {
    o = offset2;
  } else if (n === 2) {
    o = offset2;
    t = fraction;
  } else if (n !== 0) {
    let x1 = flatCoordinates[offset2];
    let y1 = flatCoordinates[offset2 + 1];
    let length = 0;
    const cumulativeLengths = [0];
    for (let i = offset2 + stride; i < end; i += stride) {
      const x2 = flatCoordinates[i];
      const y2 = flatCoordinates[i + 1];
      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      cumulativeLengths.push(length);
      x1 = x2;
      y1 = y2;
    }
    const target = fraction * length;
    const index = binarySearch(cumulativeLengths, target);
    if (index < 0) {
      t = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
      o = offset2 + (-index - 2) * stride;
    } else {
      o = offset2 + index * stride;
    }
  }
  dimension = dimension > 1 ? dimension : 2;
  dest = dest ? dest : new Array(dimension);
  for (let i = 0; i < dimension; ++i) {
    dest[i] = o === void 0 ? NaN : t === void 0 ? flatCoordinates[o + i] : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);
  }
  return dest;
}
function lineStringCoordinateAtM(flatCoordinates, offset2, end, stride, m, extrapolate) {
  if (end == offset2) {
    return null;
  }
  let coordinate;
  if (m < flatCoordinates[offset2 + stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(offset2, offset2 + stride);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  if (flatCoordinates[end - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(end - stride, end);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  if (m == flatCoordinates[offset2 + stride - 1]) {
    return flatCoordinates.slice(offset2, offset2 + stride);
  }
  let lo = offset2 / stride;
  let hi = end / stride;
  while (lo < hi) {
    const mid = lo + hi >> 1;
    if (m < flatCoordinates[(mid + 1) * stride - 1]) {
      hi = mid;
    } else {
      lo = mid + 1;
    }
  }
  const m0 = flatCoordinates[lo * stride - 1];
  if (m == m0) {
    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
  }
  const m1 = flatCoordinates[(lo + 1) * stride - 1];
  const t = (m - m0) / (m1 - m0);
  coordinate = [];
  for (let i = 0; i < stride - 1; ++i) {
    coordinate.push(
      lerp(
        flatCoordinates[(lo - 1) * stride + i],
        flatCoordinates[lo * stride + i],
        t
      )
    );
  }
  coordinate.push(m);
  return coordinate;
}
function lineStringsCoordinateAtM(flatCoordinates, offset2, ends, stride, m, extrapolate, interpolate) {
  if (interpolate) {
    return lineStringCoordinateAtM(
      flatCoordinates,
      offset2,
      ends[ends.length - 1],
      stride,
      m,
      extrapolate
    );
  }
  let coordinate;
  if (m < flatCoordinates[stride - 1]) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(0, stride);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  if (flatCoordinates[flatCoordinates.length - 1] < m) {
    if (extrapolate) {
      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
      coordinate[stride - 1] = m;
      return coordinate;
    }
    return null;
  }
  for (let i = 0, ii = ends.length; i < ii; ++i) {
    const end = ends[i];
    if (offset2 == end) {
      continue;
    }
    if (m < flatCoordinates[offset2 + stride - 1]) {
      return null;
    }
    if (m <= flatCoordinates[end - 1]) {
      return lineStringCoordinateAtM(
        flatCoordinates,
        offset2,
        end,
        stride,
        m,
        false
      );
    }
    offset2 = end;
  }
  return null;
}
var init_interpolate = __esm({
  "node_modules/ol/geom/flat/interpolate.js"() {
    init_array();
    init_math();
  }
});

// node_modules/ol/geom/flat/length.js
function lineStringLength(flatCoordinates, offset2, end, stride) {
  let x1 = flatCoordinates[offset2];
  let y1 = flatCoordinates[offset2 + 1];
  let length = 0;
  for (let i = offset2 + stride; i < end; i += stride) {
    const x2 = flatCoordinates[i];
    const y2 = flatCoordinates[i + 1];
    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    x1 = x2;
    y1 = y2;
  }
  return length;
}
function linearRingLength(flatCoordinates, offset2, end, stride) {
  let perimeter = lineStringLength(flatCoordinates, offset2, end, stride);
  const dx = flatCoordinates[end - stride] - flatCoordinates[offset2];
  const dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset2 + 1];
  perimeter += Math.sqrt(dx * dx + dy * dy);
  return perimeter;
}
var init_length = __esm({
  "node_modules/ol/geom/flat/length.js"() {
  }
});

// node_modules/ol/geom/LineString.js
var LineString, LineString_default;
var init_LineString = __esm({
  "node_modules/ol/geom/LineString.js"() {
    init_SimpleGeometry();
    init_closest();
    init_extent();
    init_deflate();
    init_simplify();
    init_array();
    init_segments();
    init_inflate();
    init_interpolate();
    init_intersectsextent();
    init_length();
    LineString = class _LineString extends SimpleGeometry_default {
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `layout` are also accepted.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(coordinates2, layout) {
        super();
        this.flatMidpoint_ = null;
        this.flatMidpointRevision_ = -1;
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        if (layout !== void 0 && !Array.isArray(coordinates2[0])) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
        } else {
          this.setCoordinates(
            /** @type {Array<import("../coordinate.js").Coordinate>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Append the passed coordinate to the coordinates of the linestring.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @api
       */
      appendCoordinate(coordinate) {
        extend(this.flatCoordinates, coordinate);
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!LineString} Clone.
       * @api
       */
      clone() {
        const lineString = new _LineString(
          this.flatCoordinates.slice(),
          this.layout
        );
        lineString.applyProperties(this);
        return lineString;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            maxSquaredDelta(
              this.flatCoordinates,
              0,
              this.flatCoordinates.length,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestPoint(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          this.maxDelta_,
          false,
          x,
          y,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * Iterate over each segment, calling the provided callback.
       * If the callback returns a truthy value the function returns that
       * value immediately. Otherwise the function returns `false`.
       *
       * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
       *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
       * @return {T|boolean} Value.
       * @template T,S
       * @api
       */
      forEachSegment(callback) {
        return forEach(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          callback
        );
      }
      /**
       * Returns the coordinate at `m` using linear interpolation, or `null` if no
       * such coordinate exists.
       *
       * `extrapolate` controls extrapolation beyond the range of Ms in the
       * MultiLineString. If `extrapolate` is `true` then Ms less than the first
       * M will return the first coordinate and Ms greater than the last M will
       * return the last coordinate.
       *
       * @param {number} m M.
       * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
       * @return {import("../coordinate.js").Coordinate|null} Coordinate.
       * @api
       */
      getCoordinateAtM(m, extrapolate) {
        if (this.layout != "XYM" && this.layout != "XYZM") {
          return null;
        }
        extrapolate = extrapolate !== void 0 ? extrapolate : false;
        return lineStringCoordinateAtM(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          m,
          extrapolate
        );
      }
      /**
       * Return the coordinates of the linestring.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       */
      getCoordinates() {
        return inflateCoordinates(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * Return the coordinate at the provided fraction along the linestring.
       * The `fraction` is a number between 0 and 1, where 0 is the start of the
       * linestring and 1 is the end.
       * @param {number} fraction Fraction.
       * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
       *     be modified. If not provided, a new coordinate will be returned.
       * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
       * @api
       */
      getCoordinateAt(fraction, dest) {
        return interpolatePoint(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          fraction,
          dest,
          this.stride
        );
      }
      /**
       * Return the length of the linestring on projected plane.
       * @return {number} Length (on projected plane).
       * @api
       */
      getLength() {
        return lineStringLength(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * @return {Array<number>} Flat midpoint.
       */
      getFlatMidpoint() {
        if (this.flatMidpointRevision_ != this.getRevision()) {
          this.flatMidpoint_ = this.getCoordinateAt(
            0.5,
            this.flatMidpoint_ ?? void 0
          );
          this.flatMidpointRevision_ = this.getRevision();
        }
        return (
          /** @type {Array<number>} */
          this.flatMidpoint_
        );
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {LineString} Simplified LineString.
       * @protected
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        simplifiedFlatCoordinates.length = douglasPeucker(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          squaredTolerance,
          simplifiedFlatCoordinates,
          0
        );
        return new _LineString(simplifiedFlatCoordinates, "XY");
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */
      getType() {
        return "LineString";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      intersectsExtent(extent) {
        return intersectsLineString(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride,
          extent
        );
      }
      /**
       * Set the coordinates of the linestring.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 1);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinates(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride
        );
        this.changed();
      }
    };
    LineString_default = LineString;
  }
});

// node_modules/ol/style/Stroke.js
var Stroke, Stroke_default;
var init_Stroke = __esm({
  "node_modules/ol/style/Stroke.js"() {
    Stroke = class _Stroke {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options) {
        options = options || {};
        this.color_ = options.color !== void 0 ? options.color : null;
        this.lineCap_ = options.lineCap;
        this.lineDash_ = options.lineDash !== void 0 ? options.lineDash : null;
        this.lineDashOffset_ = options.lineDashOffset;
        this.lineJoin_ = options.lineJoin;
        this.miterLimit_ = options.miterLimit;
        this.width_ = options.width;
      }
      /**
       * Clones the style.
       * @return {Stroke} The cloned style.
       * @api
       */
      clone() {
        const color = this.getColor();
        return new _Stroke({
          color: Array.isArray(color) ? color.slice() : color || void 0,
          lineCap: this.getLineCap(),
          lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
          lineDashOffset: this.getLineDashOffset(),
          lineJoin: this.getLineJoin(),
          miterLimit: this.getMiterLimit(),
          width: this.getWidth()
        });
      }
      /**
       * Get the stroke color.
       * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
       * @api
       */
      getColor() {
        return this.color_;
      }
      /**
       * Get the line cap type for the stroke.
       * @return {CanvasLineCap|undefined} Line cap.
       * @api
       */
      getLineCap() {
        return this.lineCap_;
      }
      /**
       * Get the line dash style for the stroke.
       * @return {Array<number>|null} Line dash.
       * @api
       */
      getLineDash() {
        return this.lineDash_;
      }
      /**
       * Get the line dash offset for the stroke.
       * @return {number|undefined} Line dash offset.
       * @api
       */
      getLineDashOffset() {
        return this.lineDashOffset_;
      }
      /**
       * Get the line join type for the stroke.
       * @return {CanvasLineJoin|undefined} Line join.
       * @api
       */
      getLineJoin() {
        return this.lineJoin_;
      }
      /**
       * Get the miter limit for the stroke.
       * @return {number|undefined} Miter limit.
       * @api
       */
      getMiterLimit() {
        return this.miterLimit_;
      }
      /**
       * Get the stroke width.
       * @return {number|undefined} Width.
       * @api
       */
      getWidth() {
        return this.width_;
      }
      /**
       * Set the color.
       *
       * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
       * @api
       */
      setColor(color) {
        this.color_ = color;
      }
      /**
       * Set the line cap.
       *
       * @param {CanvasLineCap|undefined} lineCap Line cap.
       * @api
       */
      setLineCap(lineCap) {
        this.lineCap_ = lineCap;
      }
      /**
       * Set the line dash.
       *
       * @param {Array<number>|null} lineDash Line dash.
       * @api
       */
      setLineDash(lineDash) {
        this.lineDash_ = lineDash;
      }
      /**
       * Set the line dash offset.
       *
       * @param {number|undefined} lineDashOffset Line dash offset.
       * @api
       */
      setLineDashOffset(lineDashOffset) {
        this.lineDashOffset_ = lineDashOffset;
      }
      /**
       * Set the line join.
       *
       * @param {CanvasLineJoin|undefined} lineJoin Line join.
       * @api
       */
      setLineJoin(lineJoin) {
        this.lineJoin_ = lineJoin;
      }
      /**
       * Set the miter limit.
       *
       * @param {number|undefined} miterLimit Miter limit.
       * @api
       */
      setMiterLimit(miterLimit) {
        this.miterLimit_ = miterLimit;
      }
      /**
       * Set the width.
       *
       * @param {number|undefined} width Width.
       * @api
       */
      setWidth(width) {
        this.width_ = width;
      }
    };
    Stroke_default = Stroke;
  }
});

// node_modules/ol/style/Image.js
var ImageStyle, Image_default2;
var init_Image2 = __esm({
  "node_modules/ol/style/Image.js"() {
    init_util();
    init_size();
    ImageStyle = class _ImageStyle {
      /**
       * @param {Options} options Options.
       */
      constructor(options) {
        this.opacity_ = options.opacity;
        this.rotateWithView_ = options.rotateWithView;
        this.rotation_ = options.rotation;
        this.scale_ = options.scale;
        this.scaleArray_ = toSize(options.scale);
        this.displacement_ = options.displacement;
        this.declutterMode_ = options.declutterMode;
      }
      /**
       * Clones the style.
       * @return {ImageStyle} The cloned style.
       * @api
       */
      clone() {
        const scale5 = this.getScale();
        return new _ImageStyle({
          opacity: this.getOpacity(),
          scale: Array.isArray(scale5) ? scale5.slice() : scale5,
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode()
        });
      }
      /**
       * Get the symbolizer opacity.
       * @return {number} Opacity.
       * @api
       */
      getOpacity() {
        return this.opacity_;
      }
      /**
       * Determine whether the symbolizer rotates with the map.
       * @return {boolean} Rotate with map.
       * @api
       */
      getRotateWithView() {
        return this.rotateWithView_;
      }
      /**
       * Get the symoblizer rotation.
       * @return {number} Rotation.
       * @api
       */
      getRotation() {
        return this.rotation_;
      }
      /**
       * Get the symbolizer scale.
       * @return {number|import("../size.js").Size} Scale.
       * @api
       */
      getScale() {
        return this.scale_;
      }
      /**
       * Get the symbolizer scale array.
       * @return {import("../size.js").Size} Scale array.
       */
      getScaleArray() {
        return this.scaleArray_;
      }
      /**
       * Get the displacement of the shape
       * @return {Array<number>} Shape's center displacement
       * @api
       */
      getDisplacement() {
        return this.displacement_;
      }
      /**
       * Get the declutter mode of the shape
       * @return {"declutter"|"obstacle"|"none"|undefined} Shape's declutter mode
       * @api
       */
      getDeclutterMode() {
        return this.declutterMode_;
      }
      /**
       * Get the anchor point in pixels. The anchor determines the center point for the
       * symbolizer.
       * @abstract
       * @return {Array<number>} Anchor.
       */
      getAnchor() {
        return abstract();
      }
      /**
       * Get the image element for the symbolizer.
       * @abstract
       * @param {number} pixelRatio Pixel ratio.
       * @return {import('../DataTile.js').ImageLike} Image element.
       */
      getImage(pixelRatio) {
        return abstract();
      }
      /**
       * @abstract
       * @return {import('../DataTile.js').ImageLike} Image element.
       */
      getHitDetectionImage() {
        return abstract();
      }
      /**
       * Get the image pixel ratio.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Pixel ratio.
       */
      getPixelRatio(pixelRatio) {
        return 1;
      }
      /**
       * @abstract
       * @return {import("../ImageState.js").default} Image state.
       */
      getImageState() {
        return abstract();
      }
      /**
       * @abstract
       * @return {import("../size.js").Size} Image size.
       */
      getImageSize() {
        return abstract();
      }
      /**
       * Get the origin of the symbolizer.
       * @abstract
       * @return {Array<number>} Origin.
       */
      getOrigin() {
        return abstract();
      }
      /**
       * Get the size of the symbolizer (in pixels).
       * @abstract
       * @return {import("../size.js").Size} Size.
       */
      getSize() {
        return abstract();
      }
      /**
       * Set the displacement.
       *
       * @param {Array<number>} displacement Displacement.
       * @api
       */
      setDisplacement(displacement) {
        this.displacement_ = displacement;
      }
      /**
       * Set the opacity.
       *
       * @param {number} opacity Opacity.
       * @api
       */
      setOpacity(opacity) {
        this.opacity_ = opacity;
      }
      /**
       * Set whether to rotate the style with the view.
       *
       * @param {boolean} rotateWithView Rotate with map.
       * @api
       */
      setRotateWithView(rotateWithView) {
        this.rotateWithView_ = rotateWithView;
      }
      /**
       * Set the rotation.
       *
       * @param {number} rotation Rotation.
       * @api
       */
      setRotation(rotation) {
        this.rotation_ = rotation;
      }
      /**
       * Set the scale.
       *
       * @param {number|import("../size.js").Size} scale Scale.
       * @api
       */
      setScale(scale5) {
        this.scale_ = scale5;
        this.scaleArray_ = toSize(scale5);
      }
      /**
       * @abstract
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      listenImageChange(listener) {
        abstract();
      }
      /**
       * Load not yet loaded URI.
       * @abstract
       */
      load() {
        abstract();
      }
      /**
       * @abstract
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      unlistenImageChange(listener) {
        abstract();
      }
    };
    Image_default2 = ImageStyle;
  }
});

// node_modules/ol/colorlike.js
function asColorLike(color) {
  if (Array.isArray(color)) {
    return toString2(color);
  }
  return color;
}
var init_colorlike = __esm({
  "node_modules/ol/colorlike.js"() {
    init_color();
  }
});

// node_modules/ol/style/RegularShape.js
var RegularShape, RegularShape_default;
var init_RegularShape = __esm({
  "node_modules/ol/style/RegularShape.js"() {
    init_ImageState();
    init_Image2();
    init_color();
    init_colorlike();
    init_dom();
    init_canvas();
    RegularShape = class _RegularShape extends Image_default2 {
      /**
       * @param {Options} options Options.
       */
      constructor(options) {
        const rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
        super({
          opacity: 1,
          rotateWithView,
          rotation: options.rotation !== void 0 ? options.rotation : 0,
          scale: options.scale !== void 0 ? options.scale : 1,
          displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
          declutterMode: options.declutterMode
        });
        this.canvases_;
        this.hitDetectionCanvas_ = null;
        this.fill_ = options.fill !== void 0 ? options.fill : null;
        this.origin_ = [0, 0];
        this.points_ = options.points;
        this.radius_ = options.radius !== void 0 ? options.radius : options.radius1;
        this.radius2_ = options.radius2;
        this.angle_ = options.angle !== void 0 ? options.angle : 0;
        this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
        this.size_;
        this.renderOptions_;
        this.render();
      }
      /**
       * Clones the style.
       * @return {RegularShape} The cloned style.
       * @api
       */
      clone() {
        const scale5 = this.getScale();
        const style = new _RegularShape({
          fill: this.getFill() ? this.getFill().clone() : void 0,
          points: this.getPoints(),
          radius: this.getRadius(),
          radius2: this.getRadius2(),
          angle: this.getAngle(),
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          scale: Array.isArray(scale5) ? scale5.slice() : scale5,
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode()
        });
        style.setOpacity(this.getOpacity());
        return style;
      }
      /**
       * Get the anchor point in pixels. The anchor determines the center point for the
       * symbolizer.
       * @return {Array<number>} Anchor.
       * @api
       */
      getAnchor() {
        const size = this.size_;
        const displacement = this.getDisplacement();
        const scale5 = this.getScaleArray();
        return [
          size[0] / 2 - displacement[0] / scale5[0],
          size[1] / 2 + displacement[1] / scale5[1]
        ];
      }
      /**
       * Get the angle used in generating the shape.
       * @return {number} Shape's rotation in radians.
       * @api
       */
      getAngle() {
        return this.angle_;
      }
      /**
       * Get the fill style for the shape.
       * @return {import("./Fill.js").default|null} Fill style.
       * @api
       */
      getFill() {
        return this.fill_;
      }
      /**
       * Set the fill style.
       * @param {import("./Fill.js").default|null} fill Fill style.
       * @api
       */
      setFill(fill) {
        this.fill_ = fill;
        this.render();
      }
      /**
       * @return {HTMLCanvasElement} Image element.
       */
      getHitDetectionImage() {
        if (!this.hitDetectionCanvas_) {
          this.hitDetectionCanvas_ = this.createHitDetectionCanvas_(
            this.renderOptions_
          );
        }
        return this.hitDetectionCanvas_;
      }
      /**
       * Get the image icon.
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLCanvasElement} Image or Canvas element.
       * @api
       */
      getImage(pixelRatio) {
        let image = this.canvases_[pixelRatio];
        if (!image) {
          const renderOptions = this.renderOptions_;
          const context = createCanvasContext2D(
            renderOptions.size * pixelRatio,
            renderOptions.size * pixelRatio
          );
          this.draw_(renderOptions, context, pixelRatio);
          image = context.canvas;
          this.canvases_[pixelRatio] = image;
        }
        return image;
      }
      /**
       * Get the image pixel ratio.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Pixel ratio.
       */
      getPixelRatio(pixelRatio) {
        return pixelRatio;
      }
      /**
       * @return {import("../size.js").Size} Image size.
       */
      getImageSize() {
        return this.size_;
      }
      /**
       * @return {import("../ImageState.js").default} Image state.
       */
      getImageState() {
        return ImageState_default.LOADED;
      }
      /**
       * Get the origin of the symbolizer.
       * @return {Array<number>} Origin.
       * @api
       */
      getOrigin() {
        return this.origin_;
      }
      /**
       * Get the number of points for generating the shape.
       * @return {number} Number of points for stars and regular polygons.
       * @api
       */
      getPoints() {
        return this.points_;
      }
      /**
       * Get the (primary) radius for the shape.
       * @return {number} Radius.
       * @api
       */
      getRadius() {
        return this.radius_;
      }
      /**
       * Get the secondary radius for the shape.
       * @return {number|undefined} Radius2.
       * @api
       */
      getRadius2() {
        return this.radius2_;
      }
      /**
       * Get the size of the symbolizer (in pixels).
       * @return {import("../size.js").Size} Size.
       * @api
       */
      getSize() {
        return this.size_;
      }
      /**
       * Get the stroke style for the shape.
       * @return {import("./Stroke.js").default|null} Stroke style.
       * @api
       */
      getStroke() {
        return this.stroke_;
      }
      /**
       * Set the stroke style.
       * @param {import("./Stroke.js").default|null} stroke Stroke style.
       * @api
       */
      setStroke(stroke) {
        this.stroke_ = stroke;
        this.render();
      }
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      listenImageChange(listener) {
      }
      /**
       * Load not yet loaded URI.
       */
      load() {
      }
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      unlistenImageChange(listener) {
      }
      /**
       * Calculate additional canvas size needed for the miter.
       * @param {string} lineJoin Line join
       * @param {number} strokeWidth Stroke width
       * @param {number} miterLimit Miter limit
       * @return {number} Additional canvas size needed
       * @private
       */
      calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {
        if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== "bevel" && lineJoin !== "miter") {
          return strokeWidth;
        }
        let r1 = this.radius_;
        let r2 = this.radius2_ === void 0 ? r1 : this.radius2_;
        if (r1 < r2) {
          const tmp = r1;
          r1 = r2;
          r2 = tmp;
        }
        const points = this.radius2_ === void 0 ? this.points_ : this.points_ * 2;
        const alpha = 2 * Math.PI / points;
        const a = r2 * Math.sin(alpha);
        const b = Math.sqrt(r2 * r2 - a * a);
        const d = r1 - b;
        const e = Math.sqrt(a * a + d * d);
        const miterRatio = e / a;
        if (lineJoin === "miter" && miterRatio <= miterLimit) {
          return miterRatio * strokeWidth;
        }
        const k = strokeWidth / 2 / miterRatio;
        const l = strokeWidth / 2 * (d / e);
        const maxr = Math.sqrt((r1 + k) * (r1 + k) + l * l);
        const bevelAdd = maxr - r1;
        if (this.radius2_ === void 0 || lineJoin === "bevel") {
          return bevelAdd * 2;
        }
        const aa = r1 * Math.sin(alpha);
        const bb = Math.sqrt(r1 * r1 - aa * aa);
        const dd = r2 - bb;
        const ee = Math.sqrt(aa * aa + dd * dd);
        const innerMiterRatio = ee / aa;
        if (innerMiterRatio <= miterLimit) {
          const innerLength = innerMiterRatio * strokeWidth / 2 - r2 - r1;
          return 2 * Math.max(bevelAdd, innerLength);
        }
        return bevelAdd * 2;
      }
      /**
       * @return {RenderOptions}  The render options
       * @protected
       */
      createRenderOptions() {
        let lineCap = defaultLineCap;
        let lineJoin = defaultLineJoin;
        let miterLimit = 0;
        let lineDash = null;
        let lineDashOffset = 0;
        let strokeStyle;
        let strokeWidth = 0;
        if (this.stroke_) {
          strokeStyle = asColorLike(this.stroke_.getColor() ?? defaultStrokeStyle);
          strokeWidth = this.stroke_.getWidth() ?? defaultLineWidth;
          lineDash = this.stroke_.getLineDash();
          lineDashOffset = this.stroke_.getLineDashOffset() ?? 0;
          lineJoin = this.stroke_.getLineJoin() ?? defaultLineJoin;
          lineCap = this.stroke_.getLineCap() ?? defaultLineCap;
          miterLimit = this.stroke_.getMiterLimit() ?? defaultMiterLimit;
        }
        const add4 = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
        const maxRadius = Math.max(this.radius_, this.radius2_ || 0);
        const size = Math.ceil(2 * maxRadius + add4);
        return {
          strokeStyle,
          strokeWidth,
          size,
          lineCap,
          lineDash,
          lineDashOffset,
          lineJoin,
          miterLimit
        };
      }
      /**
       * @protected
       */
      render() {
        this.renderOptions_ = this.createRenderOptions();
        const size = this.renderOptions_.size;
        this.canvases_ = {};
        this.hitDetectionCanvas_ = null;
        this.size_ = [size, size];
      }
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       * @param {CanvasRenderingContext2D} context The rendering context.
       * @param {number} pixelRatio The pixel ratio.
       */
      draw_(renderOptions, context, pixelRatio) {
        context.scale(pixelRatio, pixelRatio);
        context.translate(renderOptions.size / 2, renderOptions.size / 2);
        this.createPath_(context);
        if (this.fill_) {
          let color = this.fill_.getColor();
          if (color === null) {
            color = defaultFillStyle;
          }
          context.fillStyle = asColorLike(color);
          context.fill();
        }
        if (renderOptions.strokeStyle) {
          context.strokeStyle = renderOptions.strokeStyle;
          context.lineWidth = renderOptions.strokeWidth;
          if (renderOptions.lineDash) {
            context.setLineDash(renderOptions.lineDash);
            context.lineDashOffset = renderOptions.lineDashOffset;
          }
          context.lineCap = renderOptions.lineCap;
          context.lineJoin = renderOptions.lineJoin;
          context.miterLimit = renderOptions.miterLimit;
          context.stroke();
        }
      }
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       * @return {HTMLCanvasElement} Canvas containing the icon
       */
      createHitDetectionCanvas_(renderOptions) {
        let context;
        if (this.fill_) {
          let color = this.fill_.getColor();
          let opacity = 0;
          if (typeof color === "string") {
            color = asArray(color);
          }
          if (color === null) {
            opacity = 1;
          } else if (Array.isArray(color)) {
            opacity = color.length === 4 ? color[3] : 1;
          }
          if (opacity === 0) {
            context = createCanvasContext2D(renderOptions.size, renderOptions.size);
            this.drawHitDetectionCanvas_(renderOptions, context);
          }
        }
        return context ? context.canvas : this.getImage(1);
      }
      /**
       * @private
       * @param {CanvasRenderingContext2D} context The context to draw in.
       */
      createPath_(context) {
        let points = this.points_;
        const radius = this.radius_;
        if (points === Infinity) {
          context.arc(0, 0, radius, 0, 2 * Math.PI);
        } else {
          const radius2 = this.radius2_ === void 0 ? radius : this.radius2_;
          if (this.radius2_ !== void 0) {
            points *= 2;
          }
          const startAngle = this.angle_ - Math.PI / 2;
          const step = 2 * Math.PI / points;
          for (let i = 0; i < points; i++) {
            const angle0 = startAngle + i * step;
            const radiusC = i % 2 === 0 ? radius : radius2;
            context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
          }
          context.closePath();
        }
      }
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       * @param {CanvasRenderingContext2D} context The context.
       */
      drawHitDetectionCanvas_(renderOptions, context) {
        context.translate(renderOptions.size / 2, renderOptions.size / 2);
        this.createPath_(context);
        context.fillStyle = defaultFillStyle;
        context.fill();
        if (renderOptions.strokeStyle) {
          context.strokeStyle = renderOptions.strokeStyle;
          context.lineWidth = renderOptions.strokeWidth;
          if (renderOptions.lineDash) {
            context.setLineDash(renderOptions.lineDash);
            context.lineDashOffset = renderOptions.lineDashOffset;
          }
          context.lineJoin = renderOptions.lineJoin;
          context.miterLimit = renderOptions.miterLimit;
          context.stroke();
        }
      }
    };
    RegularShape_default = RegularShape;
  }
});

// node_modules/ol/style/Circle.js
var CircleStyle, Circle_default;
var init_Circle = __esm({
  "node_modules/ol/style/Circle.js"() {
    init_RegularShape();
    CircleStyle = class _CircleStyle extends RegularShape_default {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options) {
        options = options ? options : { radius: 5 };
        super({
          points: Infinity,
          fill: options.fill,
          radius: options.radius,
          stroke: options.stroke,
          scale: options.scale !== void 0 ? options.scale : 1,
          rotation: options.rotation !== void 0 ? options.rotation : 0,
          rotateWithView: options.rotateWithView !== void 0 ? options.rotateWithView : false,
          displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
          declutterMode: options.declutterMode
        });
      }
      /**
       * Clones the style.
       * @return {CircleStyle} The cloned style.
       * @api
       */
      clone() {
        const scale5 = this.getScale();
        const style = new _CircleStyle({
          fill: this.getFill() ? this.getFill().clone() : void 0,
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          radius: this.getRadius(),
          scale: Array.isArray(scale5) ? scale5.slice() : scale5,
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode()
        });
        style.setOpacity(this.getOpacity());
        return style;
      }
      /**
       * Set the circle radius.
       *
       * @param {number} radius Circle radius.
       * @api
       */
      setRadius(radius) {
        this.radius_ = radius;
        this.render();
      }
    };
    Circle_default = CircleStyle;
  }
});

// node_modules/ol/style/Style.js
var Style_exports = {};
__export(Style_exports, {
  createDefaultStyle: () => createDefaultStyle,
  createEditingStyle: () => createEditingStyle,
  default: () => Style_default,
  toFunction: () => toFunction
});
function toFunction(obj) {
  let styleFunction;
  if (typeof obj === "function") {
    styleFunction = obj;
  } else {
    let styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      assert(
        typeof /** @type {?} */
        obj.getZIndex === "function",
        "Expected an `Style` or an array of `Style`"
      );
      const style = (
        /** @type {Style} */
        obj
      );
      styles = [style];
    }
    styleFunction = function() {
      return styles;
    };
  }
  return styleFunction;
}
function createDefaultStyle(feature, resolution) {
  if (!defaultStyles) {
    const fill = new Fill_default({
      color: "rgba(255,255,255,0.4)"
    });
    const stroke = new Stroke_default({
      color: "#3399CC",
      width: 1.25
    });
    defaultStyles = [
      new Style({
        image: new Circle_default({
          fill,
          stroke,
          radius: 5
        }),
        fill,
        stroke
      })
    ];
  }
  return defaultStyles;
}
function createEditingStyle() {
  const styles = {};
  const white = [255, 255, 255, 1];
  const blue = [0, 153, 255, 1];
  const width = 3;
  styles["Polygon"] = [
    new Style({
      fill: new Fill_default({
        color: [255, 255, 255, 0.5]
      })
    })
  ];
  styles["MultiPolygon"] = styles["Polygon"];
  styles["LineString"] = [
    new Style({
      stroke: new Stroke_default({
        color: white,
        width: width + 2
      })
    }),
    new Style({
      stroke: new Stroke_default({
        color: blue,
        width
      })
    })
  ];
  styles["MultiLineString"] = styles["LineString"];
  styles["Circle"] = styles["Polygon"].concat(styles["LineString"]);
  styles["Point"] = [
    new Style({
      image: new Circle_default({
        radius: width * 2,
        fill: new Fill_default({
          color: blue
        }),
        stroke: new Stroke_default({
          color: white,
          width: width / 2
        })
      }),
      zIndex: Infinity
    })
  ];
  styles["MultiPoint"] = styles["Point"];
  styles["GeometryCollection"] = styles["Polygon"].concat(
    styles["LineString"],
    styles["Point"]
  );
  return styles;
}
function defaultGeometryFunction(feature) {
  return feature.getGeometry();
}
var Style, defaultStyles, Style_default;
var init_Style = __esm({
  "node_modules/ol/style/Style.js"() {
    init_Circle();
    init_Fill();
    init_Stroke();
    init_asserts();
    Style = class _Style {
      /**
       * @param {Options} [options] Style options.
       */
      constructor(options) {
        options = options || {};
        this.geometry_ = null;
        this.geometryFunction_ = defaultGeometryFunction;
        if (options.geometry !== void 0) {
          this.setGeometry(options.geometry);
        }
        this.fill_ = options.fill !== void 0 ? options.fill : null;
        this.image_ = options.image !== void 0 ? options.image : null;
        this.renderer_ = options.renderer !== void 0 ? options.renderer : null;
        this.hitDetectionRenderer_ = options.hitDetectionRenderer !== void 0 ? options.hitDetectionRenderer : null;
        this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
        this.text_ = options.text !== void 0 ? options.text : null;
        this.zIndex_ = options.zIndex;
      }
      /**
       * Clones the style.
       * @return {Style} The cloned style.
       * @api
       */
      clone() {
        let geometry = this.getGeometry();
        if (geometry && typeof geometry === "object") {
          geometry = /** @type {import("../geom/Geometry.js").default} */
          geometry.clone();
        }
        return new _Style({
          geometry: geometry ?? void 0,
          fill: this.getFill() ? this.getFill().clone() : void 0,
          image: this.getImage() ? this.getImage().clone() : void 0,
          renderer: this.getRenderer() ?? void 0,
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          text: this.getText() ? this.getText().clone() : void 0,
          zIndex: this.getZIndex()
        });
      }
      /**
       * Get the custom renderer function that was configured with
       * {@link #setRenderer} or the `renderer` constructor option.
       * @return {RenderFunction|null} Custom renderer function.
       * @api
       */
      getRenderer() {
        return this.renderer_;
      }
      /**
       * Sets a custom renderer function for this style. When set, `fill`, `stroke`
       * and `image` options of the style will be ignored.
       * @param {RenderFunction|null} renderer Custom renderer function.
       * @api
       */
      setRenderer(renderer) {
        this.renderer_ = renderer;
      }
      /**
       * Sets a custom renderer function for this style used
       * in hit detection.
       * @param {RenderFunction|null} renderer Custom renderer function.
       * @api
       */
      setHitDetectionRenderer(renderer) {
        this.hitDetectionRenderer_ = renderer;
      }
      /**
       * Get the custom renderer function that was configured with
       * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
       * @return {RenderFunction|null} Custom renderer function.
       * @api
       */
      getHitDetectionRenderer() {
        return this.hitDetectionRenderer_;
      }
      /**
       * Get the geometry to be rendered.
       * @return {string|import("../geom/Geometry.js").default|GeometryFunction|null}
       * Feature property or geometry or function that returns the geometry that will
       * be rendered with this style.
       * @api
       */
      getGeometry() {
        return this.geometry_;
      }
      /**
       * Get the function used to generate a geometry for rendering.
       * @return {!GeometryFunction} Function that is called with a feature
       * and returns the geometry to render instead of the feature's geometry.
       * @api
       */
      getGeometryFunction() {
        return this.geometryFunction_;
      }
      /**
       * Get the fill style.
       * @return {import("./Fill.js").default|null} Fill style.
       * @api
       */
      getFill() {
        return this.fill_;
      }
      /**
       * Set the fill style.
       * @param {import("./Fill.js").default|null} fill Fill style.
       * @api
       */
      setFill(fill) {
        this.fill_ = fill;
      }
      /**
       * Get the image style.
       * @return {import("./Image.js").default|null} Image style.
       * @api
       */
      getImage() {
        return this.image_;
      }
      /**
       * Set the image style.
       * @param {import("./Image.js").default} image Image style.
       * @api
       */
      setImage(image) {
        this.image_ = image;
      }
      /**
       * Get the stroke style.
       * @return {import("./Stroke.js").default|null} Stroke style.
       * @api
       */
      getStroke() {
        return this.stroke_;
      }
      /**
       * Set the stroke style.
       * @param {import("./Stroke.js").default|null} stroke Stroke style.
       * @api
       */
      setStroke(stroke) {
        this.stroke_ = stroke;
      }
      /**
       * Get the text style.
       * @return {import("./Text.js").default|null} Text style.
       * @api
       */
      getText() {
        return this.text_;
      }
      /**
       * Set the text style.
       * @param {import("./Text.js").default} text Text style.
       * @api
       */
      setText(text) {
        this.text_ = text;
      }
      /**
       * Get the z-index for the style.
       * @return {number|undefined} ZIndex.
       * @api
       */
      getZIndex() {
        return this.zIndex_;
      }
      /**
       * Set a geometry that is rendered instead of the feature's geometry.
       *
       * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
       *     Feature property or geometry or function returning a geometry to render
       *     for this style.
       * @api
       */
      setGeometry(geometry) {
        if (typeof geometry === "function") {
          this.geometryFunction_ = geometry;
        } else if (typeof geometry === "string") {
          this.geometryFunction_ = function(feature) {
            return (
              /** @type {import("../geom/Geometry.js").default} */
              feature.get(geometry)
            );
          };
        } else if (!geometry) {
          this.geometryFunction_ = defaultGeometryFunction;
        } else if (geometry !== void 0) {
          this.geometryFunction_ = function() {
            return (
              /** @type {import("../geom/Geometry.js").default} */
              geometry
            );
          };
        }
        this.geometry_ = geometry;
      }
      /**
       * Set the z-index.
       *
       * @param {number|undefined} zIndex ZIndex.
       * @api
       */
      setZIndex(zIndex) {
        this.zIndex_ = zIndex;
      }
    };
    defaultStyles = null;
    Style_default = Style;
  }
});

// node_modules/ol/style/Text.js
var DEFAULT_FILL_COLOR, Text, Text_default;
var init_Text = __esm({
  "node_modules/ol/style/Text.js"() {
    init_Fill();
    init_size();
    DEFAULT_FILL_COLOR = "#333";
    Text = class _Text {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options) {
        options = options || {};
        this.font_ = options.font;
        this.rotation_ = options.rotation;
        this.rotateWithView_ = options.rotateWithView;
        this.scale_ = options.scale;
        this.scaleArray_ = toSize(options.scale !== void 0 ? options.scale : 1);
        this.text_ = options.text;
        this.textAlign_ = options.textAlign;
        this.justify_ = options.justify;
        this.repeat_ = options.repeat;
        this.textBaseline_ = options.textBaseline;
        this.fill_ = options.fill !== void 0 ? options.fill : new Fill_default({ color: DEFAULT_FILL_COLOR });
        this.maxAngle_ = options.maxAngle !== void 0 ? options.maxAngle : Math.PI / 4;
        this.placement_ = options.placement !== void 0 ? options.placement : "point";
        this.overflow_ = !!options.overflow;
        this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
        this.offsetX_ = options.offsetX !== void 0 ? options.offsetX : 0;
        this.offsetY_ = options.offsetY !== void 0 ? options.offsetY : 0;
        this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
        this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
        this.padding_ = options.padding === void 0 ? null : options.padding;
      }
      /**
       * Clones the style.
       * @return {Text} The cloned style.
       * @api
       */
      clone() {
        const scale5 = this.getScale();
        return new _Text({
          font: this.getFont(),
          placement: this.getPlacement(),
          repeat: this.getRepeat(),
          maxAngle: this.getMaxAngle(),
          overflow: this.getOverflow(),
          rotation: this.getRotation(),
          rotateWithView: this.getRotateWithView(),
          scale: Array.isArray(scale5) ? scale5.slice() : scale5,
          text: this.getText(),
          textAlign: this.getTextAlign(),
          justify: this.getJustify(),
          textBaseline: this.getTextBaseline(),
          fill: this.getFill() ? this.getFill().clone() : void 0,
          stroke: this.getStroke() ? this.getStroke().clone() : void 0,
          offsetX: this.getOffsetX(),
          offsetY: this.getOffsetY(),
          backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
          backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
          padding: this.getPadding() || void 0
        });
      }
      /**
       * Get the `overflow` configuration.
       * @return {boolean} Let text overflow the length of the path they follow.
       * @api
       */
      getOverflow() {
        return this.overflow_;
      }
      /**
       * Get the font name.
       * @return {string|undefined} Font.
       * @api
       */
      getFont() {
        return this.font_;
      }
      /**
       * Get the maximum angle between adjacent characters.
       * @return {number} Angle in radians.
       * @api
       */
      getMaxAngle() {
        return this.maxAngle_;
      }
      /**
       * Get the label placement.
       * @return {TextPlacement} Text placement.
       * @api
       */
      getPlacement() {
        return this.placement_;
      }
      /**
       * Get the repeat interval of the text.
       * @return {number|undefined} Repeat interval in pixels.
       * @api
       */
      getRepeat() {
        return this.repeat_;
      }
      /**
       * Get the x-offset for the text.
       * @return {number} Horizontal text offset.
       * @api
       */
      getOffsetX() {
        return this.offsetX_;
      }
      /**
       * Get the y-offset for the text.
       * @return {number} Vertical text offset.
       * @api
       */
      getOffsetY() {
        return this.offsetY_;
      }
      /**
       * Get the fill style for the text.
       * @return {import("./Fill.js").default|null} Fill style.
       * @api
       */
      getFill() {
        return this.fill_;
      }
      /**
       * Determine whether the text rotates with the map.
       * @return {boolean|undefined} Rotate with map.
       * @api
       */
      getRotateWithView() {
        return this.rotateWithView_;
      }
      /**
       * Get the text rotation.
       * @return {number|undefined} Rotation.
       * @api
       */
      getRotation() {
        return this.rotation_;
      }
      /**
       * Get the text scale.
       * @return {number|import("../size.js").Size|undefined} Scale.
       * @api
       */
      getScale() {
        return this.scale_;
      }
      /**
       * Get the symbolizer scale array.
       * @return {import("../size.js").Size} Scale array.
       */
      getScaleArray() {
        return this.scaleArray_;
      }
      /**
       * Get the stroke style for the text.
       * @return {import("./Stroke.js").default|null} Stroke style.
       * @api
       */
      getStroke() {
        return this.stroke_;
      }
      /**
       * Get the text to be rendered.
       * @return {string|Array<string>|undefined} Text.
       * @api
       */
      getText() {
        return this.text_;
      }
      /**
       * Get the text alignment.
       * @return {CanvasTextAlign|undefined} Text align.
       * @api
       */
      getTextAlign() {
        return this.textAlign_;
      }
      /**
       * Get the justification.
       * @return {TextJustify|undefined} Justification.
       * @api
       */
      getJustify() {
        return this.justify_;
      }
      /**
       * Get the text baseline.
       * @return {CanvasTextBaseline|undefined} Text baseline.
       * @api
       */
      getTextBaseline() {
        return this.textBaseline_;
      }
      /**
       * Get the background fill style for the text.
       * @return {import("./Fill.js").default|null} Fill style.
       * @api
       */
      getBackgroundFill() {
        return this.backgroundFill_;
      }
      /**
       * Get the background stroke style for the text.
       * @return {import("./Stroke.js").default|null} Stroke style.
       * @api
       */
      getBackgroundStroke() {
        return this.backgroundStroke_;
      }
      /**
       * Get the padding for the text.
       * @return {Array<number>|null} Padding.
       * @api
       */
      getPadding() {
        return this.padding_;
      }
      /**
       * Set the `overflow` property.
       *
       * @param {boolean} overflow Let text overflow the path that it follows.
       * @api
       */
      setOverflow(overflow) {
        this.overflow_ = overflow;
      }
      /**
       * Set the font.
       *
       * @param {string|undefined} font Font.
       * @api
       */
      setFont(font) {
        this.font_ = font;
      }
      /**
       * Set the maximum angle between adjacent characters.
       *
       * @param {number} maxAngle Angle in radians.
       * @api
       */
      setMaxAngle(maxAngle) {
        this.maxAngle_ = maxAngle;
      }
      /**
       * Set the x offset.
       *
       * @param {number} offsetX Horizontal text offset.
       * @api
       */
      setOffsetX(offsetX) {
        this.offsetX_ = offsetX;
      }
      /**
       * Set the y offset.
       *
       * @param {number} offsetY Vertical text offset.
       * @api
       */
      setOffsetY(offsetY) {
        this.offsetY_ = offsetY;
      }
      /**
       * Set the text placement.
       *
       * @param {TextPlacement} placement Placement.
       * @api
       */
      setPlacement(placement) {
        this.placement_ = placement;
      }
      /**
       * Set the repeat interval of the text.
       * @param {number|undefined} [repeat] Repeat interval in pixels.
       * @api
       */
      setRepeat(repeat) {
        this.repeat_ = repeat;
      }
      /**
       * Set whether to rotate the text with the view.
       *
       * @param {boolean} rotateWithView Rotate with map.
       * @api
       */
      setRotateWithView(rotateWithView) {
        this.rotateWithView_ = rotateWithView;
      }
      /**
       * Set the fill.
       *
       * @param {import("./Fill.js").default|null} fill Fill style.
       * @api
       */
      setFill(fill) {
        this.fill_ = fill;
      }
      /**
       * Set the rotation.
       *
       * @param {number|undefined} rotation Rotation.
       * @api
       */
      setRotation(rotation) {
        this.rotation_ = rotation;
      }
      /**
       * Set the scale.
       *
       * @param {number|import("../size.js").Size|undefined} scale Scale.
       * @api
       */
      setScale(scale5) {
        this.scale_ = scale5;
        this.scaleArray_ = toSize(scale5 !== void 0 ? scale5 : 1);
      }
      /**
       * Set the stroke.
       *
       * @param {import("./Stroke.js").default|null} stroke Stroke style.
       * @api
       */
      setStroke(stroke) {
        this.stroke_ = stroke;
      }
      /**
       * Set the text.
       *
       * @param {string|Array<string>|undefined} text Text.
       * @api
       */
      setText(text) {
        this.text_ = text;
      }
      /**
       * Set the text alignment.
       *
       * @param {CanvasTextAlign|undefined} textAlign Text align.
       * @api
       */
      setTextAlign(textAlign) {
        this.textAlign_ = textAlign;
      }
      /**
       * Set the justification.
       *
       * @param {TextJustify|undefined} justify Justification.
       * @api
       */
      setJustify(justify) {
        this.justify_ = justify;
      }
      /**
       * Set the text baseline.
       *
       * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
       * @api
       */
      setTextBaseline(textBaseline) {
        this.textBaseline_ = textBaseline;
      }
      /**
       * Set the background fill.
       *
       * @param {import("./Fill.js").default|null} fill Fill style.
       * @api
       */
      setBackgroundFill(fill) {
        this.backgroundFill_ = fill;
      }
      /**
       * Set the background stroke.
       *
       * @param {import("./Stroke.js").default|null} stroke Stroke style.
       * @api
       */
      setBackgroundStroke(stroke) {
        this.backgroundStroke_ = stroke;
      }
      /**
       * Set the padding (`[top, right, bottom, left]`).
       *
       * @param {Array<number>|null} padding Padding.
       * @api
       */
      setPadding(padding) {
        this.padding_ = padding;
      }
    };
    Text_default = Text;
  }
});

// node_modules/quickselect/index.js
function quickselect(arr, k, left, right, compare) {
  quickselectStep(arr, k, left || 0, right || arr.length - 1, compare || defaultCompare);
}
function quickselectStep(arr, k, left, right, compare) {
  while (right > left) {
    if (right - left > 600) {
      var n = right - left + 1;
      var m = k - left + 1;
      var z = Math.log(n);
      var s = 0.5 * Math.exp(2 * z / 3);
      var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
      var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
      var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
      quickselectStep(arr, k, newLeft, newRight, compare);
    }
    var t = arr[k];
    var i = left;
    var j = right;
    swap(arr, left, k);
    if (compare(arr[right], t) > 0)
      swap(arr, left, right);
    while (i < j) {
      swap(arr, i, j);
      i++;
      j--;
      while (compare(arr[i], t) < 0)
        i++;
      while (compare(arr[j], t) > 0)
        j--;
    }
    if (compare(arr[left], t) === 0)
      swap(arr, left, j);
    else {
      j++;
      swap(arr, j, right);
    }
    if (j <= k)
      left = j + 1;
    if (k <= j)
      right = j - 1;
  }
}
function swap(arr, i, j) {
  var tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function defaultCompare(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
var init_quickselect = __esm({
  "node_modules/quickselect/index.js"() {
  }
});

// node_modules/rbush/index.js
function findItem(item, items, equalsFn) {
  if (!equalsFn)
    return items.indexOf(item);
  for (let i = 0; i < items.length; i++) {
    if (equalsFn(item, items[i]))
      return i;
  }
  return -1;
}
function calcBBox(node, toBBox) {
  distBBox(node, 0, node.children.length, toBBox, node);
}
function distBBox(node, k, p, toBBox, destNode) {
  if (!destNode)
    destNode = createNode(null);
  destNode.minX = Infinity;
  destNode.minY = Infinity;
  destNode.maxX = -Infinity;
  destNode.maxY = -Infinity;
  for (let i = k; i < p; i++) {
    const child = node.children[i];
    extend3(destNode, node.leaf ? toBBox(child) : child);
  }
  return destNode;
}
function extend3(a, b) {
  a.minX = Math.min(a.minX, b.minX);
  a.minY = Math.min(a.minY, b.minY);
  a.maxX = Math.max(a.maxX, b.maxX);
  a.maxY = Math.max(a.maxY, b.maxY);
  return a;
}
function compareNodeMinX(a, b) {
  return a.minX - b.minX;
}
function compareNodeMinY(a, b) {
  return a.minY - b.minY;
}
function bboxArea(a) {
  return (a.maxX - a.minX) * (a.maxY - a.minY);
}
function bboxMargin(a) {
  return a.maxX - a.minX + (a.maxY - a.minY);
}
function enlargedArea(a, b) {
  return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) * (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}
function intersectionArea(a, b) {
  const minX = Math.max(a.minX, b.minX);
  const minY = Math.max(a.minY, b.minY);
  const maxX = Math.min(a.maxX, b.maxX);
  const maxY = Math.min(a.maxY, b.maxY);
  return Math.max(0, maxX - minX) * Math.max(0, maxY - minY);
}
function contains(a, b) {
  return a.minX <= b.minX && a.minY <= b.minY && b.maxX <= a.maxX && b.maxY <= a.maxY;
}
function intersects2(a, b) {
  return b.minX <= a.maxX && b.minY <= a.maxY && b.maxX >= a.minX && b.maxY >= a.minY;
}
function createNode(children) {
  return {
    children,
    height: 1,
    leaf: true,
    minX: Infinity,
    minY: Infinity,
    maxX: -Infinity,
    maxY: -Infinity
  };
}
function multiSelect(arr, left, right, n, compare) {
  const stack = [left, right];
  while (stack.length) {
    right = stack.pop();
    left = stack.pop();
    if (right - left <= n)
      continue;
    const mid = left + Math.ceil((right - left) / n / 2) * n;
    quickselect(arr, mid, left, right, compare);
    stack.push(left, mid, mid, right);
  }
}
var RBush;
var init_rbush = __esm({
  "node_modules/rbush/index.js"() {
    init_quickselect();
    RBush = class {
      constructor(maxEntries = 9) {
        this._maxEntries = Math.max(4, maxEntries);
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
        this.clear();
      }
      all() {
        return this._all(this.data, []);
      }
      search(bbox2) {
        let node = this.data;
        const result = [];
        if (!intersects2(bbox2, node))
          return result;
        const toBBox = this.toBBox;
        const nodesToSearch = [];
        while (node) {
          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            const childBBox = node.leaf ? toBBox(child) : child;
            if (intersects2(bbox2, childBBox)) {
              if (node.leaf)
                result.push(child);
              else if (contains(bbox2, childBBox))
                this._all(child, result);
              else
                nodesToSearch.push(child);
            }
          }
          node = nodesToSearch.pop();
        }
        return result;
      }
      collides(bbox2) {
        let node = this.data;
        if (!intersects2(bbox2, node))
          return false;
        const nodesToSearch = [];
        while (node) {
          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            const childBBox = node.leaf ? this.toBBox(child) : child;
            if (intersects2(bbox2, childBBox)) {
              if (node.leaf || contains(bbox2, childBBox))
                return true;
              nodesToSearch.push(child);
            }
          }
          node = nodesToSearch.pop();
        }
        return false;
      }
      load(data) {
        if (!(data && data.length))
          return this;
        if (data.length < this._minEntries) {
          for (let i = 0; i < data.length; i++) {
            this.insert(data[i]);
          }
          return this;
        }
        let node = this._build(data.slice(), 0, data.length - 1, 0);
        if (!this.data.children.length) {
          this.data = node;
        } else if (this.data.height === node.height) {
          this._splitRoot(this.data, node);
        } else {
          if (this.data.height < node.height) {
            const tmpNode = this.data;
            this.data = node;
            node = tmpNode;
          }
          this._insert(node, this.data.height - node.height - 1, true);
        }
        return this;
      }
      insert(item) {
        if (item)
          this._insert(item, this.data.height - 1);
        return this;
      }
      clear() {
        this.data = createNode([]);
        return this;
      }
      remove(item, equalsFn) {
        if (!item)
          return this;
        let node = this.data;
        const bbox2 = this.toBBox(item);
        const path = [];
        const indexes = [];
        let i, parent, goingUp;
        while (node || path.length) {
          if (!node) {
            node = path.pop();
            parent = path[path.length - 1];
            i = indexes.pop();
            goingUp = true;
          }
          if (node.leaf) {
            const index = findItem(item, node.children, equalsFn);
            if (index !== -1) {
              node.children.splice(index, 1);
              path.push(node);
              this._condense(path);
              return this;
            }
          }
          if (!goingUp && !node.leaf && contains(node, bbox2)) {
            path.push(node);
            indexes.push(i);
            i = 0;
            parent = node;
            node = node.children[0];
          } else if (parent) {
            i++;
            node = parent.children[i];
            goingUp = false;
          } else
            node = null;
        }
        return this;
      }
      toBBox(item) {
        return item;
      }
      compareMinX(a, b) {
        return a.minX - b.minX;
      }
      compareMinY(a, b) {
        return a.minY - b.minY;
      }
      toJSON() {
        return this.data;
      }
      fromJSON(data) {
        this.data = data;
        return this;
      }
      _all(node, result) {
        const nodesToSearch = [];
        while (node) {
          if (node.leaf)
            result.push(...node.children);
          else
            nodesToSearch.push(...node.children);
          node = nodesToSearch.pop();
        }
        return result;
      }
      _build(items, left, right, height) {
        const N = right - left + 1;
        let M = this._maxEntries;
        let node;
        if (N <= M) {
          node = createNode(items.slice(left, right + 1));
          calcBBox(node, this.toBBox);
          return node;
        }
        if (!height) {
          height = Math.ceil(Math.log(N) / Math.log(M));
          M = Math.ceil(N / Math.pow(M, height - 1));
        }
        node = createNode([]);
        node.leaf = false;
        node.height = height;
        const N2 = Math.ceil(N / M);
        const N1 = N2 * Math.ceil(Math.sqrt(M));
        multiSelect(items, left, right, N1, this.compareMinX);
        for (let i = left; i <= right; i += N1) {
          const right2 = Math.min(i + N1 - 1, right);
          multiSelect(items, i, right2, N2, this.compareMinY);
          for (let j = i; j <= right2; j += N2) {
            const right3 = Math.min(j + N2 - 1, right2);
            node.children.push(this._build(items, j, right3, height - 1));
          }
        }
        calcBBox(node, this.toBBox);
        return node;
      }
      _chooseSubtree(bbox2, node, level2, path) {
        while (true) {
          path.push(node);
          if (node.leaf || path.length - 1 === level2)
            break;
          let minArea = Infinity;
          let minEnlargement = Infinity;
          let targetNode;
          for (let i = 0; i < node.children.length; i++) {
            const child = node.children[i];
            const area = bboxArea(child);
            const enlargement = enlargedArea(bbox2, child) - area;
            if (enlargement < minEnlargement) {
              minEnlargement = enlargement;
              minArea = area < minArea ? area : minArea;
              targetNode = child;
            } else if (enlargement === minEnlargement) {
              if (area < minArea) {
                minArea = area;
                targetNode = child;
              }
            }
          }
          node = targetNode || node.children[0];
        }
        return node;
      }
      _insert(item, level2, isNode) {
        const bbox2 = isNode ? item : this.toBBox(item);
        const insertPath = [];
        const node = this._chooseSubtree(bbox2, this.data, level2, insertPath);
        node.children.push(item);
        extend3(node, bbox2);
        while (level2 >= 0) {
          if (insertPath[level2].children.length > this._maxEntries) {
            this._split(insertPath, level2);
            level2--;
          } else
            break;
        }
        this._adjustParentBBoxes(bbox2, insertPath, level2);
      }
      // split overflowed node into two
      _split(insertPath, level2) {
        const node = insertPath[level2];
        const M = node.children.length;
        const m = this._minEntries;
        this._chooseSplitAxis(node, m, M);
        const splitIndex = this._chooseSplitIndex(node, m, M);
        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;
        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);
        if (level2)
          insertPath[level2 - 1].children.push(newNode);
        else
          this._splitRoot(node, newNode);
      }
      _splitRoot(node, newNode) {
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
      }
      _chooseSplitIndex(node, m, M) {
        let index;
        let minOverlap = Infinity;
        let minArea = Infinity;
        for (let i = m; i <= M - m; i++) {
          const bbox1 = distBBox(node, 0, i, this.toBBox);
          const bbox2 = distBBox(node, i, M, this.toBBox);
          const overlap = intersectionArea(bbox1, bbox2);
          const area = bboxArea(bbox1) + bboxArea(bbox2);
          if (overlap < minOverlap) {
            minOverlap = overlap;
            index = i;
            minArea = area < minArea ? area : minArea;
          } else if (overlap === minOverlap) {
            if (area < minArea) {
              minArea = area;
              index = i;
            }
          }
        }
        return index || M - m;
      }
      // sorts node children by the best axis for split
      _chooseSplitAxis(node, m, M) {
        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
        const xMargin = this._allDistMargin(node, m, M, compareMinX);
        const yMargin = this._allDistMargin(node, m, M, compareMinY);
        if (xMargin < yMargin)
          node.children.sort(compareMinX);
      }
      // total margin of all possible split distributions where each node is at least m full
      _allDistMargin(node, m, M, compare) {
        node.children.sort(compare);
        const toBBox = this.toBBox;
        const leftBBox = distBBox(node, 0, m, toBBox);
        const rightBBox = distBBox(node, M - m, M, toBBox);
        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);
        for (let i = m; i < M - m; i++) {
          const child = node.children[i];
          extend3(leftBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(leftBBox);
        }
        for (let i = M - m - 1; i >= m; i--) {
          const child = node.children[i];
          extend3(rightBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(rightBBox);
        }
        return margin;
      }
      _adjustParentBBoxes(bbox2, path, level2) {
        for (let i = level2; i >= 0; i--) {
          extend3(path[i], bbox2);
        }
      }
      _condense(path) {
        for (let i = path.length - 1, siblings; i >= 0; i--) {
          if (path[i].children.length === 0) {
            if (i > 0) {
              siblings = path[i - 1].children;
              siblings.splice(siblings.indexOf(path[i]), 1);
            } else
              this.clear();
          } else
            calcBBox(path[i], this.toBBox);
        }
      }
    };
  }
});

// node_modules/ol/style/IconImage.js
function get4(image, cacheKey, crossOrigin, imageState, color) {
  let iconImage = cacheKey === void 0 ? void 0 : shared.get(cacheKey, crossOrigin, color);
  if (!iconImage) {
    iconImage = new IconImage(
      image,
      image instanceof HTMLImageElement ? image.src || void 0 : cacheKey,
      crossOrigin,
      imageState,
      color
    );
    shared.set(cacheKey, crossOrigin, color, iconImage);
  }
  return iconImage;
}
var taintedTestContext, IconImage, IconImage_default;
var init_IconImage = __esm({
  "node_modules/ol/style/IconImage.js"() {
    init_Target();
    init_EventType();
    init_ImageState();
    init_color();
    init_dom();
    init_Image();
    init_IconImageCache();
    taintedTestContext = null;
    IconImage = class extends Target_default {
      /**
       * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap} image Image.
       * @param {string|undefined} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../ImageState.js").default} imageState Image state.
       * @param {import("../color.js").Color} color Color.
       */
      constructor(image, src, crossOrigin, imageState, color) {
        super();
        this.hitDetectionImage_ = null;
        this.image_ = image;
        this.crossOrigin_ = crossOrigin;
        this.canvas_ = {};
        this.color_ = color;
        this.imageState_ = imageState === void 0 ? ImageState_default.IDLE : imageState;
        this.size_ = image && image.width && image.height ? [image.width, image.height] : null;
        this.src_ = src;
        this.tainted_;
      }
      /**
       * @private
       */
      initializeImage_() {
        this.image_ = new Image();
        if (this.crossOrigin_ !== null) {
          this.image_.crossOrigin = this.crossOrigin_;
        }
      }
      /**
       * @private
       * @return {boolean} The image canvas is tainted.
       */
      isTainted_() {
        if (this.tainted_ === void 0 && this.imageState_ === ImageState_default.LOADED) {
          if (!taintedTestContext) {
            taintedTestContext = createCanvasContext2D(1, 1, void 0, {
              willReadFrequently: true
            });
          }
          taintedTestContext.drawImage(this.image_, 0, 0);
          try {
            taintedTestContext.getImageData(0, 0, 1, 1);
            this.tainted_ = false;
          } catch (e) {
            taintedTestContext = null;
            this.tainted_ = true;
          }
        }
        return this.tainted_ === true;
      }
      /**
       * @private
       */
      dispatchChangeEvent_() {
        this.dispatchEvent(EventType_default.CHANGE);
      }
      /**
       * @private
       */
      handleImageError_() {
        this.imageState_ = ImageState_default.ERROR;
        this.dispatchChangeEvent_();
      }
      /**
       * @private
       */
      handleImageLoad_() {
        this.imageState_ = ImageState_default.LOADED;
        this.size_ = [this.image_.width, this.image_.height];
        this.dispatchChangeEvent_();
      }
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
       */
      getImage(pixelRatio) {
        if (!this.image_) {
          this.initializeImage_();
        }
        this.replaceColor_(pixelRatio);
        return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
      }
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Image or Canvas element.
       */
      getPixelRatio(pixelRatio) {
        this.replaceColor_(pixelRatio);
        return this.canvas_[pixelRatio] ? pixelRatio : 1;
      }
      /**
       * @return {import("../ImageState.js").default} Image state.
       */
      getImageState() {
        return this.imageState_;
      }
      /**
       * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
       */
      getHitDetectionImage() {
        if (!this.image_) {
          this.initializeImage_();
        }
        if (!this.hitDetectionImage_) {
          if (this.isTainted_()) {
            const width = this.size_[0];
            const height = this.size_[1];
            const context = createCanvasContext2D(width, height);
            context.fillRect(0, 0, width, height);
            this.hitDetectionImage_ = context.canvas;
          } else {
            this.hitDetectionImage_ = this.image_;
          }
        }
        return this.hitDetectionImage_;
      }
      /**
       * Get the size of the icon (in pixels).
       * @return {import("../size.js").Size} Image size.
       */
      getSize() {
        return this.size_;
      }
      /**
       * @return {string|undefined} Image src.
       */
      getSrc() {
        return this.src_;
      }
      /**
       * Load not yet loaded URI.
       */
      load() {
        if (this.imageState_ !== ImageState_default.IDLE) {
          return;
        }
        if (!this.image_) {
          this.initializeImage_();
        }
        this.imageState_ = ImageState_default.LOADING;
        try {
          if (this.src_ !== void 0) {
            this.image_.src = this.src_;
          }
        } catch (e) {
          this.handleImageError_();
        }
        if (this.image_ instanceof HTMLImageElement) {
          decodeFallback(this.image_, this.src_).then((image) => {
            this.image_ = image;
            this.handleImageLoad_();
          }).catch(this.handleImageError_.bind(this));
        }
      }
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @private
       */
      replaceColor_(pixelRatio) {
        if (!this.color_ || this.canvas_[pixelRatio] || this.imageState_ !== ImageState_default.LOADED) {
          return;
        }
        const image = this.image_;
        const canvas = document.createElement("canvas");
        canvas.width = Math.ceil(image.width * pixelRatio);
        canvas.height = Math.ceil(image.height * pixelRatio);
        const ctx = canvas.getContext("2d");
        ctx.scale(pixelRatio, pixelRatio);
        ctx.drawImage(image, 0, 0);
        ctx.globalCompositeOperation = "multiply";
        ctx.fillStyle = asString(this.color_);
        ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
        ctx.globalCompositeOperation = "destination-in";
        ctx.drawImage(image, 0, 0);
        this.canvas_[pixelRatio] = canvas;
      }
    };
    IconImage_default = IconImage;
  }
});

// node_modules/ol/style/Icon.js
var Icon_exports = {};
__export(Icon_exports, {
  default: () => Icon_default
});
function calculateScale(width, height, wantedWidth, wantedHeight) {
  if (wantedWidth !== void 0 && wantedHeight !== void 0) {
    return [wantedWidth / width, wantedHeight / height];
  }
  if (wantedWidth !== void 0) {
    return wantedWidth / width;
  }
  if (wantedHeight !== void 0) {
    return wantedHeight / height;
  }
  return 1;
}
var Icon, Icon_default;
var init_Icon = __esm({
  "node_modules/ol/style/Icon.js"() {
    init_EventType();
    init_ImageState();
    init_Image2();
    init_color();
    init_asserts();
    init_IconImage();
    init_util();
    Icon = class _Icon extends Image_default2 {
      /**
       * @param {Options} [options] Options.
       */
      constructor(options) {
        options = options || {};
        const opacity = options.opacity !== void 0 ? options.opacity : 1;
        const rotation = options.rotation !== void 0 ? options.rotation : 0;
        const scale5 = options.scale !== void 0 ? options.scale : 1;
        const rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
        super({
          opacity,
          rotation,
          scale: scale5,
          displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
          rotateWithView,
          declutterMode: options.declutterMode
        });
        this.anchor_ = options.anchor !== void 0 ? options.anchor : [0.5, 0.5];
        this.normalizedAnchor_ = null;
        this.anchorOrigin_ = options.anchorOrigin !== void 0 ? options.anchorOrigin : "top-left";
        this.anchorXUnits_ = options.anchorXUnits !== void 0 ? options.anchorXUnits : "fraction";
        this.anchorYUnits_ = options.anchorYUnits !== void 0 ? options.anchorYUnits : "fraction";
        this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;
        const image = options.img !== void 0 ? options.img : null;
        let cacheKey = options.src;
        assert(
          !(cacheKey !== void 0 && image),
          "`image` and `src` cannot be provided at the same time"
        );
        if ((cacheKey === void 0 || cacheKey.length === 0) && image) {
          cacheKey = /** @type {HTMLImageElement} */
          image.src || getUid(image);
        }
        assert(
          cacheKey !== void 0 && cacheKey.length > 0,
          "A defined and non-empty `src` or `image` must be provided"
        );
        assert(
          !((options.width !== void 0 || options.height !== void 0) && options.scale !== void 0),
          "`width` or `height` cannot be provided together with `scale`"
        );
        let imageState;
        if (options.src !== void 0) {
          imageState = ImageState_default.IDLE;
        } else if (image !== void 0) {
          if (image instanceof HTMLImageElement) {
            if (image.complete) {
              imageState = image.src ? ImageState_default.LOADED : ImageState_default.IDLE;
            } else {
              imageState = ImageState_default.LOADING;
            }
          } else {
            imageState = ImageState_default.LOADED;
          }
        }
        this.color_ = options.color !== void 0 ? asArray(options.color) : null;
        this.iconImage_ = get4(
          image,
          /** @type {string} */
          cacheKey,
          this.crossOrigin_,
          imageState,
          this.color_
        );
        this.offset_ = options.offset !== void 0 ? options.offset : [0, 0];
        this.offsetOrigin_ = options.offsetOrigin !== void 0 ? options.offsetOrigin : "top-left";
        this.origin_ = null;
        this.size_ = options.size !== void 0 ? options.size : null;
        if (options.width !== void 0 || options.height !== void 0) {
          let width, height;
          if (options.size) {
            [width, height] = options.size;
          } else {
            const image2 = this.getImage(1);
            if (image2.width && image2.height) {
              width = image2.width;
              height = image2.height;
            } else if (image2 instanceof HTMLImageElement) {
              this.initialOptions_ = options;
              const onload = () => {
                this.unlistenImageChange(onload);
                if (!this.initialOptions_) {
                  return;
                }
                const imageSize = this.iconImage_.getSize();
                this.setScale(
                  calculateScale(
                    imageSize[0],
                    imageSize[1],
                    options.width,
                    options.height
                  )
                );
              };
              this.listenImageChange(onload);
              return;
            }
          }
          if (width !== void 0) {
            this.setScale(
              calculateScale(width, height, options.width, options.height)
            );
          }
        }
      }
      /**
       * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
       * @return {Icon} The cloned style.
       * @api
       */
      clone() {
        let scale5, width, height;
        if (this.initialOptions_) {
          width = this.initialOptions_.width;
          height = this.initialOptions_.height;
        } else {
          scale5 = this.getScale();
          scale5 = Array.isArray(scale5) ? scale5.slice() : scale5;
        }
        return new _Icon({
          anchor: this.anchor_.slice(),
          anchorOrigin: this.anchorOrigin_,
          anchorXUnits: this.anchorXUnits_,
          anchorYUnits: this.anchorYUnits_,
          color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
          crossOrigin: this.crossOrigin_,
          offset: this.offset_.slice(),
          offsetOrigin: this.offsetOrigin_,
          opacity: this.getOpacity(),
          rotateWithView: this.getRotateWithView(),
          rotation: this.getRotation(),
          scale: scale5,
          width,
          height,
          size: this.size_ !== null ? this.size_.slice() : void 0,
          src: this.getSrc(),
          displacement: this.getDisplacement().slice(),
          declutterMode: this.getDeclutterMode()
        });
      }
      /**
       * Get the anchor point in pixels. The anchor determines the center point for the
       * symbolizer.
       * @return {Array<number>} Anchor.
       * @api
       */
      getAnchor() {
        let anchor = this.normalizedAnchor_;
        if (!anchor) {
          anchor = this.anchor_;
          const size = this.getSize();
          if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
            if (!size) {
              return null;
            }
            anchor = this.anchor_.slice();
            if (this.anchorXUnits_ == "fraction") {
              anchor[0] *= size[0];
            }
            if (this.anchorYUnits_ == "fraction") {
              anchor[1] *= size[1];
            }
          }
          if (this.anchorOrigin_ != "top-left") {
            if (!size) {
              return null;
            }
            if (anchor === this.anchor_) {
              anchor = this.anchor_.slice();
            }
            if (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") {
              anchor[0] = -anchor[0] + size[0];
            }
            if (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") {
              anchor[1] = -anchor[1] + size[1];
            }
          }
          this.normalizedAnchor_ = anchor;
        }
        const displacement = this.getDisplacement();
        const scale5 = this.getScaleArray();
        return [
          anchor[0] - displacement[0] / scale5[0],
          anchor[1] + displacement[1] / scale5[1]
        ];
      }
      /**
       * Set the anchor point. The anchor determines the center point for the
       * symbolizer.
       *
       * @param {Array<number>} anchor Anchor.
       * @api
       */
      setAnchor(anchor) {
        this.anchor_ = anchor;
        this.normalizedAnchor_ = null;
      }
      /**
       * Get the icon color.
       * @return {import("../color.js").Color} Color.
       * @api
       */
      getColor() {
        return this.color_;
      }
      /**
       * Get the image icon.
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element. If the Icon
       * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
       * @api
       */
      getImage(pixelRatio) {
        return this.iconImage_.getImage(pixelRatio);
      }
      /**
       * Get the pixel ratio.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} The pixel ratio of the image.
       * @api
       */
      getPixelRatio(pixelRatio) {
        return this.iconImage_.getPixelRatio(pixelRatio);
      }
      /**
       * @return {import("../size.js").Size} Image size.
       */
      getImageSize() {
        return this.iconImage_.getSize();
      }
      /**
       * @return {import("../ImageState.js").default} Image state.
       */
      getImageState() {
        return this.iconImage_.getImageState();
      }
      /**
       * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
       */
      getHitDetectionImage() {
        return this.iconImage_.getHitDetectionImage();
      }
      /**
       * Get the origin of the symbolizer.
       * @return {Array<number>} Origin.
       * @api
       */
      getOrigin() {
        if (this.origin_) {
          return this.origin_;
        }
        let offset2 = this.offset_;
        if (this.offsetOrigin_ != "top-left") {
          const size = this.getSize();
          const iconImageSize = this.iconImage_.getSize();
          if (!size || !iconImageSize) {
            return null;
          }
          offset2 = offset2.slice();
          if (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") {
            offset2[0] = iconImageSize[0] - size[0] - offset2[0];
          }
          if (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") {
            offset2[1] = iconImageSize[1] - size[1] - offset2[1];
          }
        }
        this.origin_ = offset2;
        return this.origin_;
      }
      /**
       * Get the image URL.
       * @return {string|undefined} Image src.
       * @api
       */
      getSrc() {
        return this.iconImage_.getSrc();
      }
      /**
       * Get the size of the icon (in pixels).
       * @return {import("../size.js").Size} Image size.
       * @api
       */
      getSize() {
        return !this.size_ ? this.iconImage_.getSize() : this.size_;
      }
      /**
       * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
       * @return {number} Icon width (in pixels).
       * @api
       */
      getWidth() {
        const scale5 = this.getScaleArray();
        if (this.size_) {
          return this.size_[0] * scale5[0];
        }
        if (this.iconImage_.getImageState() == ImageState_default.LOADED) {
          return this.iconImage_.getSize()[0] * scale5[0];
        }
        return void 0;
      }
      /**
       * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
       * @return {number} Icon height (in pixels).
       * @api
       */
      getHeight() {
        const scale5 = this.getScaleArray();
        if (this.size_) {
          return this.size_[1] * scale5[1];
        }
        if (this.iconImage_.getImageState() == ImageState_default.LOADED) {
          return this.iconImage_.getSize()[1] * scale5[1];
        }
        return void 0;
      }
      /**
       * Set the scale.
       *
       * @param {number|import("../size.js").Size} scale Scale.
       * @api
       */
      setScale(scale5) {
        delete this.initialOptions_;
        super.setScale(scale5);
      }
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      listenImageChange(listener) {
        this.iconImage_.addEventListener(EventType_default.CHANGE, listener);
      }
      /**
       * Load not yet loaded URI.
       * When rendering a feature with an icon style, the vector renderer will
       * automatically call this method. However, you might want to call this
       * method yourself for preloading or other purposes.
       * @api
       */
      load() {
        this.iconImage_.load();
      }
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      unlistenImageChange(listener) {
        this.iconImage_.removeEventListener(EventType_default.CHANGE, listener);
      }
    };
    Icon_default = Icon;
  }
});

// node_modules/ol/expr/expression.js
function typeName(type) {
  const names2 = [];
  for (const namedType of namedTypes) {
    if (includesType(type, namedType)) {
      names2.push(typeNames[namedType]);
    }
  }
  if (names2.length === 0) {
    return "untyped";
  }
  if (names2.length < 3) {
    return names2.join(" or ");
  }
  return names2.slice(0, -1).join(", ") + ", or " + names2[names2.length - 1];
}
function includesType(broad, specific) {
  return (broad & specific) === specific;
}
function overlapsType(oneType, otherType) {
  return !!(oneType & otherType);
}
function isType(type, expected) {
  return type === expected;
}
function newParsingContext() {
  return {
    variables: /* @__PURE__ */ new Set(),
    properties: /* @__PURE__ */ new Set(),
    featureId: false,
    style: {}
  };
}
function getTypeFromHint(typeHint) {
  switch (typeHint) {
    case "string":
      return StringType;
    case "color":
      return ColorType;
    case "number":
      return NumberType;
    case "boolean":
      return BooleanType;
    case "number[]":
      return NumberArrayType;
    default:
      throw new Error(`Unrecognized type hint: ${typeHint}`);
  }
}
function parse2(encoded, context, typeHint) {
  switch (typeof encoded) {
    case "boolean": {
      return new LiteralExpression(BooleanType, encoded);
    }
    case "number": {
      return new LiteralExpression(NumberType, encoded);
    }
    case "string": {
      let type2 = StringType;
      if (isStringColor(encoded)) {
        type2 |= ColorType;
      }
      if (!isType(type2 & typeHint, NoneType)) {
        type2 &= typeHint;
      }
      return new LiteralExpression(type2, encoded);
    }
    default: {
    }
  }
  if (!Array.isArray(encoded)) {
    throw new Error("Expression must be an array or a primitive value");
  }
  if (encoded.length === 0) {
    throw new Error("Empty expression");
  }
  if (typeof encoded[0] === "string") {
    return parseCallExpression(encoded, context, typeHint);
  }
  for (const item of encoded) {
    if (typeof item !== "number") {
      throw new Error("Expected an array of numbers");
    }
  }
  let type = NumberArrayType;
  if (encoded.length === 3 || encoded.length === 4) {
    type |= ColorType;
  }
  if (typeHint) {
    type &= typeHint;
  }
  return new LiteralExpression(type, encoded);
}
function withGetArgs(encoded, context) {
  const arg = parse2(encoded[1], context);
  if (!(arg instanceof LiteralExpression)) {
    throw new Error("Expected a literal argument for get operation");
  }
  if (typeof arg.value !== "string") {
    throw new Error("Expected a string argument for get operation");
  }
  context.properties.add(arg.value);
  if (encoded.length === 3) {
    const hint = parse2(encoded[2], context);
    return [arg, hint];
  }
  return [arg];
}
function withVarArgs(encoded, context, parsedArgs, typeHint) {
  const varName = encoded[1];
  if (typeof varName !== "string") {
    throw new Error("Expected a string argument for var operation");
  }
  context.variables.add(varName);
  if (!("variables" in context.style) || context.style.variables[varName] === void 0) {
    return [new LiteralExpression(AnyType, varName)];
  }
  const initialValue = context.style.variables[varName];
  const arg = (
    /** @type {LiteralExpression} */
    parse2(initialValue, context)
  );
  arg.value = varName;
  if (typeHint && !overlapsType(typeHint, arg.type)) {
    throw new Error(
      `The variable ${varName} has type ${typeName(
        arg.type
      )} but the following type was expected: ${typeName(typeHint)}`
    );
  }
  return [arg];
}
function usesFeatureId(encoded, context) {
  context.featureId = true;
}
function withNoArgs(encoded, context) {
  const operation = encoded[0];
  if (encoded.length !== 1) {
    throw new Error(`Expected no arguments for ${operation} operation`);
  }
  return [];
}
function withArgsCount(minArgs, maxArgs) {
  return function(encoded, context) {
    const operation = encoded[0];
    const argCount = encoded.length - 1;
    if (minArgs === maxArgs) {
      if (argCount !== minArgs) {
        const plural = minArgs === 1 ? "" : "s";
        throw new Error(
          `Expected ${minArgs} argument${plural} for ${operation}, got ${argCount}`
        );
      }
    } else if (argCount < minArgs || argCount > maxArgs) {
      const range = maxArgs === Infinity ? `${minArgs} or more` : `${minArgs} to ${maxArgs}`;
      throw new Error(
        `Expected ${range} arguments for ${operation}, got ${argCount}`
      );
    }
  };
}
function parseArgsOfType(argType) {
  return function(encoded, context) {
    const operation = encoded[0];
    const argCount = encoded.length - 1;
    const args = new Array(argCount);
    for (let i = 0; i < argCount; ++i) {
      const expression = parse2(encoded[i + 1], context);
      if (!overlapsType(argType, expression.type)) {
        const gotType = typeName(argType);
        const expectedType = typeName(expression.type);
        throw new Error(
          `Unexpected type for argument ${i} of ${operation} operation, got ${gotType} but expected ${expectedType}`
        );
      }
      expression.type &= argType;
      args[i] = expression;
    }
    return args;
  };
}
function narrowArgsType(encoded, context, parsedArgs) {
  const operation = encoded[0];
  const argCount = encoded.length - 1;
  let sameType = AnyType;
  for (let i = 0; i < parsedArgs.length; ++i) {
    sameType &= parsedArgs[i].type;
  }
  if (sameType === NoneType) {
    throw new Error(
      `No common type could be found for arguments of ${operation} operation`
    );
  }
  const args = new Array(argCount);
  for (let i = 0; i < argCount; ++i) {
    args[i] = parse2(encoded[i + 1], context, sameType);
  }
  return args;
}
function withOddArgs(encoded, context) {
  const operation = encoded[0];
  const argCount = encoded.length - 1;
  if (argCount % 2 === 0) {
    throw new Error(
      `An odd amount of arguments was expected for operation ${operation}, got ${JSON.stringify(
        argCount
      )} instead`
    );
  }
}
function withEvenArgs(encoded, context) {
  const operation = encoded[0];
  const argCount = encoded.length - 1;
  if (argCount % 2 === 1) {
    throw new Error(
      `An even amount of arguments was expected for operation ${operation}, got ${JSON.stringify(
        argCount
      )} instead`
    );
  }
}
function parseMatchArgs(encoded, context, parsedArgs, typeHint) {
  const argsCount = encoded.length - 1;
  const input = parse2(encoded[1], context);
  let inputType = input.type;
  const fallback = parse2(encoded[encoded.length - 1], context);
  let outputType = typeHint !== void 0 ? typeHint & fallback.type : fallback.type;
  const args = new Array(argsCount - 2);
  for (let i = 0; i < argsCount - 2; i += 2) {
    const match = parse2(encoded[i + 2], context);
    const output = parse2(encoded[i + 3], context);
    inputType &= match.type;
    outputType &= output.type;
    args[i] = match;
    args[i + 1] = output;
  }
  const expectedInputType = StringType | NumberType | BooleanType;
  if (!overlapsType(expectedInputType, inputType)) {
    throw new Error(
      `Expected an input of type ${typeName(
        expectedInputType
      )} for the interpolate operation, got ${typeName(inputType)} instead`
    );
  }
  if (isType(outputType, NoneType)) {
    throw new Error(
      `Could not find a common output type for the following match operation: ` + JSON.stringify(encoded)
    );
  }
  for (let i = 0; i < argsCount - 2; i += 2) {
    const match = parse2(encoded[i + 2], context, inputType);
    const output = parse2(encoded[i + 3], context, outputType);
    args[i] = match;
    args[i + 1] = output;
  }
  return [
    parse2(encoded[1], context, inputType),
    ...args,
    parse2(encoded[encoded.length - 1], context, outputType)
  ];
}
function parseInterpolateArgs(encoded, context, parsedArgs, typeHint) {
  const interpolationType = encoded[1];
  let interpolation;
  switch (interpolationType[0]) {
    case "linear":
      interpolation = 1;
      break;
    case "exponential":
      interpolation = interpolationType[1];
      if (typeof interpolation !== "number") {
        throw new Error(
          `Expected a number base for exponential interpolation, got ${JSON.stringify(interpolation)} instead`
        );
      }
      break;
    default:
      interpolation = null;
  }
  if (!interpolation) {
    throw new Error(
      `Invalid interpolation type: ${JSON.stringify(interpolationType)}`
    );
  }
  interpolation = parse2(interpolation, context);
  let input = parse2(encoded[2], context);
  if (!overlapsType(NumberType, input.type)) {
    throw new Error(
      `Expected an input of type number for the interpolate operation, got ${typeName(input.type)} instead`
    );
  }
  input = parse2(encoded[2], context, NumberType);
  const args = new Array(encoded.length - 3);
  for (let i = 0; i < args.length; i += 2) {
    let stop = parse2(encoded[i + 3], context);
    if (!overlapsType(NumberType, stop.type)) {
      throw new Error(
        `Expected all stop input values in the interpolate operation to be of type number, got ${typeName(stop.type)} at position ${i + 2} instead`
      );
    }
    let output = parse2(encoded[i + 4], context);
    if (!overlapsType(NumberType | ColorType, output.type)) {
      throw new Error(
        `Expected all stop output values in the interpolate operation to be a number or color, got ${typeName(output.type)} at position ${i + 3} instead`
      );
    }
    stop = parse2(encoded[i + 3], context, NumberType);
    output = parse2(encoded[i + 4], context, NumberType | ColorType);
    args[i] = stop;
    args[i + 1] = output;
  }
  return [interpolation, input, ...args];
}
function parseCaseArgs(encoded, context, parsedArgs, typeHint) {
  const fallback = parse2(encoded[encoded.length - 1], context);
  let outputType = typeHint !== void 0 ? typeHint & fallback.type : fallback.type;
  const args = new Array(encoded.length - 1);
  for (let i = 0; i < args.length - 1; i += 2) {
    const condition = parse2(encoded[i + 1], context);
    const output = parse2(encoded[i + 2], context);
    if (!overlapsType(BooleanType, condition.type)) {
      throw new Error(
        `Expected all conditions in the case operation to be of type boolean, got ${typeName(condition.type)} at position ${i} instead`
      );
    }
    outputType &= output.type;
    args[i] = condition;
    args[i + 1] = output;
  }
  if (isType(outputType, NoneType)) {
    throw new Error(
      `Could not find a common output type for the following case operation: ` + JSON.stringify(encoded)
    );
  }
  for (let i = 0; i < args.length - 1; i += 2) {
    args[i + 1] = parse2(encoded[i + 2], context, outputType);
  }
  args[args.length - 1] = parse2(
    encoded[encoded.length - 1],
    context,
    outputType
  );
  return args;
}
function parseInArgs(encoded, context) {
  let haystack = (
    /** @type {any} */
    encoded[2]
  );
  if (!Array.isArray(haystack)) {
    throw new Error(
      `The "in" operator was provided a literal value which was not an array as second argument.`
    );
  }
  if (typeof haystack[0] === "string") {
    if (haystack[0] !== "literal") {
      throw new Error(
        `For the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions.`
      );
    }
    if (!Array.isArray(haystack[1])) {
      throw new Error(
        `The "in" operator was provided a literal value which was not an array as second argument.`
      );
    }
    haystack = haystack[1];
  }
  let needleType = StringType | NumberType;
  const args = new Array(haystack.length);
  for (let i = 0; i < args.length; i++) {
    const arg = parse2(haystack[i], context);
    needleType &= arg.type;
    args[i] = arg;
  }
  if (isType(needleType, NoneType)) {
    throw new Error(
      `Could not find a common type for the following in operation: ` + JSON.stringify(encoded)
    );
  }
  const needle = parse2(encoded[1], context, needleType);
  return [needle, ...args];
}
function parsePaletteArgs(encoded, context) {
  const index = parse2(encoded[1], context, NumberType);
  if (index.type !== NumberType) {
    throw new Error(
      `The first argument of palette must be an number, got ${typeName(
        index.type
      )} instead`
    );
  }
  const colors = encoded[2];
  if (!Array.isArray(colors)) {
    throw new Error("The second argument of palette must be an array");
  }
  const parsedColors = new Array(colors.length);
  for (let i = 0; i < parsedColors.length; i++) {
    const color = parse2(colors[i], context, ColorType);
    if (!(color instanceof LiteralExpression)) {
      throw new Error(
        `The palette color at index ${i} must be a literal value`
      );
    }
    if (!overlapsType(color.type, ColorType)) {
      throw new Error(
        `The palette color at index ${i} should be of type color, got ${typeName(
          color.type
        )} instead`
      );
    }
    parsedColors[i] = color;
  }
  return [index, ...parsedColors];
}
function createParser(returnType, ...argValidators) {
  return function(encoded, context, typeHint) {
    const operator = encoded[0];
    let parsedArgs = [];
    for (let i = 0; i < argValidators.length; i++) {
      parsedArgs = argValidators[i](encoded, context, parsedArgs, typeHint) || parsedArgs;
    }
    let actualType = typeof returnType === "function" ? returnType(parsedArgs) : returnType;
    if (typeHint !== void 0) {
      if (!overlapsType(actualType, typeHint)) {
        throw new Error(
          `The following expression was expected to return ${typeName(
            typeHint
          )}, but returns ${typeName(actualType)} instead: ${JSON.stringify(
            encoded
          )}`
        );
      }
      actualType &= typeHint;
    }
    if (actualType === NoneType) {
      throw new Error(
        `No matching type was found for the following expression: ${JSON.stringify(
          encoded
        )}`
      );
    }
    return new CallExpression(actualType, operator, ...parsedArgs);
  };
}
function parseCallExpression(encoded, context, typeHint) {
  const operator = encoded[0];
  const parser = parsers[operator];
  if (!parser) {
    throw new Error(`Unknown operator: ${operator}`);
  }
  return parser(encoded, context, typeHint);
}
var numTypes, NoneType, BooleanType, NumberType, StringType, ColorType, NumberArrayType, AnyType, typeNames, namedTypes, LiteralExpression, CallExpression, Ops, parsers;
var init_expression = __esm({
  "node_modules/ol/expr/expression.js"() {
    init_array();
    init_color();
    numTypes = 0;
    NoneType = 0;
    BooleanType = 1 << numTypes++;
    NumberType = 1 << numTypes++;
    StringType = 1 << numTypes++;
    ColorType = 1 << numTypes++;
    NumberArrayType = 1 << numTypes++;
    AnyType = Math.pow(2, numTypes) - 1;
    typeNames = {
      [BooleanType]: "boolean",
      [NumberType]: "number",
      [StringType]: "string",
      [ColorType]: "color",
      [NumberArrayType]: "number[]"
    };
    namedTypes = Object.keys(typeNames).map(Number).sort(ascending);
    LiteralExpression = class {
      /**
       * @param {number} type The value type.
       * @param {LiteralValue} value The literal value.
       */
      constructor(type, value) {
        this.type = type;
        this.value = value;
      }
    };
    CallExpression = class {
      /**
       * @param {number} type The return type.
       * @param {string} operator The operator.
       * @param {...Expression} args The arguments.
       */
      constructor(type, operator, ...args) {
        this.type = type;
        this.operator = operator;
        this.args = args;
      }
    };
    Ops = {
      Get: "get",
      Var: "var",
      Concat: "concat",
      GeometryType: "geometry-type",
      Any: "any",
      All: "all",
      Not: "!",
      Resolution: "resolution",
      Zoom: "zoom",
      Time: "time",
      Equal: "==",
      NotEqual: "!=",
      GreaterThan: ">",
      GreaterThanOrEqualTo: ">=",
      LessThan: "<",
      LessThanOrEqualTo: "<=",
      Multiply: "*",
      Divide: "/",
      Add: "+",
      Subtract: "-",
      Clamp: "clamp",
      Mod: "%",
      Pow: "^",
      Abs: "abs",
      Floor: "floor",
      Ceil: "ceil",
      Round: "round",
      Sin: "sin",
      Cos: "cos",
      Atan: "atan",
      Sqrt: "sqrt",
      Match: "match",
      Between: "between",
      Interpolate: "interpolate",
      Case: "case",
      In: "in",
      Number: "number",
      String: "string",
      Array: "array",
      Color: "color",
      Id: "id",
      Band: "band",
      Palette: "palette"
    };
    parsers = {
      [Ops.Get]: createParser(
        ([_, typeHint]) => {
          if (typeHint !== void 0) {
            return getTypeFromHint(
              /** @type {string} */
              /** @type {LiteralExpression} */
              typeHint.value
            );
          }
          return AnyType;
        },
        withArgsCount(1, 2),
        withGetArgs
      ),
      [Ops.Var]: createParser(
        ([firstArg]) => firstArg.type,
        withArgsCount(1, 1),
        withVarArgs
      ),
      [Ops.Id]: createParser(NumberType | StringType, withNoArgs, usesFeatureId),
      [Ops.Concat]: createParser(
        StringType,
        withArgsCount(2, Infinity),
        parseArgsOfType(AnyType)
      ),
      [Ops.GeometryType]: createParser(StringType, withNoArgs),
      [Ops.Resolution]: createParser(NumberType, withNoArgs),
      [Ops.Zoom]: createParser(NumberType, withNoArgs),
      [Ops.Time]: createParser(NumberType, withNoArgs),
      [Ops.Any]: createParser(
        BooleanType,
        withArgsCount(2, Infinity),
        parseArgsOfType(BooleanType)
      ),
      [Ops.All]: createParser(
        BooleanType,
        withArgsCount(2, Infinity),
        parseArgsOfType(BooleanType)
      ),
      [Ops.Not]: createParser(
        BooleanType,
        withArgsCount(1, 1),
        parseArgsOfType(BooleanType)
      ),
      [Ops.Equal]: createParser(
        BooleanType,
        withArgsCount(2, 2),
        parseArgsOfType(AnyType),
        narrowArgsType
      ),
      [Ops.NotEqual]: createParser(
        BooleanType,
        withArgsCount(2, 2),
        parseArgsOfType(AnyType),
        narrowArgsType
      ),
      [Ops.GreaterThan]: createParser(
        BooleanType,
        withArgsCount(2, 2),
        parseArgsOfType(AnyType),
        narrowArgsType
      ),
      [Ops.GreaterThanOrEqualTo]: createParser(
        BooleanType,
        withArgsCount(2, 2),
        parseArgsOfType(AnyType),
        narrowArgsType
      ),
      [Ops.LessThan]: createParser(
        BooleanType,
        withArgsCount(2, 2),
        parseArgsOfType(AnyType),
        narrowArgsType
      ),
      [Ops.LessThanOrEqualTo]: createParser(
        BooleanType,
        withArgsCount(2, 2),
        parseArgsOfType(AnyType),
        narrowArgsType
      ),
      [Ops.Multiply]: createParser(
        (parsedArgs) => {
          let outputType = NumberType | ColorType;
          for (let i = 0; i < parsedArgs.length; i++) {
            outputType &= parsedArgs[i].type;
          }
          return outputType;
        },
        withArgsCount(2, Infinity),
        parseArgsOfType(NumberType | ColorType),
        narrowArgsType
      ),
      [Ops.Divide]: createParser(
        NumberType,
        withArgsCount(2, 2),
        parseArgsOfType(NumberType)
      ),
      [Ops.Add]: createParser(
        NumberType,
        withArgsCount(2, Infinity),
        parseArgsOfType(NumberType)
      ),
      [Ops.Subtract]: createParser(
        NumberType,
        withArgsCount(2, 2),
        parseArgsOfType(NumberType)
      ),
      [Ops.Clamp]: createParser(
        NumberType,
        withArgsCount(3, 3),
        parseArgsOfType(NumberType)
      ),
      [Ops.Mod]: createParser(
        NumberType,
        withArgsCount(2, 2),
        parseArgsOfType(NumberType)
      ),
      [Ops.Pow]: createParser(
        NumberType,
        withArgsCount(2, 2),
        parseArgsOfType(NumberType)
      ),
      [Ops.Abs]: createParser(
        NumberType,
        withArgsCount(1, 1),
        parseArgsOfType(NumberType)
      ),
      [Ops.Floor]: createParser(
        NumberType,
        withArgsCount(1, 1),
        parseArgsOfType(NumberType)
      ),
      [Ops.Ceil]: createParser(
        NumberType,
        withArgsCount(1, 1),
        parseArgsOfType(NumberType)
      ),
      [Ops.Round]: createParser(
        NumberType,
        withArgsCount(1, 1),
        parseArgsOfType(NumberType)
      ),
      [Ops.Sin]: createParser(
        NumberType,
        withArgsCount(1, 1),
        parseArgsOfType(NumberType)
      ),
      [Ops.Cos]: createParser(
        NumberType,
        withArgsCount(1, 1),
        parseArgsOfType(NumberType)
      ),
      [Ops.Atan]: createParser(
        NumberType,
        withArgsCount(1, 2),
        parseArgsOfType(NumberType)
      ),
      [Ops.Sqrt]: createParser(
        NumberType,
        withArgsCount(1, 1),
        parseArgsOfType(NumberType)
      ),
      [Ops.Match]: createParser(
        (parsedArgs) => {
          let type = AnyType;
          for (let i = 2; i < parsedArgs.length; i += 2) {
            type &= parsedArgs[i].type;
          }
          type &= parsedArgs[parsedArgs.length - 1].type;
          return type;
        },
        withArgsCount(4, Infinity),
        withEvenArgs,
        parseMatchArgs
      ),
      [Ops.Between]: createParser(
        BooleanType,
        withArgsCount(3, 3),
        parseArgsOfType(NumberType)
      ),
      [Ops.Interpolate]: createParser(
        (parsedArgs) => {
          let type = ColorType | NumberType;
          for (let i = 3; i < parsedArgs.length; i += 2) {
            type &= parsedArgs[i].type;
          }
          return type;
        },
        withArgsCount(6, Infinity),
        withEvenArgs,
        parseInterpolateArgs
      ),
      [Ops.Case]: createParser(
        (parsedArgs) => {
          let type = AnyType;
          for (let i = 1; i < parsedArgs.length; i += 2) {
            type &= parsedArgs[i].type;
          }
          type &= parsedArgs[parsedArgs.length - 1].type;
          return type;
        },
        withArgsCount(3, Infinity),
        withOddArgs,
        parseCaseArgs
      ),
      [Ops.In]: createParser(BooleanType, withArgsCount(2, 2), parseInArgs),
      [Ops.Number]: createParser(
        NumberType,
        withArgsCount(1, Infinity),
        parseArgsOfType(AnyType)
      ),
      [Ops.String]: createParser(
        StringType,
        withArgsCount(1, Infinity),
        parseArgsOfType(AnyType)
      ),
      [Ops.Array]: createParser(
        (parsedArgs) => {
          return parsedArgs.length === 3 || parsedArgs.length === 4 ? NumberArrayType | ColorType : NumberArrayType;
        },
        withArgsCount(1, Infinity),
        parseArgsOfType(NumberType)
      ),
      [Ops.Color]: createParser(
        ColorType,
        withArgsCount(3, 4),
        parseArgsOfType(NumberType)
      ),
      [Ops.Band]: createParser(
        NumberType,
        withArgsCount(1, 3),
        parseArgsOfType(NumberType)
      ),
      [Ops.Palette]: createParser(ColorType, withArgsCount(2, 2), parsePaletteArgs)
    };
  }
});

// node_modules/ol/expr/cpu.js
function newEvaluationContext() {
  return {
    variables: {},
    properties: {},
    resolution: NaN,
    featureId: null
  };
}
function buildExpression(encoded, type, context) {
  const expression = parse2(encoded, context);
  if (!overlapsType(type, expression.type)) {
    const expected = typeName(type);
    const actual = typeName(expression.type);
    throw new Error(
      `Expected expression to be of type ${expected}, got ${actual}`
    );
  }
  return compileExpression(expression, context);
}
function compileExpression(expression, context) {
  if (expression instanceof LiteralExpression) {
    if (expression.type === ColorType && typeof expression.value === "string") {
      const colorValue = fromString(expression.value);
      return function() {
        return colorValue;
      };
    }
    return function() {
      return expression.value;
    };
  }
  const operator = expression.operator;
  switch (operator) {
    case Ops.Number:
    case Ops.String: {
      return compileAssertionExpression(expression, context);
    }
    case Ops.Get:
    case Ops.Var: {
      return compileAccessorExpression(expression, context);
    }
    case Ops.Id: {
      return (expression2) => expression2.featureId;
    }
    case Ops.Concat: {
      const args = expression.args.map((e) => compileExpression(e, context));
      return (context2) => "".concat(...args.map((arg) => arg(context2).toString()));
    }
    case Ops.Resolution: {
      return (context2) => context2.resolution;
    }
    case Ops.Any:
    case Ops.All:
    case Ops.Not: {
      return compileLogicalExpression(expression, context);
    }
    case Ops.Equal:
    case Ops.NotEqual:
    case Ops.LessThan:
    case Ops.LessThanOrEqualTo:
    case Ops.GreaterThan:
    case Ops.GreaterThanOrEqualTo: {
      return compileComparisonExpression(expression, context);
    }
    case Ops.Multiply:
    case Ops.Divide:
    case Ops.Add:
    case Ops.Subtract:
    case Ops.Clamp:
    case Ops.Mod:
    case Ops.Pow:
    case Ops.Abs:
    case Ops.Floor:
    case Ops.Ceil:
    case Ops.Round:
    case Ops.Sin:
    case Ops.Cos:
    case Ops.Atan:
    case Ops.Sqrt: {
      return compileNumericExpression(expression, context);
    }
    case Ops.Match: {
      return compileMatchExpression(expression, context);
    }
    case Ops.Interpolate: {
      return compileInterpolateExpression(expression, context);
    }
    default: {
      throw new Error(`Unsupported operator ${operator}`);
    }
  }
}
function compileAssertionExpression(expression, context) {
  const type = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (type) {
    case Ops.Number:
    case Ops.String: {
      return (context2) => {
        for (let i = 0; i < length; ++i) {
          const value = args[i](context2);
          if (typeof value === type) {
            return value;
          }
        }
        throw new Error(`Expected one of the values to be a ${type}`);
      };
    }
    default: {
      throw new Error(`Unsupported assertion operator ${type}`);
    }
  }
}
function compileAccessorExpression(expression, context) {
  const nameExpression = (
    /** @type {LiteralExpression} */
    expression.args[0]
  );
  const name = (
    /** @type {string} */
    nameExpression.value
  );
  switch (expression.operator) {
    case Ops.Get: {
      return (context2) => context2.properties[name];
    }
    case Ops.Var: {
      return (context2) => context2.variables[name];
    }
    default: {
      throw new Error(`Unsupported accessor operator ${expression.operator}`);
    }
  }
}
function compileComparisonExpression(expression, context) {
  const op = expression.operator;
  const left = compileExpression(expression.args[0], context);
  const right = compileExpression(expression.args[1], context);
  switch (op) {
    case Ops.Equal: {
      return (context2) => left(context2) === right(context2);
    }
    case Ops.NotEqual: {
      return (context2) => left(context2) !== right(context2);
    }
    case Ops.LessThan: {
      return (context2) => left(context2) < right(context2);
    }
    case Ops.LessThanOrEqualTo: {
      return (context2) => left(context2) <= right(context2);
    }
    case Ops.GreaterThan: {
      return (context2) => left(context2) > right(context2);
    }
    case Ops.GreaterThanOrEqualTo: {
      return (context2) => left(context2) >= right(context2);
    }
    default: {
      throw new Error(`Unsupported comparison operator ${op}`);
    }
  }
}
function compileLogicalExpression(expression, context) {
  const op = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (op) {
    case Ops.Any: {
      return (context2) => {
        for (let i = 0; i < length; ++i) {
          if (args[i](context2)) {
            return true;
          }
        }
        return false;
      };
    }
    case Ops.All: {
      return (context2) => {
        for (let i = 0; i < length; ++i) {
          if (!args[i](context2)) {
            return false;
          }
        }
        return true;
      };
    }
    case Ops.Not: {
      return (context2) => !args[0](context2);
    }
    default: {
      throw new Error(`Unsupported logical operator ${op}`);
    }
  }
}
function compileNumericExpression(expression, context) {
  const op = expression.operator;
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  switch (op) {
    case Ops.Multiply: {
      return (context2) => {
        let value = 1;
        for (let i = 0; i < length; ++i) {
          value *= args[i](context2);
        }
        return value;
      };
    }
    case Ops.Divide: {
      return (context2) => args[0](context2) / args[1](context2);
    }
    case Ops.Add: {
      return (context2) => {
        let value = 0;
        for (let i = 0; i < length; ++i) {
          value += args[i](context2);
        }
        return value;
      };
    }
    case Ops.Subtract: {
      return (context2) => args[0](context2) - args[1](context2);
    }
    case Ops.Clamp: {
      return (context2) => {
        const value = args[0](context2);
        const min = args[1](context2);
        if (value < min) {
          return min;
        }
        const max = args[2](context2);
        if (value > max) {
          return max;
        }
        return value;
      };
    }
    case Ops.Mod: {
      return (context2) => args[0](context2) % args[1](context2);
    }
    case Ops.Pow: {
      return (context2) => Math.pow(args[0](context2), args[1](context2));
    }
    case Ops.Abs: {
      return (context2) => Math.abs(args[0](context2));
    }
    case Ops.Floor: {
      return (context2) => Math.floor(args[0](context2));
    }
    case Ops.Ceil: {
      return (context2) => Math.ceil(args[0](context2));
    }
    case Ops.Round: {
      return (context2) => Math.round(args[0](context2));
    }
    case Ops.Sin: {
      return (context2) => Math.sin(args[0](context2));
    }
    case Ops.Cos: {
      return (context2) => Math.cos(args[0](context2));
    }
    case Ops.Atan: {
      if (length === 2) {
        return (context2) => Math.atan2(args[0](context2), args[1](context2));
      }
      return (context2) => Math.atan(args[0](context2));
    }
    case Ops.Sqrt: {
      return (context2) => Math.sqrt(args[0](context2));
    }
    default: {
      throw new Error(`Unsupported numeric operator ${op}`);
    }
  }
}
function compileMatchExpression(expression, context) {
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  return (context2) => {
    const value = args[0](context2);
    for (let i = 1; i < length; i += 2) {
      if (value === args[i](context2)) {
        return args[i + 1](context2);
      }
    }
    return args[length - 1](context2);
  };
}
function compileInterpolateExpression(expression, context) {
  const length = expression.args.length;
  const args = new Array(length);
  for (let i = 0; i < length; ++i) {
    args[i] = compileExpression(expression.args[i], context);
  }
  return (context2) => {
    const base = args[0](context2);
    const value = args[1](context2);
    let previousInput;
    let previousOutput;
    for (let i = 2; i < length; i += 2) {
      const input = args[i](context2);
      let output = args[i + 1](context2);
      const isColor = Array.isArray(output);
      if (isColor) {
        output = withAlpha(output);
      }
      if (input >= value) {
        if (i === 2) {
          return output;
        }
        if (isColor) {
          return interpolateColor(
            base,
            value,
            previousInput,
            previousOutput,
            input,
            output
          );
        }
        return interpolateNumber(
          base,
          value,
          previousInput,
          previousOutput,
          input,
          output
        );
      }
      previousInput = input;
      previousOutput = output;
    }
    return previousOutput;
  };
}
function interpolateNumber(base, value, input1, output1, input2, output2) {
  const delta = input2 - input1;
  if (delta === 0) {
    return output1;
  }
  const along = value - input1;
  const factor = base === 1 ? along / delta : (Math.pow(base, along) - 1) / (Math.pow(base, delta) - 1);
  return output1 + factor * (output2 - output1);
}
function interpolateColor(base, value, input1, rgba1, input2, rgba2) {
  const delta = input2 - input1;
  if (delta === 0) {
    return rgba1;
  }
  const lcha1 = rgbaToLcha(rgba1);
  const lcha2 = rgbaToLcha(rgba2);
  let deltaHue = lcha2[2] - lcha1[2];
  if (deltaHue > 180) {
    deltaHue -= 360;
  } else if (deltaHue < -180) {
    deltaHue += 360;
  }
  const lcha = [
    interpolateNumber(base, value, input1, lcha1[0], input2, lcha2[0]),
    interpolateNumber(base, value, input1, lcha1[1], input2, lcha2[1]),
    lcha1[2] + interpolateNumber(base, value, input1, 0, input2, deltaHue),
    interpolateNumber(base, value, input1, rgba1[3], input2, rgba2[3])
  ];
  return normalize(lchaToRgba(lcha));
}
var init_cpu = __esm({
  "node_modules/ol/expr/cpu.js"() {
    init_expression();
    init_color();
  }
});

// node_modules/ol/render/canvas/style.js
function always2(context) {
  return true;
}
function rulesToStyleFunction(rules) {
  const parsingContext = newParsingContext();
  const evaluator = buildRuleSet(rules, parsingContext);
  const evaluationContext = newEvaluationContext();
  return function(feature, resolution) {
    evaluationContext.properties = feature.getPropertiesInternal();
    evaluationContext.resolution = resolution;
    if (parsingContext.featureId) {
      const id = feature.getId();
      if (id !== void 0) {
        evaluationContext.featureId = id;
      } else {
        evaluationContext.featureId = null;
      }
    }
    return evaluator(evaluationContext);
  };
}
function flatStylesToStyleFunction(flatStyles) {
  const parsingContext = newParsingContext();
  const length = flatStyles.length;
  const evaluators = new Array(length);
  for (let i = 0; i < length; ++i) {
    evaluators[i] = buildStyle(flatStyles[i], parsingContext);
  }
  const evaluationContext = newEvaluationContext();
  const styles = new Array(length);
  return function(feature, resolution) {
    evaluationContext.properties = feature.getPropertiesInternal();
    evaluationContext.resolution = resolution;
    if (parsingContext.featureId) {
      const id = feature.getId();
      if (id !== void 0) {
        evaluationContext.featureId = id;
      } else {
        evaluationContext.featureId = null;
      }
    }
    let nonNullCount = 0;
    for (let i = 0; i < length; ++i) {
      const style = evaluators[i](evaluationContext);
      if (style) {
        styles[nonNullCount] = style;
        nonNullCount += 1;
      }
    }
    styles.length = nonNullCount;
    return styles;
  };
}
function buildRuleSet(rules, context) {
  const length = rules.length;
  const compiledRules = new Array(length);
  for (let i = 0; i < length; ++i) {
    const rule = rules[i];
    const filter = "filter" in rule ? buildExpression(rule.filter, BooleanType, context) : always2;
    let styles;
    if (Array.isArray(rule.style)) {
      const styleLength = rule.style.length;
      styles = new Array(styleLength);
      for (let j = 0; j < styleLength; ++j) {
        styles[j] = buildStyle(rule.style[j], context);
      }
    } else {
      styles = [buildStyle(rule.style, context)];
    }
    compiledRules[i] = { filter, styles };
  }
  return function(context2) {
    const styles = [];
    let someMatched = false;
    for (let i = 0; i < length; ++i) {
      const filterEvaluator = compiledRules[i].filter;
      if (!filterEvaluator(context2)) {
        continue;
      }
      if (rules[i].else && someMatched) {
        continue;
      }
      someMatched = true;
      for (const styleEvaluator of compiledRules[i].styles) {
        const style = styleEvaluator(context2);
        if (!style) {
          continue;
        }
        styles.push(style);
      }
    }
    return styles;
  };
}
function buildStyle(flatStyle, context) {
  const evaluateFill = buildFill(flatStyle, "", context);
  const evaluateStroke = buildStroke(flatStyle, "", context);
  const evaluateText = buildText(flatStyle, context);
  const evaluateImage = buildImage(flatStyle, context);
  const evaluateZIndex = numberEvaluator(flatStyle, "z-index", context);
  if (!evaluateFill && !evaluateStroke && !evaluateText && !evaluateImage && !isEmpty(flatStyle)) {
    throw new Error(
      "No fill, stroke, point, or text symbolizer properties in style: " + JSON.stringify(flatStyle)
    );
  }
  const style = new Style_default();
  return function(context2) {
    let empty = true;
    if (evaluateFill) {
      const fill = evaluateFill(context2);
      if (fill) {
        empty = false;
      }
      style.setFill(fill);
    }
    if (evaluateStroke) {
      const stroke = evaluateStroke(context2);
      if (stroke) {
        empty = false;
      }
      style.setStroke(stroke);
    }
    if (evaluateText) {
      const text = evaluateText(context2);
      if (text) {
        empty = false;
      }
      style.setText(text);
    }
    if (evaluateImage) {
      const image = evaluateImage(context2);
      if (image) {
        empty = false;
      }
      style.setImage(image);
    }
    if (evaluateZIndex) {
      style.setZIndex(evaluateZIndex(context2));
    }
    if (empty) {
      return null;
    }
    return style;
  };
}
function buildFill(flatStyle, prefix, context) {
  const evaluateColor = colorLikeEvaluator(
    flatStyle,
    prefix + "fill-color",
    context
  );
  if (!evaluateColor) {
    return null;
  }
  const fill = new Fill_default();
  return function(context2) {
    const color = evaluateColor(context2);
    if (color === "none") {
      return null;
    }
    fill.setColor(color);
    return fill;
  };
}
function buildStroke(flatStyle, prefix, context) {
  const evaluateWidth = numberEvaluator(
    flatStyle,
    prefix + "stroke-width",
    context
  );
  const evaluateColor = colorLikeEvaluator(
    flatStyle,
    prefix + "stroke-color",
    context
  );
  if (!evaluateWidth && !evaluateColor) {
    return null;
  }
  const evaluateLineCap = stringEvaluator(
    flatStyle,
    prefix + "stroke-line-cap",
    context
  );
  const evaluateLineJoin = stringEvaluator(
    flatStyle,
    prefix + "stroke-line-join",
    context
  );
  const evaluateLineDash = numberArrayEvaluator(
    flatStyle,
    prefix + "stroke-line-dash",
    context
  );
  const evaluateLineDashOffset = numberEvaluator(
    flatStyle,
    prefix + "stroke-line-dash-offset",
    context
  );
  const evaluateMiterLimit = numberEvaluator(
    flatStyle,
    prefix + "stroke-miter-limit",
    context
  );
  const stroke = new Stroke_default();
  return function(context2) {
    if (evaluateColor) {
      const color = evaluateColor(context2);
      if (color === "none") {
        return null;
      }
      stroke.setColor(color);
    }
    if (evaluateWidth) {
      stroke.setWidth(evaluateWidth(context2));
    }
    if (evaluateLineCap) {
      const lineCap = evaluateLineCap(context2);
      if (lineCap !== "butt" && lineCap !== "round" && lineCap !== "square") {
        throw new Error("Expected butt, round, or square line cap");
      }
      stroke.setLineCap(lineCap);
    }
    if (evaluateLineJoin) {
      const lineJoin = evaluateLineJoin(context2);
      if (lineJoin !== "bevel" && lineJoin !== "round" && lineJoin !== "miter") {
        throw new Error("Expected bevel, round, or miter line join");
      }
      stroke.setLineJoin(lineJoin);
    }
    if (evaluateLineDash) {
      stroke.setLineDash(evaluateLineDash(context2));
    }
    if (evaluateLineDashOffset) {
      stroke.setLineDashOffset(evaluateLineDashOffset(context2));
    }
    if (evaluateMiterLimit) {
      stroke.setMiterLimit(evaluateMiterLimit(context2));
    }
    return stroke;
  };
}
function buildText(flatStyle, context) {
  const prefix = "text-";
  const evaluateValue = stringEvaluator(flatStyle, prefix + "value", context);
  if (!evaluateValue) {
    return null;
  }
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateBackgroundFill = buildFill(
    flatStyle,
    prefix + "background-",
    context
  );
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateBackgroundStroke = buildStroke(
    flatStyle,
    prefix + "background-",
    context
  );
  const evaluateFont = stringEvaluator(flatStyle, prefix + "font", context);
  const evaluateMaxAngle = numberEvaluator(
    flatStyle,
    prefix + "max-angle",
    context
  );
  const evaluateOffsetX = numberEvaluator(
    flatStyle,
    prefix + "offset-x",
    context
  );
  const evaluateOffsetY = numberEvaluator(
    flatStyle,
    prefix + "offset-y",
    context
  );
  const evaluateOverflow = booleanEvaluator(
    flatStyle,
    prefix + "overflow",
    context
  );
  const evaluatePlacement = stringEvaluator(
    flatStyle,
    prefix + "placement",
    context
  );
  const evaluateRepeat = numberEvaluator(flatStyle, prefix + "repeat", context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateAlign = stringEvaluator(flatStyle, prefix + "align", context);
  const evaluateJustify = stringEvaluator(
    flatStyle,
    prefix + "justify",
    context
  );
  const evaluateBaseline = stringEvaluator(
    flatStyle,
    prefix + "baseline",
    context
  );
  const evaluatePadding = numberArrayEvaluator(
    flatStyle,
    prefix + "padding",
    context
  );
  const text = new Text_default({});
  return function(context2) {
    text.setText(evaluateValue(context2));
    if (evaluateFill) {
      text.setFill(evaluateFill(context2));
    }
    if (evaluateBackgroundFill) {
      text.setBackgroundFill(evaluateBackgroundFill(context2));
    }
    if (evaluateStroke) {
      text.setStroke(evaluateStroke(context2));
    }
    if (evaluateBackgroundStroke) {
      text.setBackgroundStroke(evaluateBackgroundStroke(context2));
    }
    if (evaluateFont) {
      text.setFont(evaluateFont(context2));
    }
    if (evaluateMaxAngle) {
      text.setMaxAngle(evaluateMaxAngle(context2));
    }
    if (evaluateOffsetX) {
      text.setOffsetX(evaluateOffsetX(context2));
    }
    if (evaluateOffsetY) {
      text.setOffsetY(evaluateOffsetY(context2));
    }
    if (evaluateOverflow) {
      text.setOverflow(evaluateOverflow(context2));
    }
    if (evaluatePlacement) {
      const placement = evaluatePlacement(context2);
      if (placement !== "point" && placement !== "line") {
        throw new Error("Expected point or line for text-placement");
      }
      text.setPlacement(placement);
    }
    if (evaluateRepeat) {
      text.setRepeat(evaluateRepeat(context2));
    }
    if (evaluateScale) {
      text.setScale(evaluateScale(context2));
    }
    if (evaluateRotateWithView) {
      text.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateRotation) {
      text.setRotation(evaluateRotation(context2));
    }
    if (evaluateAlign) {
      const textAlign = evaluateAlign(context2);
      if (textAlign !== "left" && textAlign !== "center" && textAlign !== "right" && textAlign !== "end" && textAlign !== "start") {
        throw new Error(
          "Expected left, right, center, start, or end for text-align"
        );
      }
      text.setTextAlign(textAlign);
    }
    if (evaluateJustify) {
      const justify = evaluateJustify(context2);
      if (justify !== "left" && justify !== "right" && justify !== "center") {
        throw new Error("Expected left, right, or center for text-justify");
      }
      text.setJustify(justify);
    }
    if (evaluateBaseline) {
      const textBaseline = evaluateBaseline(context2);
      if (textBaseline !== "bottom" && textBaseline !== "top" && textBaseline !== "middle" && textBaseline !== "alphabetic" && textBaseline !== "hanging") {
        throw new Error(
          "Expected bottom, top, middle, alphabetic, or hanging for text-baseline"
        );
      }
      text.setTextBaseline(textBaseline);
    }
    if (evaluatePadding) {
      text.setPadding(evaluatePadding(context2));
    }
    return text;
  };
}
function buildImage(flatStyle, context) {
  if ("icon-src" in flatStyle) {
    return buildIcon(flatStyle, context);
  }
  if ("shape-points" in flatStyle) {
    return buildShape(flatStyle, context);
  }
  if ("circle-radius" in flatStyle) {
    return buildCircle(flatStyle, context);
  }
  return null;
}
function buildIcon(flatStyle, context) {
  const prefix = "icon-";
  const srcName = prefix + "src";
  const src = requireString(flatStyle[srcName], srcName);
  const evaluateAnchor = coordinateEvaluator(
    flatStyle,
    prefix + "anchor",
    context
  );
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateOpacity = numberEvaluator(
    flatStyle,
    prefix + "opacity",
    context
  );
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + "displacement",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const anchorOrigin = optionalIconOrigin(flatStyle, prefix + "anchor-origin");
  const anchorXUnits = optionalIconAnchorUnits(
    flatStyle,
    prefix + "anchor-x-units"
  );
  const anchorYUnits = optionalIconAnchorUnits(
    flatStyle,
    prefix + "anchor-y-units"
  );
  const color = optionalColorLike(flatStyle, prefix + "color");
  const crossOrigin = optionalString(flatStyle, prefix + "cross-origin");
  const offset2 = optionalNumberArray(flatStyle, prefix + "offset");
  const offsetOrigin = optionalIconOrigin(flatStyle, prefix + "offset-origin");
  const width = optionalNumber(flatStyle, prefix + "width");
  const height = optionalNumber(flatStyle, prefix + "height");
  const size = optionalSize(flatStyle, prefix + "size");
  const declutterMode = optionalDeclutterMode(flatStyle, prefix + "declutter");
  const icon = new Icon_default({
    src,
    anchorOrigin,
    anchorXUnits,
    anchorYUnits,
    color,
    crossOrigin,
    offset: offset2,
    offsetOrigin,
    height,
    width,
    size,
    declutterMode
  });
  return function(context2) {
    if (evaluateOpacity) {
      icon.setOpacity(evaluateOpacity(context2));
    }
    if (evaluateDisplacement) {
      icon.setDisplacement(evaluateDisplacement(context2));
    }
    if (evaluateRotation) {
      icon.setRotation(evaluateRotation(context2));
    }
    if (evaluateRotateWithView) {
      icon.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateScale) {
      icon.setScale(evaluateScale(context2));
    }
    if (evaluateAnchor) {
      icon.setAnchor(evaluateAnchor(context2));
    }
    return icon;
  };
}
function buildShape(flatStyle, context) {
  const prefix = "shape-";
  const pointsName = prefix + "points";
  const points = requireNumber(flatStyle[pointsName], pointsName);
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + "displacement",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const radius = optionalNumber(flatStyle, prefix + "radius");
  const radius1 = optionalNumber(flatStyle, prefix + "radius1");
  const radius2 = optionalNumber(flatStyle, prefix + "radius2");
  const angle = optionalNumber(flatStyle, prefix + "angle");
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + "declutter-mode"
  );
  const shape = new RegularShape_default({
    points,
    radius,
    radius1,
    radius2,
    angle,
    declutterMode
  });
  return function(context2) {
    if (evaluateFill) {
      shape.setFill(evaluateFill(context2));
    }
    if (evaluateStroke) {
      shape.setStroke(evaluateStroke(context2));
    }
    if (evaluateDisplacement) {
      shape.setDisplacement(evaluateDisplacement(context2));
    }
    if (evaluateRotation) {
      shape.setRotation(evaluateRotation(context2));
    }
    if (evaluateRotateWithView) {
      shape.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateScale) {
      shape.setScale(evaluateScale(context2));
    }
    return shape;
  };
}
function buildCircle(flatStyle, context) {
  const prefix = "circle-";
  const evaluateFill = buildFill(flatStyle, prefix, context);
  const evaluateStroke = buildStroke(flatStyle, prefix, context);
  const evaluateRadius = numberEvaluator(flatStyle, prefix + "radius", context);
  const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
  const evaluateDisplacement = coordinateEvaluator(
    flatStyle,
    prefix + "displacement",
    context
  );
  const evaluateRotation = numberEvaluator(
    flatStyle,
    prefix + "rotation",
    context
  );
  const evaluateRotateWithView = booleanEvaluator(
    flatStyle,
    prefix + "rotate-with-view",
    context
  );
  const declutterMode = optionalDeclutterMode(
    flatStyle,
    prefix + "declutter-mode"
  );
  const circle = new Circle_default({
    radius: 5,
    // this is arbitrary, but required - the evaluated radius is used below
    declutterMode
  });
  return function(context2) {
    if (evaluateRadius) {
      circle.setRadius(evaluateRadius(context2));
    }
    if (evaluateFill) {
      circle.setFill(evaluateFill(context2));
    }
    if (evaluateStroke) {
      circle.setStroke(evaluateStroke(context2));
    }
    if (evaluateDisplacement) {
      circle.setDisplacement(evaluateDisplacement(context2));
    }
    if (evaluateRotation) {
      circle.setRotation(evaluateRotation(context2));
    }
    if (evaluateRotateWithView) {
      circle.setRotateWithView(evaluateRotateWithView(context2));
    }
    if (evaluateScale) {
      circle.setScale(evaluateScale(context2));
    }
    return circle;
  };
}
function numberEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return void 0;
  }
  const evaluator = buildExpression(flatStyle[name], NumberType, context);
  return function(context2) {
    return requireNumber(evaluator(context2), name);
  };
}
function stringEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], StringType, context);
  return function(context2) {
    return requireString(evaluator(context2), name);
  };
}
function booleanEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], BooleanType, context);
  return function(context2) {
    const value = evaluator(context2);
    if (typeof value !== "boolean") {
      throw new Error(`Expected a boolean for ${name}`);
    }
    return value;
  };
}
function colorLikeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(
    flatStyle[name],
    ColorType | StringType,
    context
  );
  return function(context2) {
    return requireColorLike(evaluator(context2), name);
  };
}
function numberArrayEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);
  return function(context2) {
    return requireNumberArray(evaluator(context2), name);
  };
}
function coordinateEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);
  return function(context2) {
    const array = requireNumberArray(evaluator(context2), name);
    if (array.length !== 2) {
      throw new Error(`Expected two numbers for ${name}`);
    }
    return array;
  };
}
function sizeLikeEvaluator(flatStyle, name, context) {
  if (!(name in flatStyle)) {
    return null;
  }
  const evaluator = buildExpression(
    flatStyle[name],
    NumberArrayType | NumberType,
    context
  );
  return function(context2) {
    return requireSizeLike(evaluator(context2), name);
  };
}
function optionalNumber(flatStyle, property) {
  const value = flatStyle[property];
  if (value === void 0) {
    return void 0;
  }
  if (typeof value !== "number") {
    throw new Error(`Expected a number for ${property}`);
  }
  return value;
}
function optionalSize(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (typeof encoded === "number") {
    return toSize(encoded);
  }
  if (!Array.isArray(encoded)) {
    throw new Error(`Expected a number or size array for ${property}`);
  }
  if (encoded.length !== 2 || typeof encoded[0] !== "number" || typeof encoded[1] !== "number") {
    throw new Error(`Expected a number or size array for ${property}`);
  }
  return encoded;
}
function optionalString(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (typeof encoded !== "string") {
    throw new Error(`Expected a string for ${property}`);
  }
  return encoded;
}
function optionalIconOrigin(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (encoded !== "bottom-left" && encoded !== "bottom-right" && encoded !== "top-left" && encoded !== "top-right") {
    throw new Error(
      `Expected bottom-left, bottom-right, top-left, or top-right for ${property}`
    );
  }
  return encoded;
}
function optionalIconAnchorUnits(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (encoded !== "pixels" && encoded !== "fraction") {
    throw new Error(`Expected pixels or fraction for ${property}`);
  }
  return encoded;
}
function optionalNumberArray(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  return requireNumberArray(encoded, property);
}
function optionalDeclutterMode(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  if (typeof encoded !== "string") {
    throw new Error(`Expected a string for ${property}`);
  }
  if (encoded !== "declutter" && encoded !== "obstacle" && encoded !== "none") {
    throw new Error(`Expected declutter, obstacle, or none for ${property}`);
  }
  return encoded;
}
function optionalColorLike(flatStyle, property) {
  const encoded = flatStyle[property];
  if (encoded === void 0) {
    return void 0;
  }
  return requireColorLike(encoded, property);
}
function requireNumberArray(value, property) {
  if (!Array.isArray(value)) {
    throw new Error(`Expected an array for ${property}`);
  }
  const length = value.length;
  for (let i = 0; i < length; ++i) {
    if (typeof value[i] !== "number") {
      throw new Error(`Expected an array of numbers for ${property}`);
    }
  }
  return value;
}
function requireString(value, property) {
  if (typeof value !== "string") {
    throw new Error(`Expected a string for ${property}`);
  }
  return value;
}
function requireNumber(value, property) {
  if (typeof value !== "number") {
    throw new Error(`Expected a number for ${property}`);
  }
  return value;
}
function requireColorLike(value, property) {
  if (typeof value === "string") {
    return value;
  }
  const array = requireNumberArray(value, property);
  const length = array.length;
  if (length < 3 || length > 4) {
    throw new Error(`Expected a color with 3 or 4 values for ${property}`);
  }
  return array;
}
function requireSizeLike(value, property) {
  if (typeof value === "number") {
    return value;
  }
  const size = requireNumberArray(value, property);
  if (size.length !== 2) {
    throw new Error(`Expected an array of two numbers for ${property}`);
  }
  return size;
}
var init_style = __esm({
  "node_modules/ol/render/canvas/style.js"() {
    init_Circle();
    init_Fill();
    init_Icon();
    init_RegularShape();
    init_Stroke();
    init_Style();
    init_Text();
    init_expression();
    init_cpu();
    init_obj();
    init_size();
  }
});

// node_modules/ol/layer/BaseVector.js
function toStyleLike(style) {
  if (style === void 0) {
    return createDefaultStyle;
  }
  if (!style) {
    return null;
  }
  if (typeof style === "function") {
    return style;
  }
  if (style instanceof Style_default) {
    return style;
  }
  if (!Array.isArray(style)) {
    return flatStylesToStyleFunction([style]);
  }
  if (style.length === 0) {
    return [];
  }
  const length = style.length;
  const first = style[0];
  if (first instanceof Style_default) {
    const styles = new Array(length);
    for (let i = 0; i < length; ++i) {
      const candidate = style[i];
      if (!(candidate instanceof Style_default)) {
        throw new Error("Expected a list of style instances");
      }
      styles[i] = candidate;
    }
    return styles;
  }
  if ("style" in first) {
    const rules = new Array(length);
    for (let i = 0; i < length; ++i) {
      const candidate = style[i];
      if (!("style" in candidate)) {
        throw new Error("Expected a list of rules with a style property");
      }
      rules[i] = candidate;
    }
    return rulesToStyleFunction(rules);
  }
  const flatStyles = (
    /** @type {Array<import("../style/flat.js").FlatStyle>} */
    style
  );
  return flatStylesToStyleFunction(flatStyles);
}
var Property3, BaseVectorLayer, BaseVector_default;
var init_BaseVector = __esm({
  "node_modules/ol/layer/BaseVector.js"() {
    init_Layer();
    init_rbush();
    init_Style();
    init_style();
    Property3 = {
      RENDER_ORDER: "renderOrder"
    };
    BaseVectorLayer = class extends Layer_default {
      /**
       * @param {Options<VectorSourceType>} [options] Options.
       */
      constructor(options) {
        options = options ? options : {};
        const baseOptions = Object.assign({}, options);
        delete baseOptions.style;
        delete baseOptions.renderBuffer;
        delete baseOptions.updateWhileAnimating;
        delete baseOptions.updateWhileInteracting;
        super(baseOptions);
        this.declutter_ = options.declutter !== void 0 ? options.declutter : false;
        this.renderBuffer_ = options.renderBuffer !== void 0 ? options.renderBuffer : 100;
        this.style_ = null;
        this.styleFunction_ = void 0;
        this.setStyle(options.style);
        this.updateWhileAnimating_ = options.updateWhileAnimating !== void 0 ? options.updateWhileAnimating : false;
        this.updateWhileInteracting_ = options.updateWhileInteracting !== void 0 ? options.updateWhileInteracting : false;
      }
      /**
       * @return {boolean} Declutter.
       */
      getDeclutter() {
        return this.declutter_;
      }
      /**
       * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
       * that resolves with an array of features. The array will either contain the topmost feature
       * when a hit was detected, or it will be empty.
       *
       * The hit detection algorithm used for this method is optimized for performance, but is less
       * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
       * Text is not considered, and icons are only represented by their bounding box instead of the exact
       * image.
       *
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
       * @api
       */
      getFeatures(pixel) {
        return super.getFeatures(pixel);
      }
      /**
       * @return {number|undefined} Render buffer.
       */
      getRenderBuffer() {
        return this.renderBuffer_;
      }
      /**
       * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
       *     order.
       */
      getRenderOrder() {
        return (
          /** @type {import("../render.js").OrderFunction|null|undefined} */
          this.get(Property3.RENDER_ORDER)
        );
      }
      /**
       * Get the style for features.  This returns whatever was passed to the `style`
       * option at construction or to the `setStyle` method.
       * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
       * @api
       */
      getStyle() {
        return this.style_;
      }
      /**
       * Get the style function.
       * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
       * @api
       */
      getStyleFunction() {
        return this.styleFunction_;
      }
      /**
       * @return {boolean} Whether the rendered layer should be updated while
       *     animating.
       */
      getUpdateWhileAnimating() {
        return this.updateWhileAnimating_;
      }
      /**
       * @return {boolean} Whether the rendered layer should be updated while
       *     interacting.
       */
      getUpdateWhileInteracting() {
        return this.updateWhileInteracting_;
      }
      /**
       * Render declutter items for this layer
       * @param {import("../Map.js").FrameState} frameState Frame state.
       */
      renderDeclutter(frameState) {
        if (!frameState.declutterTree) {
          frameState.declutterTree = new RBush(9);
        }
        this.getRenderer().renderDeclutter(frameState);
      }
      /**
       * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
       *     Render order.
       */
      setRenderOrder(renderOrder) {
        this.set(Property3.RENDER_ORDER, renderOrder);
      }
      /**
       * Set the style for features.  This can be a single style object, an array
       * of styles, or a function that takes a feature and resolution and returns
       * an array of styles. If set to `null`, the layer has no style (a `null` style),
       * so only features that have their own styles will be rendered in the layer. Call
       * `setStyle()` without arguments to reset to the default style. See
       * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
       *
       * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
       * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
       * ```js
       * vectorLayer.setStyle({
       *   "fill-color": "yellow",
       *   "stroke-color": "black",
       *   "stroke-width": 4
       * })
       * ```
       *
       * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
       * @api
       */
      setStyle(style) {
        this.style_ = toStyleLike(style);
        this.styleFunction_ = style === null ? void 0 : toFunction(this.style_);
        this.changed();
      }
    };
    BaseVector_default = BaseVectorLayer;
  }
});

// node_modules/ol/render/canvas/Instruction.js
var Instruction, fillInstruction, strokeInstruction, beginPathInstruction, closePathInstruction, Instruction_default;
var init_Instruction = __esm({
  "node_modules/ol/render/canvas/Instruction.js"() {
    Instruction = {
      BEGIN_GEOMETRY: 0,
      BEGIN_PATH: 1,
      CIRCLE: 2,
      CLOSE_PATH: 3,
      CUSTOM: 4,
      DRAW_CHARS: 5,
      DRAW_IMAGE: 6,
      END_GEOMETRY: 7,
      FILL: 8,
      MOVE_TO_LINE_TO: 9,
      SET_FILL_STYLE: 10,
      SET_STROKE_STYLE: 11,
      STROKE: 12
    };
    fillInstruction = [Instruction.FILL];
    strokeInstruction = [Instruction.STROKE];
    beginPathInstruction = [Instruction.BEGIN_PATH];
    closePathInstruction = [Instruction.CLOSE_PATH];
    Instruction_default = Instruction;
  }
});

// node_modules/ol/render/VectorContext.js
var VectorContext, VectorContext_default;
var init_VectorContext = __esm({
  "node_modules/ol/render/VectorContext.js"() {
    VectorContext = class {
      /**
       * Render a geometry with a custom renderer.
       *
       * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {Function} renderer Renderer.
       * @param {Function} hitDetectionRenderer Renderer.
       */
      drawCustom(geometry, feature, renderer, hitDetectionRenderer) {
      }
      /**
       * Render a geometry.
       *
       * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
       */
      drawGeometry(geometry) {
      }
      /**
       * Set the rendering style.
       *
       * @param {import("../style/Style.js").default} style The rendering style.
       */
      setStyle(style) {
      }
      /**
       * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
       * @param {import("../Feature.js").default} feature Feature.
       */
      drawCircle(circleGeometry, feature) {
      }
      /**
       * @param {import("../Feature.js").default} feature Feature.
       * @param {import("../style/Style.js").default} style Style.
       */
      drawFeature(feature, style) {
      }
      /**
       * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
       * @param {import("../Feature.js").default} feature Feature.
       */
      drawGeometryCollection(geometryCollectionGeometry, feature) {
      }
      /**
       * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      drawLineString(lineStringGeometry, feature) {
      }
      /**
       * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      drawMultiLineString(multiLineStringGeometry, feature) {
      }
      /**
       * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      drawMultiPoint(multiPointGeometry, feature) {
      }
      /**
       * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      drawMultiPolygon(multiPolygonGeometry, feature) {
      }
      /**
       * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      drawPoint(pointGeometry, feature) {
      }
      /**
       * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      drawPolygon(polygonGeometry, feature) {
      }
      /**
       * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      drawText(geometry, feature) {
      }
      /**
       * @param {import("../style/Fill.js").default} fillStyle Fill style.
       * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
       */
      setFillStrokeStyle(fillStyle, strokeStyle) {
      }
      /**
       * @param {import("../style/Image.js").default} imageStyle Image style.
       * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
       */
      setImageStyle(imageStyle, declutterImageWithText) {
      }
      /**
       * @param {import("../style/Text.js").default} textStyle Text style.
       * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
       */
      setTextStyle(textStyle, declutterImageWithText) {
      }
    };
    VectorContext_default = VectorContext;
  }
});

// node_modules/ol/render/canvas/Builder.js
var CanvasBuilder, Builder_default;
var init_Builder = __esm({
  "node_modules/ol/render/canvas/Builder.js"() {
    init_Instruction();
    init_Relationship();
    init_VectorContext();
    init_colorlike();
    init_extent();
    init_canvas();
    init_array();
    init_inflate();
    CanvasBuilder = class extends VectorContext_default {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      constructor(tolerance, maxExtent, resolution, pixelRatio) {
        super();
        this.tolerance = tolerance;
        this.maxExtent = maxExtent;
        this.pixelRatio = pixelRatio;
        this.maxLineWidth = 0;
        this.resolution = resolution;
        this.beginGeometryInstruction1_ = null;
        this.beginGeometryInstruction2_ = null;
        this.bufferedMaxExtent_ = null;
        this.instructions = [];
        this.coordinates = [];
        this.tmpCoordinate_ = [];
        this.hitDetectionInstructions = [];
        this.state = /** @type {import("../canvas.js").FillStrokeState} */
        {};
      }
      /**
       * @protected
       * @param {Array<number>} dashArray Dash array.
       * @return {Array<number>} Dash array with pixel ratio applied
       */
      applyPixelRatio(dashArray) {
        const pixelRatio = this.pixelRatio;
        return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {
          return dash * pixelRatio;
        });
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} stride Stride.
       * @protected
       * @return {number} My end
       */
      appendFlatPointCoordinates(flatCoordinates, stride) {
        const extent = this.getBufferedMaxExtent();
        const tmpCoord = this.tmpCoordinate_;
        const coordinates2 = this.coordinates;
        let myEnd = coordinates2.length;
        for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
          tmpCoord[0] = flatCoordinates[i];
          tmpCoord[1] = flatCoordinates[i + 1];
          if (containsCoordinate(extent, tmpCoord)) {
            coordinates2[myEnd++] = tmpCoord[0];
            coordinates2[myEnd++] = tmpCoord[1];
          }
        }
        return myEnd;
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @param {boolean} closed Last input coordinate equals first.
       * @param {boolean} skipFirst Skip first coordinate.
       * @protected
       * @return {number} My end.
       */
      appendFlatLineCoordinates(flatCoordinates, offset2, end, stride, closed, skipFirst) {
        const coordinates2 = this.coordinates;
        let myEnd = coordinates2.length;
        const extent = this.getBufferedMaxExtent();
        if (skipFirst) {
          offset2 += stride;
        }
        let lastXCoord = flatCoordinates[offset2];
        let lastYCoord = flatCoordinates[offset2 + 1];
        const nextCoord = this.tmpCoordinate_;
        let skipped = true;
        let i, lastRel, nextRel;
        for (i = offset2 + stride; i < end; i += stride) {
          nextCoord[0] = flatCoordinates[i];
          nextCoord[1] = flatCoordinates[i + 1];
          nextRel = coordinateRelationship(extent, nextCoord);
          if (nextRel !== lastRel) {
            if (skipped) {
              coordinates2[myEnd++] = lastXCoord;
              coordinates2[myEnd++] = lastYCoord;
              skipped = false;
            }
            coordinates2[myEnd++] = nextCoord[0];
            coordinates2[myEnd++] = nextCoord[1];
          } else if (nextRel === Relationship_default.INTERSECTING) {
            coordinates2[myEnd++] = nextCoord[0];
            coordinates2[myEnd++] = nextCoord[1];
            skipped = false;
          } else {
            skipped = true;
          }
          lastXCoord = nextCoord[0];
          lastYCoord = nextCoord[1];
          lastRel = nextRel;
        }
        if (closed && skipped || i === offset2 + stride) {
          coordinates2[myEnd++] = lastXCoord;
          coordinates2[myEnd++] = lastYCoord;
        }
        return myEnd;
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @param {Array<number>} builderEnds Builder ends.
       * @return {number} Offset.
       */
      drawCustomCoordinates_(flatCoordinates, offset2, ends, stride, builderEnds) {
        for (let i = 0, ii = ends.length; i < ii; ++i) {
          const end = ends[i];
          const builderEnd = this.appendFlatLineCoordinates(
            flatCoordinates,
            offset2,
            end,
            stride,
            false,
            false
          );
          builderEnds.push(builderEnd);
          offset2 = end;
        }
        return offset2;
      }
      /**
       * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {Function} renderer Renderer.
       * @param {Function} hitDetectionRenderer Renderer.
       */
      drawCustom(geometry, feature, renderer, hitDetectionRenderer) {
        this.beginGeometry(geometry, feature);
        const type = geometry.getType();
        const stride = geometry.getStride();
        const builderBegin = this.coordinates.length;
        let flatCoordinates, builderEnd, builderEnds, builderEndss;
        let offset2;
        switch (type) {
          case "MultiPolygon":
            flatCoordinates = /** @type {import("../../geom/MultiPolygon.js").default} */
            geometry.getOrientedFlatCoordinates();
            builderEndss = [];
            const endss = (
              /** @type {import("../../geom/MultiPolygon.js").default} */
              geometry.getEndss()
            );
            offset2 = 0;
            for (let i = 0, ii = endss.length; i < ii; ++i) {
              const myEnds = [];
              offset2 = this.drawCustomCoordinates_(
                flatCoordinates,
                offset2,
                endss[i],
                stride,
                myEnds
              );
              builderEndss.push(myEnds);
            }
            this.instructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEndss,
              geometry,
              renderer,
              inflateMultiCoordinatesArray
            ]);
            this.hitDetectionInstructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEndss,
              geometry,
              hitDetectionRenderer || renderer,
              inflateMultiCoordinatesArray
            ]);
            break;
          case "Polygon":
          case "MultiLineString":
            builderEnds = [];
            flatCoordinates = type == "Polygon" ? (
              /** @type {import("../../geom/Polygon.js").default} */
              geometry.getOrientedFlatCoordinates()
            ) : geometry.getFlatCoordinates();
            offset2 = this.drawCustomCoordinates_(
              flatCoordinates,
              0,
              /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
              geometry.getEnds(),
              stride,
              builderEnds
            );
            this.instructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnds,
              geometry,
              renderer,
              inflateCoordinatesArray
            ]);
            this.hitDetectionInstructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnds,
              geometry,
              hitDetectionRenderer || renderer,
              inflateCoordinatesArray
            ]);
            break;
          case "LineString":
          case "Circle":
            flatCoordinates = geometry.getFlatCoordinates();
            builderEnd = this.appendFlatLineCoordinates(
              flatCoordinates,
              0,
              flatCoordinates.length,
              stride,
              false,
              false
            );
            this.instructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnd,
              geometry,
              renderer,
              inflateCoordinates
            ]);
            this.hitDetectionInstructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnd,
              geometry,
              hitDetectionRenderer || renderer,
              inflateCoordinates
            ]);
            break;
          case "MultiPoint":
            flatCoordinates = geometry.getFlatCoordinates();
            builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
            if (builderEnd > builderBegin) {
              this.instructions.push([
                Instruction_default.CUSTOM,
                builderBegin,
                builderEnd,
                geometry,
                renderer,
                inflateCoordinates
              ]);
              this.hitDetectionInstructions.push([
                Instruction_default.CUSTOM,
                builderBegin,
                builderEnd,
                geometry,
                hitDetectionRenderer || renderer,
                inflateCoordinates
              ]);
            }
            break;
          case "Point":
            flatCoordinates = geometry.getFlatCoordinates();
            this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
            builderEnd = this.coordinates.length;
            this.instructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnd,
              geometry,
              renderer
            ]);
            this.hitDetectionInstructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnd,
              geometry,
              hitDetectionRenderer || renderer
            ]);
            break;
          default:
        }
        this.endGeometry(feature);
      }
      /**
       * @protected
       * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      beginGeometry(geometry, feature) {
        this.beginGeometryInstruction1_ = [
          Instruction_default.BEGIN_GEOMETRY,
          feature,
          0,
          geometry
        ];
        this.instructions.push(this.beginGeometryInstruction1_);
        this.beginGeometryInstruction2_ = [
          Instruction_default.BEGIN_GEOMETRY,
          feature,
          0,
          geometry
        ];
        this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
      }
      /**
       * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
       */
      finish() {
        return {
          instructions: this.instructions,
          hitDetectionInstructions: this.hitDetectionInstructions,
          coordinates: this.coordinates
        };
      }
      /**
       * Reverse the hit detection instructions.
       */
      reverseHitDetectionInstructions() {
        const hitDetectionInstructions = this.hitDetectionInstructions;
        hitDetectionInstructions.reverse();
        let i;
        const n = hitDetectionInstructions.length;
        let instruction;
        let type;
        let begin = -1;
        for (i = 0; i < n; ++i) {
          instruction = hitDetectionInstructions[i];
          type = /** @type {import("./Instruction.js").default} */
          instruction[0];
          if (type == Instruction_default.END_GEOMETRY) {
            begin = i;
          } else if (type == Instruction_default.BEGIN_GEOMETRY) {
            instruction[2] = i;
            reverseSubArray(this.hitDetectionInstructions, begin, i);
            begin = -1;
          }
        }
      }
      /**
       * @param {import("../../style/Fill.js").default} fillStyle Fill style.
       * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
       */
      setFillStrokeStyle(fillStyle, strokeStyle) {
        const state = this.state;
        if (fillStyle) {
          const fillStyleColor = fillStyle.getColor();
          state.fillStyle = asColorLike(
            fillStyleColor ? fillStyleColor : defaultFillStyle
          );
        } else {
          state.fillStyle = void 0;
        }
        if (strokeStyle) {
          const strokeStyleColor = strokeStyle.getColor();
          state.strokeStyle = asColorLike(
            strokeStyleColor ? strokeStyleColor : defaultStrokeStyle
          );
          const strokeStyleLineCap = strokeStyle.getLineCap();
          state.lineCap = strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap;
          const strokeStyleLineDash = strokeStyle.getLineDash();
          state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;
          const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
          state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;
          const strokeStyleLineJoin = strokeStyle.getLineJoin();
          state.lineJoin = strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin;
          const strokeStyleWidth = strokeStyle.getWidth();
          state.lineWidth = strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth;
          const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
          state.miterLimit = strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit;
          if (state.lineWidth > this.maxLineWidth) {
            this.maxLineWidth = state.lineWidth;
            this.bufferedMaxExtent_ = null;
          }
        } else {
          state.strokeStyle = void 0;
          state.lineCap = void 0;
          state.lineDash = null;
          state.lineDashOffset = void 0;
          state.lineJoin = void 0;
          state.lineWidth = void 0;
          state.miterLimit = void 0;
        }
      }
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @return {Array<*>} Fill instruction.
       */
      createFill(state) {
        const fillStyle = state.fillStyle;
        const fillInstruction2 = [Instruction_default.SET_FILL_STYLE, fillStyle];
        if (typeof fillStyle !== "string") {
          fillInstruction2.push(true);
        }
        return fillInstruction2;
      }
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       */
      applyStroke(state) {
        this.instructions.push(this.createStroke(state));
      }
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @return {Array<*>} Stroke instruction.
       */
      createStroke(state) {
        return [
          Instruction_default.SET_STROKE_STYLE,
          state.strokeStyle,
          state.lineWidth * this.pixelRatio,
          state.lineCap,
          state.lineJoin,
          state.miterLimit,
          this.applyPixelRatio(state.lineDash),
          state.lineDashOffset * this.pixelRatio
        ];
      }
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
       */
      updateFillStyle(state, createFill) {
        const fillStyle = state.fillStyle;
        if (typeof fillStyle !== "string" || state.currentFillStyle != fillStyle) {
          if (fillStyle !== void 0) {
            this.instructions.push(createFill.call(this, state));
          }
          state.currentFillStyle = fillStyle;
        }
      }
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
       */
      updateStrokeStyle(state, applyStroke) {
        const strokeStyle = state.strokeStyle;
        const lineCap = state.lineCap;
        const lineDash = state.lineDash;
        const lineDashOffset = state.lineDashOffset;
        const lineJoin = state.lineJoin;
        const lineWidth = state.lineWidth;
        const miterLimit = state.miterLimit;
        if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
          if (strokeStyle !== void 0) {
            applyStroke.call(this, state);
          }
          state.currentStrokeStyle = strokeStyle;
          state.currentLineCap = lineCap;
          state.currentLineDash = lineDash;
          state.currentLineDashOffset = lineDashOffset;
          state.currentLineJoin = lineJoin;
          state.currentLineWidth = lineWidth;
          state.currentMiterLimit = miterLimit;
        }
      }
      /**
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      endGeometry(feature) {
        this.beginGeometryInstruction1_[2] = this.instructions.length;
        this.beginGeometryInstruction1_ = null;
        this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
        this.beginGeometryInstruction2_ = null;
        const endGeometryInstruction = [Instruction_default.END_GEOMETRY, feature];
        this.instructions.push(endGeometryInstruction);
        this.hitDetectionInstructions.push(endGeometryInstruction);
      }
      /**
       * Get the buffered rendering extent.  Rendering will be clipped to the extent
       * provided to the constructor.  To account for symbolizers that may intersect
       * this extent, we calculate a buffered extent (e.g. based on stroke width).
       * @return {import("../../extent.js").Extent} The buffered rendering extent.
       * @protected
       */
      getBufferedMaxExtent() {
        if (!this.bufferedMaxExtent_) {
          this.bufferedMaxExtent_ = clone(this.maxExtent);
          if (this.maxLineWidth > 0) {
            const width = this.resolution * (this.maxLineWidth + 1) / 2;
            buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
          }
        }
        return this.bufferedMaxExtent_;
      }
    };
    Builder_default = CanvasBuilder;
  }
});

// node_modules/ol/render/canvas/ImageBuilder.js
var CanvasImageBuilder, ImageBuilder_default;
var init_ImageBuilder = __esm({
  "node_modules/ol/render/canvas/ImageBuilder.js"() {
    init_Builder();
    init_Instruction();
    CanvasImageBuilder = class extends Builder_default {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      constructor(tolerance, maxExtent, resolution, pixelRatio) {
        super(tolerance, maxExtent, resolution, pixelRatio);
        this.hitDetectionImage_ = null;
        this.image_ = null;
        this.imagePixelRatio_ = void 0;
        this.anchorX_ = void 0;
        this.anchorY_ = void 0;
        this.height_ = void 0;
        this.opacity_ = void 0;
        this.originX_ = void 0;
        this.originY_ = void 0;
        this.rotateWithView_ = void 0;
        this.rotation_ = void 0;
        this.scale_ = void 0;
        this.width_ = void 0;
        this.declutterMode_ = void 0;
        this.declutterImageWithText_ = void 0;
      }
      /**
       * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      drawPoint(pointGeometry, feature) {
        if (!this.image_) {
          return;
        }
        this.beginGeometry(pointGeometry, feature);
        const flatCoordinates = pointGeometry.getFlatCoordinates();
        const stride = pointGeometry.getStride();
        const myBegin = this.coordinates.length;
        const myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
        this.instructions.push([
          Instruction_default.DRAW_IMAGE,
          myBegin,
          myEnd,
          this.image_,
          // Remaining arguments to DRAW_IMAGE are in alphabetical order
          this.anchorX_ * this.imagePixelRatio_,
          this.anchorY_ * this.imagePixelRatio_,
          Math.ceil(this.height_ * this.imagePixelRatio_),
          this.opacity_,
          this.originX_ * this.imagePixelRatio_,
          this.originY_ * this.imagePixelRatio_,
          this.rotateWithView_,
          this.rotation_,
          [
            this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
            this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
          ],
          Math.ceil(this.width_ * this.imagePixelRatio_),
          this.declutterMode_,
          this.declutterImageWithText_
        ]);
        this.hitDetectionInstructions.push([
          Instruction_default.DRAW_IMAGE,
          myBegin,
          myEnd,
          this.hitDetectionImage_,
          // Remaining arguments to DRAW_IMAGE are in alphabetical order
          this.anchorX_,
          this.anchorY_,
          this.height_,
          1,
          this.originX_,
          this.originY_,
          this.rotateWithView_,
          this.rotation_,
          this.scale_,
          this.width_,
          this.declutterMode_,
          this.declutterImageWithText_
        ]);
        this.endGeometry(feature);
      }
      /**
       * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      drawMultiPoint(multiPointGeometry, feature) {
        if (!this.image_) {
          return;
        }
        this.beginGeometry(multiPointGeometry, feature);
        const flatCoordinates = multiPointGeometry.getFlatCoordinates();
        const stride = multiPointGeometry.getStride();
        const myBegin = this.coordinates.length;
        const myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
        this.instructions.push([
          Instruction_default.DRAW_IMAGE,
          myBegin,
          myEnd,
          this.image_,
          // Remaining arguments to DRAW_IMAGE are in alphabetical order
          this.anchorX_ * this.imagePixelRatio_,
          this.anchorY_ * this.imagePixelRatio_,
          Math.ceil(this.height_ * this.imagePixelRatio_),
          this.opacity_,
          this.originX_ * this.imagePixelRatio_,
          this.originY_ * this.imagePixelRatio_,
          this.rotateWithView_,
          this.rotation_,
          [
            this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
            this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
          ],
          Math.ceil(this.width_ * this.imagePixelRatio_),
          this.declutterMode_,
          this.declutterImageWithText_
        ]);
        this.hitDetectionInstructions.push([
          Instruction_default.DRAW_IMAGE,
          myBegin,
          myEnd,
          this.hitDetectionImage_,
          // Remaining arguments to DRAW_IMAGE are in alphabetical order
          this.anchorX_,
          this.anchorY_,
          this.height_,
          1,
          this.originX_,
          this.originY_,
          this.rotateWithView_,
          this.rotation_,
          this.scale_,
          this.width_,
          this.declutterMode_,
          this.declutterImageWithText_
        ]);
        this.endGeometry(feature);
      }
      /**
       * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
       */
      finish() {
        this.reverseHitDetectionInstructions();
        this.anchorX_ = void 0;
        this.anchorY_ = void 0;
        this.hitDetectionImage_ = null;
        this.image_ = null;
        this.imagePixelRatio_ = void 0;
        this.height_ = void 0;
        this.scale_ = void 0;
        this.opacity_ = void 0;
        this.originX_ = void 0;
        this.originY_ = void 0;
        this.rotateWithView_ = void 0;
        this.rotation_ = void 0;
        this.width_ = void 0;
        return super.finish();
      }
      /**
       * @param {import("../../style/Image.js").default} imageStyle Image style.
       * @param {Object} [sharedData] Shared data.
       */
      setImageStyle(imageStyle, sharedData) {
        const anchor = imageStyle.getAnchor();
        const size = imageStyle.getSize();
        const origin = imageStyle.getOrigin();
        this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
        this.anchorX_ = anchor[0];
        this.anchorY_ = anchor[1];
        this.hitDetectionImage_ = imageStyle.getHitDetectionImage();
        this.image_ = imageStyle.getImage(this.pixelRatio);
        this.height_ = size[1];
        this.opacity_ = imageStyle.getOpacity();
        this.originX_ = origin[0];
        this.originY_ = origin[1];
        this.rotateWithView_ = imageStyle.getRotateWithView();
        this.rotation_ = imageStyle.getRotation();
        this.scale_ = imageStyle.getScaleArray();
        this.width_ = size[0];
        this.declutterMode_ = imageStyle.getDeclutterMode();
        this.declutterImageWithText_ = sharedData;
      }
    };
    ImageBuilder_default = CanvasImageBuilder;
  }
});

// node_modules/ol/render/canvas/LineStringBuilder.js
var CanvasLineStringBuilder, LineStringBuilder_default;
var init_LineStringBuilder = __esm({
  "node_modules/ol/render/canvas/LineStringBuilder.js"() {
    init_Builder();
    init_Instruction();
    init_canvas();
    CanvasLineStringBuilder = class extends Builder_default {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      constructor(tolerance, maxExtent, resolution, pixelRatio) {
        super(tolerance, maxExtent, resolution, pixelRatio);
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       * @return {number} end.
       */
      drawFlatCoordinates_(flatCoordinates, offset2, end, stride) {
        const myBegin = this.coordinates.length;
        const myEnd = this.appendFlatLineCoordinates(
          flatCoordinates,
          offset2,
          end,
          stride,
          false,
          false
        );
        const moveToLineToInstruction = [
          Instruction_default.MOVE_TO_LINE_TO,
          myBegin,
          myEnd
        ];
        this.instructions.push(moveToLineToInstruction);
        this.hitDetectionInstructions.push(moveToLineToInstruction);
        return end;
      }
      /**
       * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      drawLineString(lineStringGeometry, feature) {
        const state = this.state;
        const strokeStyle = state.strokeStyle;
        const lineWidth = state.lineWidth;
        if (strokeStyle === void 0 || lineWidth === void 0) {
          return;
        }
        this.updateStrokeStyle(state, this.applyStroke);
        this.beginGeometry(lineStringGeometry, feature);
        this.hitDetectionInstructions.push(
          [
            Instruction_default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            defaultLineDash,
            defaultLineDashOffset
          ],
          beginPathInstruction
        );
        const flatCoordinates = lineStringGeometry.getFlatCoordinates();
        const stride = lineStringGeometry.getStride();
        this.drawFlatCoordinates_(
          flatCoordinates,
          0,
          flatCoordinates.length,
          stride
        );
        this.hitDetectionInstructions.push(strokeInstruction);
        this.endGeometry(feature);
      }
      /**
       * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      drawMultiLineString(multiLineStringGeometry, feature) {
        const state = this.state;
        const strokeStyle = state.strokeStyle;
        const lineWidth = state.lineWidth;
        if (strokeStyle === void 0 || lineWidth === void 0) {
          return;
        }
        this.updateStrokeStyle(state, this.applyStroke);
        this.beginGeometry(multiLineStringGeometry, feature);
        this.hitDetectionInstructions.push(
          [
            Instruction_default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            defaultLineDash,
            defaultLineDashOffset
          ],
          beginPathInstruction
        );
        const ends = multiLineStringGeometry.getEnds();
        const flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
        const stride = multiLineStringGeometry.getStride();
        let offset2 = 0;
        for (let i = 0, ii = ends.length; i < ii; ++i) {
          offset2 = this.drawFlatCoordinates_(
            flatCoordinates,
            offset2,
            /** @type {number} */
            ends[i],
            stride
          );
        }
        this.hitDetectionInstructions.push(strokeInstruction);
        this.endGeometry(feature);
      }
      /**
       * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
       */
      finish() {
        const state = this.state;
        if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
          this.instructions.push(strokeInstruction);
        }
        this.reverseHitDetectionInstructions();
        this.state = null;
        return super.finish();
      }
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       */
      applyStroke(state) {
        if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
          this.instructions.push(strokeInstruction);
          state.lastStroke = this.coordinates.length;
        }
        state.lastStroke = 0;
        super.applyStroke(state);
        this.instructions.push(beginPathInstruction);
      }
    };
    LineStringBuilder_default = CanvasLineStringBuilder;
  }
});

// node_modules/ol/render/canvas/PolygonBuilder.js
var CanvasPolygonBuilder, PolygonBuilder_default;
var init_PolygonBuilder = __esm({
  "node_modules/ol/render/canvas/PolygonBuilder.js"() {
    init_Builder();
    init_Instruction();
    init_canvas();
    init_simplify();
    CanvasPolygonBuilder = class extends Builder_default {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      constructor(tolerance, maxExtent, resolution, pixelRatio) {
        super(tolerance, maxExtent, resolution, pixelRatio);
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @private
       * @return {number} End.
       */
      drawFlatCoordinatess_(flatCoordinates, offset2, ends, stride) {
        const state = this.state;
        const fill = state.fillStyle !== void 0;
        const stroke = state.strokeStyle !== void 0;
        const numEnds = ends.length;
        this.instructions.push(beginPathInstruction);
        this.hitDetectionInstructions.push(beginPathInstruction);
        for (let i = 0; i < numEnds; ++i) {
          const end = ends[i];
          const myBegin = this.coordinates.length;
          const myEnd = this.appendFlatLineCoordinates(
            flatCoordinates,
            offset2,
            end,
            stride,
            true,
            !stroke
          );
          const moveToLineToInstruction = [
            Instruction_default.MOVE_TO_LINE_TO,
            myBegin,
            myEnd
          ];
          this.instructions.push(moveToLineToInstruction);
          this.hitDetectionInstructions.push(moveToLineToInstruction);
          if (stroke) {
            this.instructions.push(closePathInstruction);
            this.hitDetectionInstructions.push(closePathInstruction);
          }
          offset2 = end;
        }
        if (fill) {
          this.instructions.push(fillInstruction);
          this.hitDetectionInstructions.push(fillInstruction);
        }
        if (stroke) {
          this.instructions.push(strokeInstruction);
          this.hitDetectionInstructions.push(strokeInstruction);
        }
        return offset2;
      }
      /**
       * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
       * @param {import("../../Feature.js").default} feature Feature.
       */
      drawCircle(circleGeometry, feature) {
        const state = this.state;
        const fillStyle = state.fillStyle;
        const strokeStyle = state.strokeStyle;
        if (fillStyle === void 0 && strokeStyle === void 0) {
          return;
        }
        this.setFillStrokeStyles_();
        this.beginGeometry(circleGeometry, feature);
        if (state.fillStyle !== void 0) {
          this.hitDetectionInstructions.push([
            Instruction_default.SET_FILL_STYLE,
            defaultFillStyle
          ]);
        }
        if (state.strokeStyle !== void 0) {
          this.hitDetectionInstructions.push([
            Instruction_default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            defaultLineDash,
            defaultLineDashOffset
          ]);
        }
        const flatCoordinates = circleGeometry.getFlatCoordinates();
        const stride = circleGeometry.getStride();
        const myBegin = this.coordinates.length;
        this.appendFlatLineCoordinates(
          flatCoordinates,
          0,
          flatCoordinates.length,
          stride,
          false,
          false
        );
        const circleInstruction = [Instruction_default.CIRCLE, myBegin];
        this.instructions.push(beginPathInstruction, circleInstruction);
        this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
        if (state.fillStyle !== void 0) {
          this.instructions.push(fillInstruction);
          this.hitDetectionInstructions.push(fillInstruction);
        }
        if (state.strokeStyle !== void 0) {
          this.instructions.push(strokeInstruction);
          this.hitDetectionInstructions.push(strokeInstruction);
        }
        this.endGeometry(feature);
      }
      /**
       * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      drawPolygon(polygonGeometry, feature) {
        const state = this.state;
        const fillStyle = state.fillStyle;
        const strokeStyle = state.strokeStyle;
        if (fillStyle === void 0 && strokeStyle === void 0) {
          return;
        }
        this.setFillStrokeStyles_();
        this.beginGeometry(polygonGeometry, feature);
        if (state.fillStyle !== void 0) {
          this.hitDetectionInstructions.push([
            Instruction_default.SET_FILL_STYLE,
            defaultFillStyle
          ]);
        }
        if (state.strokeStyle !== void 0) {
          this.hitDetectionInstructions.push([
            Instruction_default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            defaultLineDash,
            defaultLineDashOffset
          ]);
        }
        const ends = polygonGeometry.getEnds();
        const flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
        const stride = polygonGeometry.getStride();
        this.drawFlatCoordinatess_(
          flatCoordinates,
          0,
          /** @type {Array<number>} */
          ends,
          stride
        );
        this.endGeometry(feature);
      }
      /**
       * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      drawMultiPolygon(multiPolygonGeometry, feature) {
        const state = this.state;
        const fillStyle = state.fillStyle;
        const strokeStyle = state.strokeStyle;
        if (fillStyle === void 0 && strokeStyle === void 0) {
          return;
        }
        this.setFillStrokeStyles_();
        this.beginGeometry(multiPolygonGeometry, feature);
        if (state.fillStyle !== void 0) {
          this.hitDetectionInstructions.push([
            Instruction_default.SET_FILL_STYLE,
            defaultFillStyle
          ]);
        }
        if (state.strokeStyle !== void 0) {
          this.hitDetectionInstructions.push([
            Instruction_default.SET_STROKE_STYLE,
            state.strokeStyle,
            state.lineWidth,
            state.lineCap,
            state.lineJoin,
            state.miterLimit,
            defaultLineDash,
            defaultLineDashOffset
          ]);
        }
        const endss = multiPolygonGeometry.getEndss();
        const flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
        const stride = multiPolygonGeometry.getStride();
        let offset2 = 0;
        for (let i = 0, ii = endss.length; i < ii; ++i) {
          offset2 = this.drawFlatCoordinatess_(
            flatCoordinates,
            offset2,
            endss[i],
            stride
          );
        }
        this.endGeometry(feature);
      }
      /**
       * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
       */
      finish() {
        this.reverseHitDetectionInstructions();
        this.state = null;
        const tolerance = this.tolerance;
        if (tolerance !== 0) {
          const coordinates2 = this.coordinates;
          for (let i = 0, ii = coordinates2.length; i < ii; ++i) {
            coordinates2[i] = snap(coordinates2[i], tolerance);
          }
        }
        return super.finish();
      }
      /**
       * @private
       */
      setFillStrokeStyles_() {
        const state = this.state;
        const fillStyle = state.fillStyle;
        if (fillStyle !== void 0) {
          this.updateFillStyle(state, this.createFill);
        }
        if (state.strokeStyle !== void 0) {
          this.updateStrokeStyle(state, this.applyStroke);
        }
      }
    };
    PolygonBuilder_default = CanvasPolygonBuilder;
  }
});

// node_modules/ol/geom/flat/linechunk.js
function lineChunk(chunkLength, flatCoordinates, offset2, end, stride) {
  const chunks = [];
  let cursor = offset2;
  let chunkM = 0;
  let currentChunk = flatCoordinates.slice(offset2, 2);
  while (chunkM < chunkLength && cursor + stride < end) {
    const [x1, y1] = currentChunk.slice(-2);
    const x2 = flatCoordinates[cursor + stride];
    const y2 = flatCoordinates[cursor + stride + 1];
    const segmentLength = Math.sqrt(
      (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)
    );
    chunkM += segmentLength;
    if (chunkM >= chunkLength) {
      const m = (chunkLength - chunkM + segmentLength) / segmentLength;
      const x = lerp(x1, x2, m);
      const y = lerp(y1, y2, m);
      currentChunk.push(x, y);
      chunks.push(currentChunk);
      currentChunk = [x, y];
      if (chunkM == chunkLength) {
        cursor += stride;
      }
      chunkM = 0;
    } else if (chunkM < chunkLength) {
      currentChunk.push(
        flatCoordinates[cursor + stride],
        flatCoordinates[cursor + stride + 1]
      );
      cursor += stride;
    } else {
      const missing = segmentLength - chunkM;
      const x = lerp(x1, x2, missing / segmentLength);
      const y = lerp(y1, y2, missing / segmentLength);
      currentChunk.push(x, y);
      chunks.push(currentChunk);
      currentChunk = [x, y];
      chunkM = 0;
      cursor += stride;
    }
  }
  if (chunkM > 0) {
    chunks.push(currentChunk);
  }
  return chunks;
}
var init_linechunk = __esm({
  "node_modules/ol/geom/flat/linechunk.js"() {
    init_math();
  }
});

// node_modules/ol/geom/flat/straightchunk.js
function matchingChunk(maxAngle, flatCoordinates, offset2, end, stride) {
  let chunkStart = offset2;
  let chunkEnd = offset2;
  let chunkM = 0;
  let m = 0;
  let start = offset2;
  let acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
  for (i = offset2; i < end; i += stride) {
    const x2 = flatCoordinates[i];
    const y2 = flatCoordinates[i + 1];
    if (x1 !== void 0) {
      x23 = x2 - x1;
      y23 = y2 - y1;
      m23 = Math.sqrt(x23 * x23 + y23 * y23);
      if (x12 !== void 0) {
        m += m12;
        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
        if (acos > maxAngle) {
          if (m > chunkM) {
            chunkM = m;
            chunkStart = start;
            chunkEnd = i;
          }
          m = 0;
          start = i - stride;
        }
      }
      m12 = m23;
      x12 = x23;
      y12 = y23;
    }
    x1 = x2;
    y1 = y2;
  }
  m += m23;
  return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
}
var init_straightchunk = __esm({
  "node_modules/ol/geom/flat/straightchunk.js"() {
  }
});

// node_modules/ol/render/canvas/TextBuilder.js
var TEXT_ALIGN, CanvasTextBuilder, TextBuilder_default;
var init_TextBuilder = __esm({
  "node_modules/ol/render/canvas/TextBuilder.js"() {
    init_Builder();
    init_Instruction();
    init_colorlike();
    init_canvas();
    init_util();
    init_extent();
    init_linechunk();
    init_straightchunk();
    TEXT_ALIGN = {
      "left": 0,
      "center": 0.5,
      "right": 1,
      "top": 0,
      "middle": 0.5,
      "hanging": 0.2,
      "alphabetic": 0.8,
      "ideographic": 0.8,
      "bottom": 1
    };
    CanvasTextBuilder = class extends Builder_default {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      constructor(tolerance, maxExtent, resolution, pixelRatio) {
        super(tolerance, maxExtent, resolution, pixelRatio);
        this.labels_ = null;
        this.text_ = "";
        this.textOffsetX_ = 0;
        this.textOffsetY_ = 0;
        this.textRotateWithView_ = void 0;
        this.textRotation_ = 0;
        this.textFillState_ = null;
        this.fillStates = {};
        this.fillStates[defaultFillStyle] = { fillStyle: defaultFillStyle };
        this.textStrokeState_ = null;
        this.strokeStates = {};
        this.textState_ = /** @type {import("../canvas.js").TextState} */
        {};
        this.textStates = {};
        this.textKey_ = "";
        this.fillKey_ = "";
        this.strokeKey_ = "";
        this.declutterImageWithText_ = void 0;
      }
      /**
       * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
       */
      finish() {
        const instructions = super.finish();
        instructions.textStates = this.textStates;
        instructions.fillStates = this.fillStates;
        instructions.strokeStates = this.strokeStates;
        return instructions;
      }
      /**
       * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      drawText(geometry, feature) {
        const fillState = this.textFillState_;
        const strokeState = this.textStrokeState_;
        const textState = this.textState_;
        if (this.text_ === "" || !textState || !fillState && !strokeState) {
          return;
        }
        const coordinates2 = this.coordinates;
        let begin = coordinates2.length;
        const geometryType = geometry.getType();
        let flatCoordinates = null;
        let stride = geometry.getStride();
        if (textState.placement === "line" && (geometryType == "LineString" || geometryType == "MultiLineString" || geometryType == "Polygon" || geometryType == "MultiPolygon")) {
          if (!intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {
            return;
          }
          let ends;
          flatCoordinates = geometry.getFlatCoordinates();
          if (geometryType == "LineString") {
            ends = [flatCoordinates.length];
          } else if (geometryType == "MultiLineString") {
            ends = /** @type {import("../../geom/MultiLineString.js").default} */
            geometry.getEnds();
          } else if (geometryType == "Polygon") {
            ends = /** @type {import("../../geom/Polygon.js").default} */
            geometry.getEnds().slice(0, 1);
          } else if (geometryType == "MultiPolygon") {
            const endss = (
              /** @type {import("../../geom/MultiPolygon.js").default} */
              geometry.getEndss()
            );
            ends = [];
            for (let i = 0, ii = endss.length; i < ii; ++i) {
              ends.push(endss[i][0]);
            }
          }
          this.beginGeometry(geometry, feature);
          const repeat = textState.repeat;
          const textAlign = repeat ? void 0 : textState.textAlign;
          let flatOffset = 0;
          for (let o = 0, oo = ends.length; o < oo; ++o) {
            let chunks;
            if (repeat) {
              chunks = lineChunk(
                repeat * this.resolution,
                flatCoordinates,
                flatOffset,
                ends[o],
                stride
              );
            } else {
              chunks = [flatCoordinates.slice(flatOffset, ends[o])];
            }
            for (let c = 0, cc = chunks.length; c < cc; ++c) {
              const chunk = chunks[c];
              let chunkBegin = 0;
              let chunkEnd = chunk.length;
              if (textAlign == void 0) {
                const range = matchingChunk(
                  textState.maxAngle,
                  chunk,
                  0,
                  chunk.length,
                  2
                );
                chunkBegin = range[0];
                chunkEnd = range[1];
              }
              for (let i = chunkBegin; i < chunkEnd; i += stride) {
                coordinates2.push(chunk[i], chunk[i + 1]);
              }
              const end = coordinates2.length;
              flatOffset = ends[o];
              this.drawChars_(begin, end);
              begin = end;
            }
          }
          this.endGeometry(feature);
        } else {
          let geometryWidths = textState.overflow ? null : [];
          switch (geometryType) {
            case "Point":
            case "MultiPoint":
              flatCoordinates = /** @type {import("../../geom/MultiPoint.js").default} */
              geometry.getFlatCoordinates();
              break;
            case "LineString":
              flatCoordinates = /** @type {import("../../geom/LineString.js").default} */
              geometry.getFlatMidpoint();
              break;
            case "Circle":
              flatCoordinates = /** @type {import("../../geom/Circle.js").default} */
              geometry.getCenter();
              break;
            case "MultiLineString":
              flatCoordinates = /** @type {import("../../geom/MultiLineString.js").default} */
              geometry.getFlatMidpoints();
              stride = 2;
              break;
            case "Polygon":
              flatCoordinates = /** @type {import("../../geom/Polygon.js").default} */
              geometry.getFlatInteriorPoint();
              if (!textState.overflow) {
                geometryWidths.push(flatCoordinates[2] / this.resolution);
              }
              stride = 3;
              break;
            case "MultiPolygon":
              const interiorPoints = (
                /** @type {import("../../geom/MultiPolygon.js").default} */
                geometry.getFlatInteriorPoints()
              );
              flatCoordinates = [];
              for (let i = 0, ii = interiorPoints.length; i < ii; i += 3) {
                if (!textState.overflow) {
                  geometryWidths.push(interiorPoints[i + 2] / this.resolution);
                }
                flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
              }
              if (flatCoordinates.length === 0) {
                return;
              }
              stride = 2;
              break;
            default:
          }
          const end = this.appendFlatPointCoordinates(flatCoordinates, stride);
          if (end === begin) {
            return;
          }
          if (geometryWidths && (end - begin) / 2 !== flatCoordinates.length / stride) {
            let beg = begin / 2;
            geometryWidths = geometryWidths.filter((w, i) => {
              const keep = coordinates2[(beg + i) * 2] === flatCoordinates[i * stride] && coordinates2[(beg + i) * 2 + 1] === flatCoordinates[i * stride + 1];
              if (!keep) {
                --beg;
              }
              return keep;
            });
          }
          this.saveTextStates_();
          if (textState.backgroundFill || textState.backgroundStroke) {
            this.setFillStrokeStyle(
              textState.backgroundFill,
              textState.backgroundStroke
            );
            if (textState.backgroundFill) {
              this.updateFillStyle(this.state, this.createFill);
            }
            if (textState.backgroundStroke) {
              this.updateStrokeStyle(this.state, this.applyStroke);
              this.hitDetectionInstructions.push(this.createStroke(this.state));
            }
          }
          this.beginGeometry(geometry, feature);
          let padding = textState.padding;
          if (padding != defaultPadding && (textState.scale[0] < 0 || textState.scale[1] < 0)) {
            let p0 = textState.padding[0];
            let p12 = textState.padding[1];
            let p22 = textState.padding[2];
            let p32 = textState.padding[3];
            if (textState.scale[0] < 0) {
              p12 = -p12;
              p32 = -p32;
            }
            if (textState.scale[1] < 0) {
              p0 = -p0;
              p22 = -p22;
            }
            padding = [p0, p12, p22, p32];
          }
          const pixelRatio = this.pixelRatio;
          this.instructions.push([
            Instruction_default.DRAW_IMAGE,
            begin,
            end,
            null,
            NaN,
            NaN,
            NaN,
            1,
            0,
            0,
            this.textRotateWithView_,
            this.textRotation_,
            [1, 1],
            NaN,
            void 0,
            this.declutterImageWithText_,
            padding == defaultPadding ? defaultPadding : padding.map(function(p) {
              return p * pixelRatio;
            }),
            !!textState.backgroundFill,
            !!textState.backgroundStroke,
            this.text_,
            this.textKey_,
            this.strokeKey_,
            this.fillKey_,
            this.textOffsetX_,
            this.textOffsetY_,
            geometryWidths
          ]);
          const scale5 = 1 / pixelRatio;
          const currentFillStyle = this.state.fillStyle;
          if (textState.backgroundFill) {
            this.state.fillStyle = defaultFillStyle;
            this.hitDetectionInstructions.push(this.createFill(this.state));
          }
          this.hitDetectionInstructions.push([
            Instruction_default.DRAW_IMAGE,
            begin,
            end,
            null,
            NaN,
            NaN,
            NaN,
            1,
            0,
            0,
            this.textRotateWithView_,
            this.textRotation_,
            [scale5, scale5],
            NaN,
            void 0,
            this.declutterImageWithText_,
            padding,
            !!textState.backgroundFill,
            !!textState.backgroundStroke,
            this.text_,
            this.textKey_,
            this.strokeKey_,
            this.fillKey_ ? defaultFillStyle : this.fillKey_,
            this.textOffsetX_,
            this.textOffsetY_,
            geometryWidths
          ]);
          if (textState.backgroundFill) {
            this.state.fillStyle = currentFillStyle;
            this.hitDetectionInstructions.push(this.createFill(this.state));
          }
          this.endGeometry(feature);
        }
      }
      /**
       * @private
       */
      saveTextStates_() {
        const strokeState = this.textStrokeState_;
        const textState = this.textState_;
        const fillState = this.textFillState_;
        const strokeKey = this.strokeKey_;
        if (strokeState) {
          if (!(strokeKey in this.strokeStates)) {
            this.strokeStates[strokeKey] = {
              strokeStyle: strokeState.strokeStyle,
              lineCap: strokeState.lineCap,
              lineDashOffset: strokeState.lineDashOffset,
              lineWidth: strokeState.lineWidth,
              lineJoin: strokeState.lineJoin,
              miterLimit: strokeState.miterLimit,
              lineDash: strokeState.lineDash
            };
          }
        }
        const textKey = this.textKey_;
        if (!(textKey in this.textStates)) {
          this.textStates[textKey] = {
            font: textState.font,
            textAlign: textState.textAlign || defaultTextAlign,
            justify: textState.justify,
            textBaseline: textState.textBaseline || defaultTextBaseline,
            scale: textState.scale
          };
        }
        const fillKey = this.fillKey_;
        if (fillState) {
          if (!(fillKey in this.fillStates)) {
            this.fillStates[fillKey] = {
              fillStyle: fillState.fillStyle
            };
          }
        }
      }
      /**
       * @private
       * @param {number} begin Begin.
       * @param {number} end End.
       */
      drawChars_(begin, end) {
        const strokeState = this.textStrokeState_;
        const textState = this.textState_;
        const strokeKey = this.strokeKey_;
        const textKey = this.textKey_;
        const fillKey = this.fillKey_;
        this.saveTextStates_();
        const pixelRatio = this.pixelRatio;
        const baseline = TEXT_ALIGN[textState.textBaseline];
        const offsetY = this.textOffsetY_ * pixelRatio;
        const text = this.text_;
        const strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;
        this.instructions.push([
          Instruction_default.DRAW_CHARS,
          begin,
          end,
          baseline,
          textState.overflow,
          fillKey,
          textState.maxAngle,
          pixelRatio,
          offsetY,
          strokeKey,
          strokeWidth * pixelRatio,
          text,
          textKey,
          1
        ]);
        this.hitDetectionInstructions.push([
          Instruction_default.DRAW_CHARS,
          begin,
          end,
          baseline,
          textState.overflow,
          fillKey ? defaultFillStyle : fillKey,
          textState.maxAngle,
          pixelRatio,
          offsetY,
          strokeKey,
          strokeWidth * pixelRatio,
          text,
          textKey,
          1 / pixelRatio
        ]);
      }
      /**
       * @param {import("../../style/Text.js").default} textStyle Text style.
       * @param {Object} [sharedData] Shared data.
       */
      setTextStyle(textStyle, sharedData) {
        let textState, fillState, strokeState;
        if (!textStyle) {
          this.text_ = "";
        } else {
          const textFillStyle = textStyle.getFill();
          if (!textFillStyle) {
            fillState = null;
            this.textFillState_ = fillState;
          } else {
            fillState = this.textFillState_;
            if (!fillState) {
              fillState = /** @type {import("../canvas.js").FillState} */
              {};
              this.textFillState_ = fillState;
            }
            fillState.fillStyle = asColorLike(
              textFillStyle.getColor() || defaultFillStyle
            );
          }
          const textStrokeStyle = textStyle.getStroke();
          if (!textStrokeStyle) {
            strokeState = null;
            this.textStrokeState_ = strokeState;
          } else {
            strokeState = this.textStrokeState_;
            if (!strokeState) {
              strokeState = /** @type {import("../canvas.js").StrokeState} */
              {};
              this.textStrokeState_ = strokeState;
            }
            const lineDash = textStrokeStyle.getLineDash();
            const lineDashOffset = textStrokeStyle.getLineDashOffset();
            const lineWidth = textStrokeStyle.getWidth();
            const miterLimit = textStrokeStyle.getMiterLimit();
            strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;
            strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;
            strokeState.lineDashOffset = lineDashOffset === void 0 ? defaultLineDashOffset : lineDashOffset;
            strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;
            strokeState.lineWidth = lineWidth === void 0 ? defaultLineWidth : lineWidth;
            strokeState.miterLimit = miterLimit === void 0 ? defaultMiterLimit : miterLimit;
            strokeState.strokeStyle = asColorLike(
              textStrokeStyle.getColor() || defaultStrokeStyle
            );
          }
          textState = this.textState_;
          const font = textStyle.getFont() || defaultFont;
          registerFont(font);
          const textScale = textStyle.getScaleArray();
          textState.overflow = textStyle.getOverflow();
          textState.font = font;
          textState.maxAngle = textStyle.getMaxAngle();
          textState.placement = textStyle.getPlacement();
          textState.textAlign = textStyle.getTextAlign();
          textState.repeat = textStyle.getRepeat();
          textState.justify = textStyle.getJustify();
          textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;
          textState.backgroundFill = textStyle.getBackgroundFill();
          textState.backgroundStroke = textStyle.getBackgroundStroke();
          textState.padding = textStyle.getPadding() || defaultPadding;
          textState.scale = textScale === void 0 ? [1, 1] : textScale;
          const textOffsetX = textStyle.getOffsetX();
          const textOffsetY = textStyle.getOffsetY();
          const textRotateWithView = textStyle.getRotateWithView();
          const textRotation = textStyle.getRotation();
          this.text_ = textStyle.getText() || "";
          this.textOffsetX_ = textOffsetX === void 0 ? 0 : textOffsetX;
          this.textOffsetY_ = textOffsetY === void 0 ? 0 : textOffsetY;
          this.textRotateWithView_ = textRotateWithView === void 0 ? false : textRotateWithView;
          this.textRotation_ = textRotation === void 0 ? 0 : textRotation;
          this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == "string" ? strokeState.strokeStyle : getUid(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + "|" + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + "[" + strokeState.lineDash.join() + "]" : "";
          this.textKey_ = textState.font + textState.scale + (textState.textAlign || "?") + (textState.repeat || "?") + (textState.justify || "?") + (textState.textBaseline || "?");
          this.fillKey_ = fillState ? typeof fillState.fillStyle == "string" ? fillState.fillStyle : "|" + getUid(fillState.fillStyle) : "";
        }
        this.declutterImageWithText_ = sharedData;
      }
    };
    TextBuilder_default = CanvasTextBuilder;
  }
});

// node_modules/ol/render/canvas/BuilderGroup.js
var BATCH_CONSTRUCTORS, BuilderGroup, BuilderGroup_default;
var init_BuilderGroup = __esm({
  "node_modules/ol/render/canvas/BuilderGroup.js"() {
    init_Builder();
    init_ImageBuilder();
    init_LineStringBuilder();
    init_PolygonBuilder();
    init_TextBuilder();
    BATCH_CONSTRUCTORS = {
      "Circle": PolygonBuilder_default,
      "Default": Builder_default,
      "Image": ImageBuilder_default,
      "LineString": LineStringBuilder_default,
      "Polygon": PolygonBuilder_default,
      "Text": TextBuilder_default
    };
    BuilderGroup = class {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Max extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      constructor(tolerance, maxExtent, resolution, pixelRatio) {
        this.tolerance_ = tolerance;
        this.maxExtent_ = maxExtent;
        this.pixelRatio_ = pixelRatio;
        this.resolution_ = resolution;
        this.buildersByZIndex_ = {};
      }
      /**
       * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
       */
      finish() {
        const builderInstructions = {};
        for (const zKey in this.buildersByZIndex_) {
          builderInstructions[zKey] = builderInstructions[zKey] || {};
          const builders = this.buildersByZIndex_[zKey];
          for (const builderKey in builders) {
            const builderInstruction = builders[builderKey].finish();
            builderInstructions[zKey][builderKey] = builderInstruction;
          }
        }
        return builderInstructions;
      }
      /**
       * @param {number|undefined} zIndex Z index.
       * @param {import("../canvas.js").BuilderType} builderType Replay type.
       * @return {import("../VectorContext.js").default} Replay.
       */
      getBuilder(zIndex, builderType) {
        const zIndexKey = zIndex !== void 0 ? zIndex.toString() : "0";
        let replays = this.buildersByZIndex_[zIndexKey];
        if (replays === void 0) {
          replays = {};
          this.buildersByZIndex_[zIndexKey] = replays;
        }
        let replay = replays[builderType];
        if (replay === void 0) {
          const Constructor = BATCH_CONSTRUCTORS[builderType];
          replay = new Constructor(
            this.tolerance_,
            this.maxExtent_,
            this.resolution_,
            this.pixelRatio_
          );
          replays[builderType] = replay;
        }
        return replay;
      }
    };
    BuilderGroup_default = BuilderGroup;
  }
});

// node_modules/ol/geom/flat/textpath.js
function drawTextOnPath(flatCoordinates, offset2, end, stride, text, startM, maxAngle, scale5, measureAndCacheTextWidth2, font, cache3, rotation) {
  let x2 = flatCoordinates[offset2];
  let y2 = flatCoordinates[offset2 + 1];
  let x1 = 0;
  let y1 = 0;
  let segmentLength = 0;
  let segmentM = 0;
  function advance() {
    x1 = x2;
    y1 = y2;
    offset2 += stride;
    x2 = flatCoordinates[offset2];
    y2 = flatCoordinates[offset2 + 1];
    segmentM += segmentLength;
    segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
  }
  do {
    advance();
  } while (offset2 < end - stride && segmentM + segmentLength < startM);
  let interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;
  const beginX = lerp(x1, x2, interpolate);
  const beginY = lerp(y1, y2, interpolate);
  const startOffset = offset2 - stride;
  const startLength = segmentM;
  const endM = startM + scale5 * measureAndCacheTextWidth2(font, text, cache3);
  while (offset2 < end - stride && segmentM + segmentLength < endM) {
    advance();
  }
  interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;
  const endX = lerp(x1, x2, interpolate);
  const endY = lerp(y1, y2, interpolate);
  let reverse;
  if (rotation) {
    const flat = [beginX, beginY, endX, endY];
    rotate3(flat, 0, 4, 2, rotation, flat, flat);
    reverse = flat[0] > flat[2];
  } else {
    reverse = beginX > endX;
  }
  const PI = Math.PI;
  const result = [];
  const singleSegment = startOffset + stride === offset2;
  offset2 = startOffset;
  segmentLength = 0;
  segmentM = startLength;
  x2 = flatCoordinates[offset2];
  y2 = flatCoordinates[offset2 + 1];
  let previousAngle;
  if (singleSegment) {
    advance();
    previousAngle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse) {
      previousAngle += previousAngle > 0 ? -PI : PI;
    }
    const x = (endX + beginX) / 2;
    const y = (endY + beginY) / 2;
    result[0] = [x, y, (endM - startM) / 2, previousAngle, text];
    return result;
  }
  text = text.replace(/\n/g, " ");
  for (let i = 0, ii = text.length; i < ii; ) {
    advance();
    let angle = Math.atan2(y2 - y1, x2 - x1);
    if (reverse) {
      angle += angle > 0 ? -PI : PI;
    }
    if (previousAngle !== void 0) {
      let delta = angle - previousAngle;
      delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;
      if (Math.abs(delta) > maxAngle) {
        return null;
      }
    }
    previousAngle = angle;
    const iStart = i;
    let charLength = 0;
    for (; i < ii; ++i) {
      const index = reverse ? ii - i - 1 : i;
      const len = scale5 * measureAndCacheTextWidth2(font, text[index], cache3);
      if (offset2 + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {
        break;
      }
      charLength += len;
    }
    if (i === iStart) {
      continue;
    }
    const chars = reverse ? text.substring(ii - iStart, ii - i) : text.substring(iStart, i);
    interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;
    const x = lerp(x1, x2, interpolate);
    const y = lerp(y1, y2, interpolate);
    result.push([x, y, charLength / 2, angle, chars]);
    startM += charLength;
  }
  return result;
}
var init_textpath = __esm({
  "node_modules/ol/geom/flat/textpath.js"() {
    init_math();
    init_transform2();
  }
});

// node_modules/ol/render/canvas/Executor.js
function getDeclutterBox(replayImageOrLabelArgs) {
  return replayImageOrLabelArgs[3].declutterBox;
}
function horizontalTextAlign(text, align) {
  if (align === "start") {
    align = rtlRegEx.test(text) ? "right" : "left";
  } else if (align === "end") {
    align = rtlRegEx.test(text) ? "left" : "right";
  }
  return TEXT_ALIGN[align];
}
function createTextChunks(acc, line, i) {
  if (i > 0) {
    acc.push("\n", "");
  }
  acc.push(line, "");
  return acc;
}
var tmpExtent, p1, p2, p3, p4, rtlRegEx, Executor, Executor_default;
var init_Executor = __esm({
  "node_modules/ol/render/canvas/Executor.js"() {
    init_Instruction();
    init_TextBuilder();
    init_transform();
    init_extent();
    init_canvas();
    init_textpath();
    init_array();
    init_length();
    init_transform2();
    tmpExtent = createEmpty();
    p1 = [];
    p2 = [];
    p3 = [];
    p4 = [];
    rtlRegEx = new RegExp(
      /* eslint-disable prettier/prettier */
      "[" + String.fromCharCode(1425) + "-" + String.fromCharCode(2303) + String.fromCharCode(64285) + "-" + String.fromCharCode(65023) + String.fromCharCode(65136) + "-" + String.fromCharCode(65276) + String.fromCharCode(67584) + "-" + String.fromCharCode(69631) + String.fromCharCode(124928) + "-" + String.fromCharCode(126975) + "]"
      /* eslint-enable prettier/prettier */
    );
    Executor = class {
      /**
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {boolean} overlaps The replay can have overlapping geometries.
       * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions
       */
      constructor(resolution, pixelRatio, overlaps, instructions) {
        this.overlaps = overlaps;
        this.pixelRatio = pixelRatio;
        this.resolution = resolution;
        this.alignFill_;
        this.instructions = instructions.instructions;
        this.coordinates = instructions.coordinates;
        this.coordinateCache_ = {};
        this.renderedTransform_ = create();
        this.hitDetectionInstructions = instructions.hitDetectionInstructions;
        this.pixelCoordinates_ = null;
        this.viewRotation_ = 0;
        this.fillStates = instructions.fillStates || {};
        this.strokeStates = instructions.strokeStates || {};
        this.textStates = instructions.textStates || {};
        this.widths_ = {};
        this.labels_ = {};
      }
      /**
       * @param {string|Array<string>} text Text.
       * @param {string} textKey Text style key.
       * @param {string} fillKey Fill style key.
       * @param {string} strokeKey Stroke style key.
       * @return {import("../canvas.js").Label} Label.
       */
      createLabel(text, textKey, fillKey, strokeKey) {
        const key = text + textKey + fillKey + strokeKey;
        if (this.labels_[key]) {
          return this.labels_[key];
        }
        const strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
        const fillState = fillKey ? this.fillStates[fillKey] : null;
        const textState = this.textStates[textKey];
        const pixelRatio = this.pixelRatio;
        const scale5 = [
          textState.scale[0] * pixelRatio,
          textState.scale[1] * pixelRatio
        ];
        const textIsArray = Array.isArray(text);
        const align = textState.justify ? TEXT_ALIGN[textState.justify] : horizontalTextAlign(
          Array.isArray(text) ? text[0] : text,
          textState.textAlign || defaultTextAlign
        );
        const strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
        const chunks = textIsArray ? text : text.split("\n").reduce(createTextChunks, []);
        const { width, height, widths, heights, lineWidths } = getTextDimensions(
          textState,
          chunks
        );
        const renderWidth = width + strokeWidth;
        const contextInstructions = [];
        const w = (renderWidth + 2) * scale5[0];
        const h = (height + strokeWidth) * scale5[1];
        const label = {
          width: w < 0 ? Math.floor(w) : Math.ceil(w),
          height: h < 0 ? Math.floor(h) : Math.ceil(h),
          contextInstructions
        };
        if (scale5[0] != 1 || scale5[1] != 1) {
          contextInstructions.push("scale", scale5);
        }
        if (strokeKey) {
          contextInstructions.push("strokeStyle", strokeState.strokeStyle);
          contextInstructions.push("lineWidth", strokeWidth);
          contextInstructions.push("lineCap", strokeState.lineCap);
          contextInstructions.push("lineJoin", strokeState.lineJoin);
          contextInstructions.push("miterLimit", strokeState.miterLimit);
          contextInstructions.push("setLineDash", [strokeState.lineDash]);
          contextInstructions.push("lineDashOffset", strokeState.lineDashOffset);
        }
        if (fillKey) {
          contextInstructions.push("fillStyle", fillState.fillStyle);
        }
        contextInstructions.push("textBaseline", "middle");
        contextInstructions.push("textAlign", "center");
        const leftRight = 0.5 - align;
        let x = align * renderWidth + leftRight * strokeWidth;
        const strokeInstructions = [];
        const fillInstructions = [];
        let lineHeight = 0;
        let lineOffset = 0;
        let widthHeightIndex = 0;
        let lineWidthIndex = 0;
        let previousFont;
        for (let i = 0, ii = chunks.length; i < ii; i += 2) {
          const text2 = chunks[i];
          if (text2 === "\n") {
            lineOffset += lineHeight;
            lineHeight = 0;
            x = align * renderWidth + leftRight * strokeWidth;
            ++lineWidthIndex;
            continue;
          }
          const font = chunks[i + 1] || textState.font;
          if (font !== previousFont) {
            if (strokeKey) {
              strokeInstructions.push("font", font);
            }
            if (fillKey) {
              fillInstructions.push("font", font);
            }
            previousFont = font;
          }
          lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);
          const fillStrokeArgs = [
            text2,
            x + leftRight * widths[widthHeightIndex] + align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]),
            0.5 * (strokeWidth + lineHeight) + lineOffset
          ];
          x += widths[widthHeightIndex];
          if (strokeKey) {
            strokeInstructions.push("strokeText", fillStrokeArgs);
          }
          if (fillKey) {
            fillInstructions.push("fillText", fillStrokeArgs);
          }
          ++widthHeightIndex;
        }
        Array.prototype.push.apply(contextInstructions, strokeInstructions);
        Array.prototype.push.apply(contextInstructions, fillInstructions);
        this.labels_[key] = label;
        return label;
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
       * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
       * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
       * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
       * @param {Array<*>} fillInstruction Fill instruction.
       * @param {Array<*>} strokeInstruction Stroke instruction.
       */
      replayTextBackground_(context, p12, p22, p32, p42, fillInstruction2, strokeInstruction2) {
        context.beginPath();
        context.moveTo.apply(context, p12);
        context.lineTo.apply(context, p22);
        context.lineTo.apply(context, p32);
        context.lineTo.apply(context, p42);
        context.lineTo.apply(context, p12);
        if (fillInstruction2) {
          this.alignFill_ = /** @type {boolean} */
          fillInstruction2[2];
          this.fill_(context);
        }
        if (strokeInstruction2) {
          this.setStrokeStyle_(
            context,
            /** @type {Array<*>} */
            strokeInstruction2
          );
          context.stroke();
        }
      }
      /**
       * @private
       * @param {number} sheetWidth Width of the sprite sheet.
       * @param {number} sheetHeight Height of the sprite sheet.
       * @param {number} centerX X.
       * @param {number} centerY Y.
       * @param {number} width Width.
       * @param {number} height Height.
       * @param {number} anchorX Anchor X.
       * @param {number} anchorY Anchor Y.
       * @param {number} originX Origin X.
       * @param {number} originY Origin Y.
       * @param {number} rotation Rotation.
       * @param {import("../../size.js").Size} scale Scale.
       * @param {boolean} snapToPixel Snap to pixel.
       * @param {Array<number>} padding Padding.
       * @param {boolean} fillStroke Background fill or stroke.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
       */
      calculateImageOrLabelDimensions_(sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale5, snapToPixel, padding, fillStroke, feature) {
        anchorX *= scale5[0];
        anchorY *= scale5[1];
        let x = centerX - anchorX;
        let y = centerY - anchorY;
        const w = width + originX > sheetWidth ? sheetWidth - originX : width;
        const h = height + originY > sheetHeight ? sheetHeight - originY : height;
        const boxW = padding[3] + w * scale5[0] + padding[1];
        const boxH = padding[0] + h * scale5[1] + padding[2];
        const boxX = x - padding[3];
        const boxY = y - padding[0];
        if (fillStroke || rotation !== 0) {
          p1[0] = boxX;
          p4[0] = boxX;
          p1[1] = boxY;
          p2[1] = boxY;
          p2[0] = boxX + boxW;
          p3[0] = p2[0];
          p3[1] = boxY + boxH;
          p4[1] = p3[1];
        }
        let transform2;
        if (rotation !== 0) {
          transform2 = compose(
            create(),
            centerX,
            centerY,
            1,
            1,
            rotation,
            -centerX,
            -centerY
          );
          apply(transform2, p1);
          apply(transform2, p2);
          apply(transform2, p3);
          apply(transform2, p4);
          createOrUpdate(
            Math.min(p1[0], p2[0], p3[0], p4[0]),
            Math.min(p1[1], p2[1], p3[1], p4[1]),
            Math.max(p1[0], p2[0], p3[0], p4[0]),
            Math.max(p1[1], p2[1], p3[1], p4[1]),
            tmpExtent
          );
        } else {
          createOrUpdate(
            Math.min(boxX, boxX + boxW),
            Math.min(boxY, boxY + boxH),
            Math.max(boxX, boxX + boxW),
            Math.max(boxY, boxY + boxH),
            tmpExtent
          );
        }
        if (snapToPixel) {
          x = Math.round(x);
          y = Math.round(y);
        }
        return {
          drawImageX: x,
          drawImageY: y,
          drawImageW: w,
          drawImageH: h,
          originX,
          originY,
          declutterBox: {
            minX: tmpExtent[0],
            minY: tmpExtent[1],
            maxX: tmpExtent[2],
            maxY: tmpExtent[3],
            value: feature
          },
          canvasTransform: transform2,
          scale: scale5
        };
      }
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} contextScale Scale of the context.
       * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
       * @param {ImageOrLabelDimensions} dimensions Dimensions.
       * @param {number} opacity Opacity.
       * @param {Array<*>} fillInstruction Fill instruction.
       * @param {Array<*>} strokeInstruction Stroke instruction.
       * @return {boolean} The image or label was rendered.
       */
      replayImageOrLabel_(context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction2, strokeInstruction2) {
        const fillStroke = !!(fillInstruction2 || strokeInstruction2);
        const box = dimensions.declutterBox;
        const canvas = context.canvas;
        const strokePadding = strokeInstruction2 ? strokeInstruction2[2] * dimensions.scale[0] / 2 : 0;
        const intersects3 = box.minX - strokePadding <= canvas.width / contextScale && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= canvas.height / contextScale && box.maxY + strokePadding >= 0;
        if (intersects3) {
          if (fillStroke) {
            this.replayTextBackground_(
              context,
              p1,
              p2,
              p3,
              p4,
              /** @type {Array<*>} */
              fillInstruction2,
              /** @type {Array<*>} */
              strokeInstruction2
            );
          }
          drawImageOrLabel(
            context,
            dimensions.canvasTransform,
            opacity,
            imageOrLabel,
            dimensions.originX,
            dimensions.originY,
            dimensions.drawImageW,
            dimensions.drawImageH,
            dimensions.drawImageX,
            dimensions.drawImageY,
            dimensions.scale
          );
        }
        return true;
      }
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       */
      fill_(context) {
        if (this.alignFill_) {
          const origin = apply(this.renderedTransform_, [0, 0]);
          const repeatSize = 512 * this.pixelRatio;
          context.save();
          context.translate(origin[0] % repeatSize, origin[1] % repeatSize);
          context.rotate(this.viewRotation_);
        }
        context.fill();
        if (this.alignFill_) {
          context.restore();
        }
      }
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       * @param {Array<*>} instruction Instruction.
       */
      setStrokeStyle_(context, instruction) {
        context["strokeStyle"] = /** @type {import("../../colorlike.js").ColorLike} */
        instruction[1];
        context.lineWidth = /** @type {number} */
        instruction[2];
        context.lineCap = /** @type {CanvasLineCap} */
        instruction[3];
        context.lineJoin = /** @type {CanvasLineJoin} */
        instruction[4];
        context.miterLimit = /** @type {number} */
        instruction[5];
        context.lineDashOffset = /** @type {number} */
        instruction[7];
        context.setLineDash(
          /** @type {Array<number>} */
          instruction[6]
        );
      }
      /**
       * @private
       * @param {string|Array<string>} text The text to draw.
       * @param {string} textKey The key of the text state.
       * @param {string} strokeKey The key for the stroke state.
       * @param {string} fillKey The key for the fill state.
       * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
       */
      drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey) {
        const textState = this.textStates[textKey];
        const label = this.createLabel(text, textKey, fillKey, strokeKey);
        const strokeState = this.strokeStates[strokeKey];
        const pixelRatio = this.pixelRatio;
        const align = horizontalTextAlign(
          Array.isArray(text) ? text[0] : text,
          textState.textAlign || defaultTextAlign
        );
        const baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];
        const strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
        const width = label.width / pixelRatio - 2 * textState.scale[0];
        const anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
        const anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
        return {
          label,
          anchorX,
          anchorY
        };
      }
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} contextScale Scale of the context.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {Array<*>} instructions Instructions array.
       * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
       * @param {FeatureCallback<T>} [featureCallback] Feature callback.
       * @param {import("../../extent.js").Extent} [hitExtent] Only check
       *     features that intersect this extent.
       * @param {import("rbush").default} [declutterTree] Declutter tree.
       * @return {T|undefined} Callback result.
       * @template T
       */
      execute_(context, contextScale, transform2, instructions, snapToPixel, featureCallback, hitExtent, declutterTree) {
        let pixelCoordinates;
        if (this.pixelCoordinates_ && equals(transform2, this.renderedTransform_)) {
          pixelCoordinates = this.pixelCoordinates_;
        } else {
          if (!this.pixelCoordinates_) {
            this.pixelCoordinates_ = [];
          }
          pixelCoordinates = transform2D(
            this.coordinates,
            0,
            this.coordinates.length,
            2,
            transform2,
            this.pixelCoordinates_
          );
          setFromArray(this.renderedTransform_, transform2);
        }
        let i = 0;
        const ii = instructions.length;
        let d = 0;
        let dd;
        let anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;
        let pendingFill = 0;
        let pendingStroke = 0;
        let lastFillInstruction = null;
        let lastStrokeInstruction = null;
        const coordinateCache = this.coordinateCache_;
        const viewRotation = this.viewRotation_;
        const viewRotationFromTransform = Math.round(Math.atan2(-transform2[1], transform2[0]) * 1e12) / 1e12;
        const state = (
          /** @type {import("../../render.js").State} */
          {
            context,
            pixelRatio: this.pixelRatio,
            resolution: this.resolution,
            rotation: viewRotation
          }
        );
        const batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
        let feature;
        let x, y, currentGeometry;
        while (i < ii) {
          const instruction = instructions[i];
          const type = (
            /** @type {import("./Instruction.js").default} */
            instruction[0]
          );
          switch (type) {
            case Instruction_default.BEGIN_GEOMETRY:
              feature = /** @type {import("../../Feature.js").FeatureLike} */
              instruction[1];
              currentGeometry = instruction[3];
              if (!feature.getGeometry()) {
                i = /** @type {number} */
                instruction[2];
              } else if (hitExtent !== void 0 && !intersects(hitExtent, currentGeometry.getExtent())) {
                i = /** @type {number} */
                instruction[2] + 1;
              } else {
                ++i;
              }
              break;
            case Instruction_default.BEGIN_PATH:
              if (pendingFill > batchSize) {
                this.fill_(context);
                pendingFill = 0;
              }
              if (pendingStroke > batchSize) {
                context.stroke();
                pendingStroke = 0;
              }
              if (!pendingFill && !pendingStroke) {
                context.beginPath();
                prevX = NaN;
                prevY = NaN;
              }
              ++i;
              break;
            case Instruction_default.CIRCLE:
              d = /** @type {number} */
              instruction[1];
              const x1 = pixelCoordinates[d];
              const y1 = pixelCoordinates[d + 1];
              const x2 = pixelCoordinates[d + 2];
              const y2 = pixelCoordinates[d + 3];
              const dx = x2 - x1;
              const dy = y2 - y1;
              const r = Math.sqrt(dx * dx + dy * dy);
              context.moveTo(x1 + r, y1);
              context.arc(x1, y1, r, 0, 2 * Math.PI, true);
              ++i;
              break;
            case Instruction_default.CLOSE_PATH:
              context.closePath();
              ++i;
              break;
            case Instruction_default.CUSTOM:
              d = /** @type {number} */
              instruction[1];
              dd = instruction[2];
              const geometry = (
                /** @type {import("../../geom/SimpleGeometry.js").default} */
                instruction[3]
              );
              const renderer = instruction[4];
              const fn = instruction.length == 6 ? instruction[5] : void 0;
              state.geometry = geometry;
              state.feature = feature;
              if (!(i in coordinateCache)) {
                coordinateCache[i] = [];
              }
              const coords = coordinateCache[i];
              if (fn) {
                fn(pixelCoordinates, d, dd, 2, coords);
              } else {
                coords[0] = pixelCoordinates[d];
                coords[1] = pixelCoordinates[d + 1];
                coords.length = 2;
              }
              renderer(coords, state);
              ++i;
              break;
            case Instruction_default.DRAW_IMAGE:
              d = /** @type {number} */
              instruction[1];
              dd = /** @type {number} */
              instruction[2];
              image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
              instruction[3];
              anchorX = /** @type {number} */
              instruction[4];
              anchorY = /** @type {number} */
              instruction[5];
              let height = (
                /** @type {number} */
                instruction[6]
              );
              const opacity = (
                /** @type {number} */
                instruction[7]
              );
              const originX = (
                /** @type {number} */
                instruction[8]
              );
              const originY = (
                /** @type {number} */
                instruction[9]
              );
              const rotateWithView = (
                /** @type {boolean} */
                instruction[10]
              );
              let rotation = (
                /** @type {number} */
                instruction[11]
              );
              const scale5 = (
                /** @type {import("../../size.js").Size} */
                instruction[12]
              );
              let width = (
                /** @type {number} */
                instruction[13]
              );
              const declutterMode = (
                /** @type {"declutter"|"obstacle"|"none"|undefined} */
                instruction[14]
              );
              const declutterImageWithText = (
                /** @type {import("../canvas.js").DeclutterImageWithText} */
                instruction[15]
              );
              if (!image && instruction.length >= 20) {
                text = /** @type {string} */
                instruction[19];
                textKey = /** @type {string} */
                instruction[20];
                strokeKey = /** @type {string} */
                instruction[21];
                fillKey = /** @type {string} */
                instruction[22];
                const labelWithAnchor = this.drawLabelWithPointPlacement_(
                  text,
                  textKey,
                  strokeKey,
                  fillKey
                );
                image = labelWithAnchor.label;
                instruction[3] = image;
                const textOffsetX = (
                  /** @type {number} */
                  instruction[23]
                );
                anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
                instruction[4] = anchorX;
                const textOffsetY = (
                  /** @type {number} */
                  instruction[24]
                );
                anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
                instruction[5] = anchorY;
                height = image.height;
                instruction[6] = height;
                width = image.width;
                instruction[13] = width;
              }
              let geometryWidths;
              if (instruction.length > 25) {
                geometryWidths = /** @type {number} */
                instruction[25];
              }
              let padding, backgroundFill, backgroundStroke;
              if (instruction.length > 17) {
                padding = /** @type {Array<number>} */
                instruction[16];
                backgroundFill = /** @type {boolean} */
                instruction[17];
                backgroundStroke = /** @type {boolean} */
                instruction[18];
              } else {
                padding = defaultPadding;
                backgroundFill = false;
                backgroundStroke = false;
              }
              if (rotateWithView && viewRotationFromTransform) {
                rotation += viewRotation;
              } else if (!rotateWithView && !viewRotationFromTransform) {
                rotation -= viewRotation;
              }
              let widthIndex = 0;
              for (; d < dd; d += 2) {
                if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {
                  continue;
                }
                const dimensions = this.calculateImageOrLabelDimensions_(
                  image.width,
                  image.height,
                  pixelCoordinates[d],
                  pixelCoordinates[d + 1],
                  width,
                  height,
                  anchorX,
                  anchorY,
                  originX,
                  originY,
                  rotation,
                  scale5,
                  snapToPixel,
                  padding,
                  backgroundFill || backgroundStroke,
                  feature
                );
                const args = [
                  context,
                  contextScale,
                  image,
                  dimensions,
                  opacity,
                  backgroundFill ? (
                    /** @type {Array<*>} */
                    lastFillInstruction
                  ) : null,
                  backgroundStroke ? (
                    /** @type {Array<*>} */
                    lastStrokeInstruction
                  ) : null
                ];
                if (declutterTree) {
                  if (declutterMode === "none") {
                    continue;
                  } else if (declutterMode === "obstacle") {
                    declutterTree.insert(dimensions.declutterBox);
                    continue;
                  } else {
                    let imageArgs;
                    let imageDeclutterBox;
                    if (declutterImageWithText) {
                      const index = dd - d;
                      if (!declutterImageWithText[index]) {
                        declutterImageWithText[index] = args;
                        continue;
                      }
                      imageArgs = declutterImageWithText[index];
                      delete declutterImageWithText[index];
                      imageDeclutterBox = getDeclutterBox(imageArgs);
                      if (declutterTree.collides(imageDeclutterBox)) {
                        continue;
                      }
                    }
                    if (declutterTree.collides(dimensions.declutterBox)) {
                      continue;
                    }
                    if (imageArgs) {
                      declutterTree.insert(imageDeclutterBox);
                      this.replayImageOrLabel_.apply(this, imageArgs);
                    }
                    declutterTree.insert(dimensions.declutterBox);
                  }
                }
                this.replayImageOrLabel_.apply(this, args);
              }
              ++i;
              break;
            case Instruction_default.DRAW_CHARS:
              const begin = (
                /** @type {number} */
                instruction[1]
              );
              const end = (
                /** @type {number} */
                instruction[2]
              );
              const baseline = (
                /** @type {number} */
                instruction[3]
              );
              const overflow = (
                /** @type {number} */
                instruction[4]
              );
              fillKey = /** @type {string} */
              instruction[5];
              const maxAngle = (
                /** @type {number} */
                instruction[6]
              );
              const measurePixelRatio = (
                /** @type {number} */
                instruction[7]
              );
              const offsetY = (
                /** @type {number} */
                instruction[8]
              );
              strokeKey = /** @type {string} */
              instruction[9];
              const strokeWidth = (
                /** @type {number} */
                instruction[10]
              );
              text = /** @type {string} */
              instruction[11];
              textKey = /** @type {string} */
              instruction[12];
              const pixelRatioScale = [
                /** @type {number} */
                instruction[13],
                /** @type {number} */
                instruction[13]
              ];
              const textState = this.textStates[textKey];
              const font = textState.font;
              const textScale = [
                textState.scale[0] * measurePixelRatio,
                textState.scale[1] * measurePixelRatio
              ];
              let cachedWidths;
              if (font in this.widths_) {
                cachedWidths = this.widths_[font];
              } else {
                cachedWidths = {};
                this.widths_[font] = cachedWidths;
              }
              const pathLength = lineStringLength(pixelCoordinates, begin, end, 2);
              const textLength = Math.abs(textScale[0]) * measureAndCacheTextWidth(font, text, cachedWidths);
              if (overflow || textLength <= pathLength) {
                const textAlign = this.textStates[textKey].textAlign;
                const startM = (pathLength - textLength) * horizontalTextAlign(text, textAlign);
                const parts = drawTextOnPath(
                  pixelCoordinates,
                  begin,
                  end,
                  2,
                  text,
                  startM,
                  maxAngle,
                  Math.abs(textScale[0]),
                  measureAndCacheTextWidth,
                  font,
                  cachedWidths,
                  viewRotationFromTransform ? 0 : this.viewRotation_
                );
                drawChars:
                  if (parts) {
                    const replayImageOrLabelArgs = [];
                    let c, cc, chars, label, part;
                    if (strokeKey) {
                      for (c = 0, cc = parts.length; c < cc; ++c) {
                        part = parts[c];
                        chars = /** @type {string} */
                        part[4];
                        label = this.createLabel(chars, textKey, "", strokeKey);
                        anchorX = /** @type {number} */
                        part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                        anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;
                        const dimensions = this.calculateImageOrLabelDimensions_(
                          label.width,
                          label.height,
                          part[0],
                          part[1],
                          label.width,
                          label.height,
                          anchorX,
                          anchorY,
                          0,
                          0,
                          part[3],
                          pixelRatioScale,
                          false,
                          defaultPadding,
                          false,
                          feature
                        );
                        if (declutterTree && declutterTree.collides(dimensions.declutterBox)) {
                          break drawChars;
                        }
                        replayImageOrLabelArgs.push([
                          context,
                          contextScale,
                          label,
                          dimensions,
                          1,
                          null,
                          null
                        ]);
                      }
                    }
                    if (fillKey) {
                      for (c = 0, cc = parts.length; c < cc; ++c) {
                        part = parts[c];
                        chars = /** @type {string} */
                        part[4];
                        label = this.createLabel(chars, textKey, fillKey, "");
                        anchorX = /** @type {number} */
                        part[2];
                        anchorY = baseline * label.height - offsetY;
                        const dimensions = this.calculateImageOrLabelDimensions_(
                          label.width,
                          label.height,
                          part[0],
                          part[1],
                          label.width,
                          label.height,
                          anchorX,
                          anchorY,
                          0,
                          0,
                          part[3],
                          pixelRatioScale,
                          false,
                          defaultPadding,
                          false,
                          feature
                        );
                        if (declutterTree && declutterTree.collides(dimensions.declutterBox)) {
                          break drawChars;
                        }
                        replayImageOrLabelArgs.push([
                          context,
                          contextScale,
                          label,
                          dimensions,
                          1,
                          null,
                          null
                        ]);
                      }
                    }
                    if (declutterTree) {
                      declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
                    }
                    for (let i2 = 0, ii2 = replayImageOrLabelArgs.length; i2 < ii2; ++i2) {
                      this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i2]);
                    }
                  }
              }
              ++i;
              break;
            case Instruction_default.END_GEOMETRY:
              if (featureCallback !== void 0) {
                feature = /** @type {import("../../Feature.js").FeatureLike} */
                instruction[1];
                const result = featureCallback(feature, currentGeometry);
                if (result) {
                  return result;
                }
              }
              ++i;
              break;
            case Instruction_default.FILL:
              if (batchSize) {
                pendingFill++;
              } else {
                this.fill_(context);
              }
              ++i;
              break;
            case Instruction_default.MOVE_TO_LINE_TO:
              d = /** @type {number} */
              instruction[1];
              dd = /** @type {number} */
              instruction[2];
              x = pixelCoordinates[d];
              y = pixelCoordinates[d + 1];
              roundX = x + 0.5 | 0;
              roundY = y + 0.5 | 0;
              if (roundX !== prevX || roundY !== prevY) {
                context.moveTo(x, y);
                prevX = roundX;
                prevY = roundY;
              }
              for (d += 2; d < dd; d += 2) {
                x = pixelCoordinates[d];
                y = pixelCoordinates[d + 1];
                roundX = x + 0.5 | 0;
                roundY = y + 0.5 | 0;
                if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
                  context.lineTo(x, y);
                  prevX = roundX;
                  prevY = roundY;
                }
              }
              ++i;
              break;
            case Instruction_default.SET_FILL_STYLE:
              lastFillInstruction = instruction;
              this.alignFill_ = instruction[2];
              if (pendingFill) {
                this.fill_(context);
                pendingFill = 0;
                if (pendingStroke) {
                  context.stroke();
                  pendingStroke = 0;
                }
              }
              context.fillStyle = /** @type {import("../../colorlike.js").ColorLike} */
              instruction[1];
              ++i;
              break;
            case Instruction_default.SET_STROKE_STYLE:
              lastStrokeInstruction = instruction;
              if (pendingStroke) {
                context.stroke();
                pendingStroke = 0;
              }
              this.setStrokeStyle_(
                context,
                /** @type {Array<*>} */
                instruction
              );
              ++i;
              break;
            case Instruction_default.STROKE:
              if (batchSize) {
                pendingStroke++;
              } else {
                context.stroke();
              }
              ++i;
              break;
            default:
              ++i;
              break;
          }
        }
        if (pendingFill) {
          this.fill_(context);
        }
        if (pendingStroke) {
          context.stroke();
        }
        return void 0;
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} contextScale Scale of the context.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
       * @param {import("rbush").default} [declutterTree] Declutter tree.
       */
      execute(context, contextScale, transform2, viewRotation, snapToPixel, declutterTree) {
        this.viewRotation_ = viewRotation;
        this.execute_(
          context,
          contextScale,
          transform2,
          this.instructions,
          snapToPixel,
          void 0,
          void 0,
          declutterTree
        );
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {FeatureCallback<T>} [featureCallback] Feature callback.
       * @param {import("../../extent.js").Extent} [hitExtent] Only check
       *     features that intersect this extent.
       * @return {T|undefined} Callback result.
       * @template T
       */
      executeHitDetection(context, transform2, viewRotation, featureCallback, hitExtent) {
        this.viewRotation_ = viewRotation;
        return this.execute_(
          context,
          1,
          transform2,
          this.hitDetectionInstructions,
          true,
          featureCallback,
          hitExtent
        );
      }
    };
    Executor_default = Executor;
  }
});

// node_modules/ol/render/canvas/ExecutorGroup.js
function getPixelIndexArray(radius) {
  if (circlePixelIndexArrayCache[radius] !== void 0) {
    return circlePixelIndexArrayCache[radius];
  }
  const size = radius * 2 + 1;
  const maxDistanceSq = radius * radius;
  const distances = new Array(maxDistanceSq + 1);
  for (let i = 0; i <= radius; ++i) {
    for (let j = 0; j <= radius; ++j) {
      const distanceSq = i * i + j * j;
      if (distanceSq > maxDistanceSq) {
        break;
      }
      let distance2 = distances[distanceSq];
      if (!distance2) {
        distance2 = [];
        distances[distanceSq] = distance2;
      }
      distance2.push(((radius + i) * size + (radius + j)) * 4 + 3);
      if (i > 0) {
        distance2.push(((radius - i) * size + (radius + j)) * 4 + 3);
      }
      if (j > 0) {
        distance2.push(((radius + i) * size + (radius - j)) * 4 + 3);
        if (i > 0) {
          distance2.push(((radius - i) * size + (radius - j)) * 4 + 3);
        }
      }
    }
  }
  const pixelIndex = [];
  for (let i = 0, ii = distances.length; i < ii; ++i) {
    if (distances[i]) {
      pixelIndex.push(...distances[i]);
    }
  }
  circlePixelIndexArrayCache[radius] = pixelIndex;
  return pixelIndex;
}
var ORDER, ExecutorGroup, circlePixelIndexArrayCache, ExecutorGroup_default;
var init_ExecutorGroup = __esm({
  "node_modules/ol/render/canvas/ExecutorGroup.js"() {
    init_Executor();
    init_array();
    init_extent();
    init_transform();
    init_dom();
    init_obj();
    init_transform2();
    ORDER = ["Polygon", "Circle", "LineString", "Image", "Text", "Default"];
    ExecutorGroup = class {
      /**
       * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
       * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
       * should be set here, unless the target context does not exceed that extent (which
       * can be the case when rendering to tiles).
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {boolean} overlaps The executor group can have overlapping geometries.
       * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
       * The serializable instructions.
       * @param {number} [renderBuffer] Optional rendering buffer.
       */
      constructor(maxExtent, resolution, pixelRatio, overlaps, allInstructions, renderBuffer) {
        this.maxExtent_ = maxExtent;
        this.overlaps_ = overlaps;
        this.pixelRatio_ = pixelRatio;
        this.resolution_ = resolution;
        this.renderBuffer_ = renderBuffer;
        this.executorsByZIndex_ = {};
        this.hitDetectionContext_ = null;
        this.hitDetectionTransform_ = create();
        this.createExecutors_(allInstructions);
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../transform.js").Transform} transform Transform.
       */
      clip(context, transform2) {
        const flatClipCoords = this.getClipCoords(transform2);
        context.beginPath();
        context.moveTo(flatClipCoords[0], flatClipCoords[1]);
        context.lineTo(flatClipCoords[2], flatClipCoords[3]);
        context.lineTo(flatClipCoords[4], flatClipCoords[5]);
        context.lineTo(flatClipCoords[6], flatClipCoords[7]);
        context.clip();
      }
      /**
       * Create executors and populate them using the provided instructions.
       * @private
       * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
       */
      createExecutors_(allInstructions) {
        for (const zIndex in allInstructions) {
          let executors = this.executorsByZIndex_[zIndex];
          if (executors === void 0) {
            executors = {};
            this.executorsByZIndex_[zIndex] = executors;
          }
          const instructionByZindex = allInstructions[zIndex];
          for (const builderType in instructionByZindex) {
            const instructions = instructionByZindex[builderType];
            executors[builderType] = new Executor_default(
              this.resolution_,
              this.pixelRatio_,
              this.overlaps_,
              instructions
            );
          }
        }
      }
      /**
       * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
       * @return {boolean} Has executors of the provided types.
       */
      hasExecutors(executors) {
        for (const zIndex in this.executorsByZIndex_) {
          const candidates = this.executorsByZIndex_[zIndex];
          for (let i = 0, ii = executors.length; i < ii; ++i) {
            if (executors[i] in candidates) {
              return true;
            }
          }
        }
        return false;
      }
      /**
       * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
       * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
       * @return {T|undefined} Callback result.
       * @template T
       */
      forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
        hitTolerance = Math.round(hitTolerance);
        const contextSize = hitTolerance * 2 + 1;
        const transform2 = compose(
          this.hitDetectionTransform_,
          hitTolerance + 0.5,
          hitTolerance + 0.5,
          1 / resolution,
          -1 / resolution,
          -rotation,
          -coordinate[0],
          -coordinate[1]
        );
        const newContext = !this.hitDetectionContext_;
        if (newContext) {
          this.hitDetectionContext_ = createCanvasContext2D(
            contextSize,
            contextSize,
            void 0,
            { willReadFrequently: true }
          );
        }
        const context = this.hitDetectionContext_;
        if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
          context.canvas.width = contextSize;
          context.canvas.height = contextSize;
        } else if (!newContext) {
          context.clearRect(0, 0, contextSize, contextSize);
        }
        let hitExtent;
        if (this.renderBuffer_ !== void 0) {
          hitExtent = createEmpty();
          extendCoordinate(hitExtent, coordinate);
          buffer(
            hitExtent,
            resolution * (this.renderBuffer_ + hitTolerance),
            hitExtent
          );
        }
        const indexes = getPixelIndexArray(hitTolerance);
        let builderType;
        function featureCallback(feature, geometry) {
          const imageData = context.getImageData(
            0,
            0,
            contextSize,
            contextSize
          ).data;
          for (let i2 = 0, ii = indexes.length; i2 < ii; i2++) {
            if (imageData[indexes[i2]] > 0) {
              if (!declutteredFeatures || builderType !== "Image" && builderType !== "Text" || declutteredFeatures.includes(feature)) {
                const idx = (indexes[i2] - 3) / 4;
                const x = hitTolerance - idx % contextSize;
                const y = hitTolerance - (idx / contextSize | 0);
                const result2 = callback(feature, geometry, x * x + y * y);
                if (result2) {
                  return result2;
                }
              }
              context.clearRect(0, 0, contextSize, contextSize);
              break;
            }
          }
          return void 0;
        }
        const zs = Object.keys(this.executorsByZIndex_).map(Number);
        zs.sort(ascending);
        let i, j, executors, executor, result;
        for (i = zs.length - 1; i >= 0; --i) {
          const zIndexKey = zs[i].toString();
          executors = this.executorsByZIndex_[zIndexKey];
          for (j = ORDER.length - 1; j >= 0; --j) {
            builderType = ORDER[j];
            executor = executors[builderType];
            if (executor !== void 0) {
              result = executor.executeHitDetection(
                context,
                transform2,
                rotation,
                featureCallback,
                hitExtent
              );
              if (result) {
                return result;
              }
            }
          }
        }
        return void 0;
      }
      /**
       * @param {import("../../transform.js").Transform} transform Transform.
       * @return {Array<number>|null} Clip coordinates.
       */
      getClipCoords(transform2) {
        const maxExtent = this.maxExtent_;
        if (!maxExtent) {
          return null;
        }
        const minX = maxExtent[0];
        const minY = maxExtent[1];
        const maxX = maxExtent[2];
        const maxY = maxExtent[3];
        const flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
        transform2D(flatClipCoords, 0, 8, 2, transform2, flatClipCoords);
        return flatClipCoords;
      }
      /**
       * @return {boolean} Is empty.
       */
      isEmpty() {
        return isEmpty(this.executorsByZIndex_);
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} contextScale Scale of the context.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
       * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
       *     Default is {@link module:ol/render/replay~ORDER}
       * @param {import("rbush").default} [declutterTree] Declutter tree.
       */
      execute(context, contextScale, transform2, viewRotation, snapToPixel, builderTypes, declutterTree) {
        const zs = Object.keys(this.executorsByZIndex_).map(Number);
        zs.sort(ascending);
        if (this.maxExtent_) {
          context.save();
          this.clip(context, transform2);
        }
        builderTypes = builderTypes ? builderTypes : ORDER;
        let i, ii, j, jj, replays, replay;
        if (declutterTree) {
          zs.reverse();
        }
        for (i = 0, ii = zs.length; i < ii; ++i) {
          const zIndexKey = zs[i].toString();
          replays = this.executorsByZIndex_[zIndexKey];
          for (j = 0, jj = builderTypes.length; j < jj; ++j) {
            const builderType = builderTypes[j];
            replay = replays[builderType];
            if (replay !== void 0) {
              replay.execute(
                context,
                contextScale,
                transform2,
                viewRotation,
                snapToPixel,
                declutterTree
              );
            }
          }
        }
        if (this.maxExtent_) {
          context.restore();
        }
      }
    };
    circlePixelIndexArrayCache = {};
    ExecutorGroup_default = ExecutorGroup;
  }
});

// node_modules/ol/render/canvas/Immediate.js
var CanvasImmediateRenderer, Immediate_default;
var init_Immediate = __esm({
  "node_modules/ol/render/canvas/Immediate.js"() {
    init_VectorContext();
    init_colorlike();
    init_transform();
    init_canvas();
    init_array();
    init_extent();
    init_math();
    init_transform2();
    init_SimpleGeometry();
    CanvasImmediateRenderer = class extends VectorContext_default {
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../../extent.js").Extent} extent Extent.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
       * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
       */
      constructor(context, pixelRatio, extent, transform2, viewRotation, squaredTolerance, userTransform) {
        super();
        this.context_ = context;
        this.pixelRatio_ = pixelRatio;
        this.extent_ = extent;
        this.transform_ = transform2;
        this.transformRotation_ = transform2 ? toFixed(Math.atan2(transform2[1], transform2[0]), 10) : 0;
        this.viewRotation_ = viewRotation;
        this.squaredTolerance_ = squaredTolerance;
        this.userTransform_ = userTransform;
        this.contextFillState_ = null;
        this.contextStrokeState_ = null;
        this.contextTextState_ = null;
        this.fillState_ = null;
        this.strokeState_ = null;
        this.image_ = null;
        this.imageAnchorX_ = 0;
        this.imageAnchorY_ = 0;
        this.imageHeight_ = 0;
        this.imageOpacity_ = 0;
        this.imageOriginX_ = 0;
        this.imageOriginY_ = 0;
        this.imageRotateWithView_ = false;
        this.imageRotation_ = 0;
        this.imageScale_ = [0, 0];
        this.imageWidth_ = 0;
        this.text_ = "";
        this.textOffsetX_ = 0;
        this.textOffsetY_ = 0;
        this.textRotateWithView_ = false;
        this.textRotation_ = 0;
        this.textScale_ = [0, 0];
        this.textFillState_ = null;
        this.textStrokeState_ = null;
        this.textState_ = null;
        this.pixelCoordinates_ = [];
        this.tmpLocalTransform_ = create();
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       */
      drawImages_(flatCoordinates, offset2, end, stride) {
        if (!this.image_) {
          return;
        }
        const pixelCoordinates = transform2D(
          flatCoordinates,
          offset2,
          end,
          stride,
          this.transform_,
          this.pixelCoordinates_
        );
        const context = this.context_;
        const localTransform = this.tmpLocalTransform_;
        const alpha = context.globalAlpha;
        if (this.imageOpacity_ != 1) {
          context.globalAlpha = alpha * this.imageOpacity_;
        }
        let rotation = this.imageRotation_;
        if (this.transformRotation_ === 0) {
          rotation -= this.viewRotation_;
        }
        if (this.imageRotateWithView_) {
          rotation += this.viewRotation_;
        }
        for (let i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
          const x = pixelCoordinates[i] - this.imageAnchorX_;
          const y = pixelCoordinates[i + 1] - this.imageAnchorY_;
          if (rotation !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
            const centerX = x + this.imageAnchorX_;
            const centerY = y + this.imageAnchorY_;
            compose(
              localTransform,
              centerX,
              centerY,
              1,
              1,
              rotation,
              -centerX,
              -centerY
            );
            context.save();
            context.transform.apply(context, localTransform);
            context.translate(centerX, centerY);
            context.scale(this.imageScale_[0], this.imageScale_[1]);
            context.drawImage(
              this.image_,
              this.imageOriginX_,
              this.imageOriginY_,
              this.imageWidth_,
              this.imageHeight_,
              -this.imageAnchorX_,
              -this.imageAnchorY_,
              this.imageWidth_,
              this.imageHeight_
            );
            context.restore();
          } else {
            context.drawImage(
              this.image_,
              this.imageOriginX_,
              this.imageOriginY_,
              this.imageWidth_,
              this.imageHeight_,
              x,
              y,
              this.imageWidth_,
              this.imageHeight_
            );
          }
        }
        if (this.imageOpacity_ != 1) {
          context.globalAlpha = alpha;
        }
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       */
      drawText_(flatCoordinates, offset2, end, stride) {
        if (!this.textState_ || this.text_ === "") {
          return;
        }
        if (this.textFillState_) {
          this.setContextFillState_(this.textFillState_);
        }
        if (this.textStrokeState_) {
          this.setContextStrokeState_(this.textStrokeState_);
        }
        this.setContextTextState_(this.textState_);
        const pixelCoordinates = transform2D(
          flatCoordinates,
          offset2,
          end,
          stride,
          this.transform_,
          this.pixelCoordinates_
        );
        const context = this.context_;
        let rotation = this.textRotation_;
        if (this.transformRotation_ === 0) {
          rotation -= this.viewRotation_;
        }
        if (this.textRotateWithView_) {
          rotation += this.viewRotation_;
        }
        for (; offset2 < end; offset2 += stride) {
          const x = pixelCoordinates[offset2] + this.textOffsetX_;
          const y = pixelCoordinates[offset2 + 1] + this.textOffsetY_;
          if (rotation !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1) {
            context.save();
            context.translate(x - this.textOffsetX_, y - this.textOffsetY_);
            context.rotate(rotation);
            context.translate(this.textOffsetX_, this.textOffsetY_);
            context.scale(this.textScale_[0], this.textScale_[1]);
            if (this.textStrokeState_) {
              context.strokeText(this.text_, 0, 0);
            }
            if (this.textFillState_) {
              context.fillText(this.text_, 0, 0);
            }
            context.restore();
          } else {
            if (this.textStrokeState_) {
              context.strokeText(this.text_, x, y);
            }
            if (this.textFillState_) {
              context.fillText(this.text_, x, y);
            }
          }
        }
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @param {boolean} close Close.
       * @private
       * @return {number} end End.
       */
      moveToLineTo_(flatCoordinates, offset2, end, stride, close) {
        const context = this.context_;
        const pixelCoordinates = transform2D(
          flatCoordinates,
          offset2,
          end,
          stride,
          this.transform_,
          this.pixelCoordinates_
        );
        context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
        let length = pixelCoordinates.length;
        if (close) {
          length -= 2;
        }
        for (let i = 2; i < length; i += 2) {
          context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
        }
        if (close) {
          context.closePath();
        }
        return end;
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @private
       * @return {number} End.
       */
      drawRings_(flatCoordinates, offset2, ends, stride) {
        for (let i = 0, ii = ends.length; i < ii; ++i) {
          offset2 = this.moveToLineTo_(
            flatCoordinates,
            offset2,
            ends[i],
            stride,
            true
          );
        }
        return offset2;
      }
      /**
       * Render a circle geometry into the canvas.  Rendering is immediate and uses
       * the current fill and stroke styles.
       *
       * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
       * @api
       */
      drawCircle(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/Circle.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        if (!intersects(this.extent_, geometry.getExtent())) {
          return;
        }
        if (this.fillState_ || this.strokeState_) {
          if (this.fillState_) {
            this.setContextFillState_(this.fillState_);
          }
          if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
          }
          const pixelCoordinates = transformGeom2D(
            geometry,
            this.transform_,
            this.pixelCoordinates_
          );
          const dx = pixelCoordinates[2] - pixelCoordinates[0];
          const dy = pixelCoordinates[3] - pixelCoordinates[1];
          const radius = Math.sqrt(dx * dx + dy * dy);
          const context = this.context_;
          context.beginPath();
          context.arc(
            pixelCoordinates[0],
            pixelCoordinates[1],
            radius,
            0,
            2 * Math.PI
          );
          if (this.fillState_) {
            context.fill();
          }
          if (this.strokeState_) {
            context.stroke();
          }
        }
        if (this.text_ !== "") {
          this.drawText_(geometry.getCenter(), 0, 2, 2);
        }
      }
      /**
       * Set the rendering style.  Note that since this is an immediate rendering API,
       * any `zIndex` on the provided style will be ignored.
       *
       * @param {import("../../style/Style.js").default} style The rendering style.
       * @api
       */
      setStyle(style) {
        this.setFillStrokeStyle(style.getFill(), style.getStroke());
        this.setImageStyle(style.getImage());
        this.setTextStyle(style.getText());
      }
      /**
       * @param {import("../../transform.js").Transform} transform Transform.
       */
      setTransform(transform2) {
        this.transform_ = transform2;
      }
      /**
       * Render a geometry into the canvas.  Call
       * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
       *
       * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
       * @api
       */
      drawGeometry(geometry) {
        const type = geometry.getType();
        switch (type) {
          case "Point":
            this.drawPoint(
              /** @type {import("../../geom/Point.js").default} */
              geometry
            );
            break;
          case "LineString":
            this.drawLineString(
              /** @type {import("../../geom/LineString.js").default} */
              geometry
            );
            break;
          case "Polygon":
            this.drawPolygon(
              /** @type {import("../../geom/Polygon.js").default} */
              geometry
            );
            break;
          case "MultiPoint":
            this.drawMultiPoint(
              /** @type {import("../../geom/MultiPoint.js").default} */
              geometry
            );
            break;
          case "MultiLineString":
            this.drawMultiLineString(
              /** @type {import("../../geom/MultiLineString.js").default} */
              geometry
            );
            break;
          case "MultiPolygon":
            this.drawMultiPolygon(
              /** @type {import("../../geom/MultiPolygon.js").default} */
              geometry
            );
            break;
          case "GeometryCollection":
            this.drawGeometryCollection(
              /** @type {import("../../geom/GeometryCollection.js").default} */
              geometry
            );
            break;
          case "Circle":
            this.drawCircle(
              /** @type {import("../../geom/Circle.js").default} */
              geometry
            );
            break;
          default:
        }
      }
      /**
       * Render a feature into the canvas.  Note that any `zIndex` on the provided
       * style will be ignored - features are rendered immediately in the order that
       * this method is called.  If you need `zIndex` support, you should be using an
       * {@link module:ol/layer/Vector~VectorLayer} instead.
       *
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {import("../../style/Style.js").default} style Style.
       * @api
       */
      drawFeature(feature, style) {
        const geometry = style.getGeometryFunction()(feature);
        if (!geometry) {
          return;
        }
        this.setStyle(style);
        this.drawGeometry(geometry);
      }
      /**
       * Render a GeometryCollection to the canvas.  Rendering is immediate and
       * uses the current styles appropriate for each geometry in the collection.
       *
       * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
       */
      drawGeometryCollection(geometry) {
        const geometries = geometry.getGeometriesArray();
        for (let i = 0, ii = geometries.length; i < ii; ++i) {
          this.drawGeometry(geometries[i]);
        }
      }
      /**
       * Render a Point geometry into the canvas.  Rendering is immediate and uses
       * the current style.
       *
       * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
       */
      drawPoint(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/Point.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        const flatCoordinates = geometry.getFlatCoordinates();
        const stride = geometry.getStride();
        if (this.image_) {
          this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
        }
        if (this.text_ !== "") {
          this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
        }
      }
      /**
       * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
       * uses the current style.
       *
       * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
       */
      drawMultiPoint(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/MultiPoint.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        const flatCoordinates = geometry.getFlatCoordinates();
        const stride = geometry.getStride();
        if (this.image_) {
          this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
        }
        if (this.text_ !== "") {
          this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
        }
      }
      /**
       * Render a LineString into the canvas.  Rendering is immediate and uses
       * the current style.
       *
       * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
       */
      drawLineString(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/LineString.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        if (!intersects(this.extent_, geometry.getExtent())) {
          return;
        }
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
          const context = this.context_;
          const flatCoordinates = geometry.getFlatCoordinates();
          context.beginPath();
          this.moveToLineTo_(
            flatCoordinates,
            0,
            flatCoordinates.length,
            geometry.getStride(),
            false
          );
          context.stroke();
        }
        if (this.text_ !== "") {
          const flatMidpoint = geometry.getFlatMidpoint();
          this.drawText_(flatMidpoint, 0, 2, 2);
        }
      }
      /**
       * Render a MultiLineString geometry into the canvas.  Rendering is immediate
       * and uses the current style.
       *
       * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
       */
      drawMultiLineString(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/MultiLineString.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        const geometryExtent = geometry.getExtent();
        if (!intersects(this.extent_, geometryExtent)) {
          return;
        }
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
          const context = this.context_;
          const flatCoordinates = geometry.getFlatCoordinates();
          let offset2 = 0;
          const ends = (
            /** @type {Array<number>} */
            geometry.getEnds()
          );
          const stride = geometry.getStride();
          context.beginPath();
          for (let i = 0, ii = ends.length; i < ii; ++i) {
            offset2 = this.moveToLineTo_(
              flatCoordinates,
              offset2,
              ends[i],
              stride,
              false
            );
          }
          context.stroke();
        }
        if (this.text_ !== "") {
          const flatMidpoints = geometry.getFlatMidpoints();
          this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
        }
      }
      /**
       * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
       * the current style.
       *
       * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
       */
      drawPolygon(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/Polygon.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        if (!intersects(this.extent_, geometry.getExtent())) {
          return;
        }
        if (this.strokeState_ || this.fillState_) {
          if (this.fillState_) {
            this.setContextFillState_(this.fillState_);
          }
          if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
          }
          const context = this.context_;
          context.beginPath();
          this.drawRings_(
            geometry.getOrientedFlatCoordinates(),
            0,
            /** @type {Array<number>} */
            geometry.getEnds(),
            geometry.getStride()
          );
          if (this.fillState_) {
            context.fill();
          }
          if (this.strokeState_) {
            context.stroke();
          }
        }
        if (this.text_ !== "") {
          const flatInteriorPoint = geometry.getFlatInteriorPoint();
          this.drawText_(flatInteriorPoint, 0, 2, 2);
        }
      }
      /**
       * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
       * uses the current style.
       * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
       */
      drawMultiPolygon(geometry) {
        if (this.squaredTolerance_) {
          geometry = /** @type {import("../../geom/MultiPolygon.js").default} */
          geometry.simplifyTransformed(
            this.squaredTolerance_,
            this.userTransform_
          );
        }
        if (!intersects(this.extent_, geometry.getExtent())) {
          return;
        }
        if (this.strokeState_ || this.fillState_) {
          if (this.fillState_) {
            this.setContextFillState_(this.fillState_);
          }
          if (this.strokeState_) {
            this.setContextStrokeState_(this.strokeState_);
          }
          const context = this.context_;
          const flatCoordinates = geometry.getOrientedFlatCoordinates();
          let offset2 = 0;
          const endss = geometry.getEndss();
          const stride = geometry.getStride();
          context.beginPath();
          for (let i = 0, ii = endss.length; i < ii; ++i) {
            const ends = endss[i];
            offset2 = this.drawRings_(flatCoordinates, offset2, ends, stride);
          }
          if (this.fillState_) {
            context.fill();
          }
          if (this.strokeState_) {
            context.stroke();
          }
        }
        if (this.text_ !== "") {
          const flatInteriorPoints = geometry.getFlatInteriorPoints();
          this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
        }
      }
      /**
       * @param {import("../canvas.js").FillState} fillState Fill state.
       * @private
       */
      setContextFillState_(fillState) {
        const context = this.context_;
        const contextFillState = this.contextFillState_;
        if (!contextFillState) {
          context.fillStyle = fillState.fillStyle;
          this.contextFillState_ = {
            fillStyle: fillState.fillStyle
          };
        } else {
          if (contextFillState.fillStyle != fillState.fillStyle) {
            contextFillState.fillStyle = fillState.fillStyle;
            context.fillStyle = fillState.fillStyle;
          }
        }
      }
      /**
       * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
       * @private
       */
      setContextStrokeState_(strokeState) {
        const context = this.context_;
        const contextStrokeState = this.contextStrokeState_;
        if (!contextStrokeState) {
          context.lineCap = strokeState.lineCap;
          context.setLineDash(strokeState.lineDash);
          context.lineDashOffset = strokeState.lineDashOffset;
          context.lineJoin = strokeState.lineJoin;
          context.lineWidth = strokeState.lineWidth;
          context.miterLimit = strokeState.miterLimit;
          context.strokeStyle = strokeState.strokeStyle;
          this.contextStrokeState_ = {
            lineCap: strokeState.lineCap,
            lineDash: strokeState.lineDash,
            lineDashOffset: strokeState.lineDashOffset,
            lineJoin: strokeState.lineJoin,
            lineWidth: strokeState.lineWidth,
            miterLimit: strokeState.miterLimit,
            strokeStyle: strokeState.strokeStyle
          };
        } else {
          if (contextStrokeState.lineCap != strokeState.lineCap) {
            contextStrokeState.lineCap = strokeState.lineCap;
            context.lineCap = strokeState.lineCap;
          }
          if (!equals(contextStrokeState.lineDash, strokeState.lineDash)) {
            context.setLineDash(
              contextStrokeState.lineDash = strokeState.lineDash
            );
          }
          if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
            contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
            context.lineDashOffset = strokeState.lineDashOffset;
          }
          if (contextStrokeState.lineJoin != strokeState.lineJoin) {
            contextStrokeState.lineJoin = strokeState.lineJoin;
            context.lineJoin = strokeState.lineJoin;
          }
          if (contextStrokeState.lineWidth != strokeState.lineWidth) {
            contextStrokeState.lineWidth = strokeState.lineWidth;
            context.lineWidth = strokeState.lineWidth;
          }
          if (contextStrokeState.miterLimit != strokeState.miterLimit) {
            contextStrokeState.miterLimit = strokeState.miterLimit;
            context.miterLimit = strokeState.miterLimit;
          }
          if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
            contextStrokeState.strokeStyle = strokeState.strokeStyle;
            context.strokeStyle = strokeState.strokeStyle;
          }
        }
      }
      /**
       * @param {import("../canvas.js").TextState} textState Text state.
       * @private
       */
      setContextTextState_(textState) {
        const context = this.context_;
        const contextTextState = this.contextTextState_;
        const textAlign = textState.textAlign ? textState.textAlign : defaultTextAlign;
        if (!contextTextState) {
          context.font = textState.font;
          context.textAlign = textAlign;
          context.textBaseline = textState.textBaseline;
          this.contextTextState_ = {
            font: textState.font,
            textAlign,
            textBaseline: textState.textBaseline
          };
        } else {
          if (contextTextState.font != textState.font) {
            contextTextState.font = textState.font;
            context.font = textState.font;
          }
          if (contextTextState.textAlign != textAlign) {
            contextTextState.textAlign = textAlign;
            context.textAlign = textAlign;
          }
          if (contextTextState.textBaseline != textState.textBaseline) {
            contextTextState.textBaseline = textState.textBaseline;
            context.textBaseline = textState.textBaseline;
          }
        }
      }
      /**
       * Set the fill and stroke style for subsequent draw operations.  To clear
       * either fill or stroke styles, pass null for the appropriate parameter.
       *
       * @param {import("../../style/Fill.js").default} fillStyle Fill style.
       * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
       */
      setFillStrokeStyle(fillStyle, strokeStyle) {
        if (!fillStyle) {
          this.fillState_ = null;
        } else {
          const fillStyleColor = fillStyle.getColor();
          this.fillState_ = {
            fillStyle: asColorLike(
              fillStyleColor ? fillStyleColor : defaultFillStyle
            )
          };
        }
        if (!strokeStyle) {
          this.strokeState_ = null;
        } else {
          const strokeStyleColor = strokeStyle.getColor();
          const strokeStyleLineCap = strokeStyle.getLineCap();
          const strokeStyleLineDash = strokeStyle.getLineDash();
          const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
          const strokeStyleLineJoin = strokeStyle.getLineJoin();
          const strokeStyleWidth = strokeStyle.getWidth();
          const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
          const lineDash = strokeStyleLineDash ? strokeStyleLineDash : defaultLineDash;
          this.strokeState_ = {
            lineCap: strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap,
            lineDash: this.pixelRatio_ === 1 ? lineDash : lineDash.map((n) => n * this.pixelRatio_),
            lineDashOffset: (strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset) * this.pixelRatio_,
            lineJoin: strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin,
            lineWidth: (strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth) * this.pixelRatio_,
            miterLimit: strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit,
            strokeStyle: asColorLike(
              strokeStyleColor ? strokeStyleColor : defaultStrokeStyle
            )
          };
        }
      }
      /**
       * Set the image style for subsequent draw operations.  Pass null to remove
       * the image style.
       *
       * @param {import("../../style/Image.js").default} imageStyle Image style.
       */
      setImageStyle(imageStyle) {
        let imageSize;
        if (!imageStyle || !(imageSize = imageStyle.getSize())) {
          this.image_ = null;
          return;
        }
        const imagePixelRatio = imageStyle.getPixelRatio(this.pixelRatio_);
        const imageAnchor = imageStyle.getAnchor();
        const imageOrigin = imageStyle.getOrigin();
        this.image_ = imageStyle.getImage(this.pixelRatio_);
        this.imageAnchorX_ = imageAnchor[0] * imagePixelRatio;
        this.imageAnchorY_ = imageAnchor[1] * imagePixelRatio;
        this.imageHeight_ = imageSize[1] * imagePixelRatio;
        this.imageOpacity_ = imageStyle.getOpacity();
        this.imageOriginX_ = imageOrigin[0];
        this.imageOriginY_ = imageOrigin[1];
        this.imageRotateWithView_ = imageStyle.getRotateWithView();
        this.imageRotation_ = imageStyle.getRotation();
        const imageScale = imageStyle.getScaleArray();
        this.imageScale_ = [
          imageScale[0] * this.pixelRatio_ / imagePixelRatio,
          imageScale[1] * this.pixelRatio_ / imagePixelRatio
        ];
        this.imageWidth_ = imageSize[0] * imagePixelRatio;
      }
      /**
       * Set the text style for subsequent draw operations.  Pass null to
       * remove the text style.
       *
       * @param {import("../../style/Text.js").default} textStyle Text style.
       */
      setTextStyle(textStyle) {
        if (!textStyle) {
          this.text_ = "";
        } else {
          const textFillStyle = textStyle.getFill();
          if (!textFillStyle) {
            this.textFillState_ = null;
          } else {
            const textFillStyleColor = textFillStyle.getColor();
            this.textFillState_ = {
              fillStyle: asColorLike(
                textFillStyleColor ? textFillStyleColor : defaultFillStyle
              )
            };
          }
          const textStrokeStyle = textStyle.getStroke();
          if (!textStrokeStyle) {
            this.textStrokeState_ = null;
          } else {
            const textStrokeStyleColor = textStrokeStyle.getColor();
            const textStrokeStyleLineCap = textStrokeStyle.getLineCap();
            const textStrokeStyleLineDash = textStrokeStyle.getLineDash();
            const textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
            const textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
            const textStrokeStyleWidth = textStrokeStyle.getWidth();
            const textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
            this.textStrokeState_ = {
              lineCap: textStrokeStyleLineCap !== void 0 ? textStrokeStyleLineCap : defaultLineCap,
              lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : defaultLineDash,
              lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : defaultLineDashOffset,
              lineJoin: textStrokeStyleLineJoin !== void 0 ? textStrokeStyleLineJoin : defaultLineJoin,
              lineWidth: textStrokeStyleWidth !== void 0 ? textStrokeStyleWidth : defaultLineWidth,
              miterLimit: textStrokeStyleMiterLimit !== void 0 ? textStrokeStyleMiterLimit : defaultMiterLimit,
              strokeStyle: asColorLike(
                textStrokeStyleColor ? textStrokeStyleColor : defaultStrokeStyle
              )
            };
          }
          const textFont = textStyle.getFont();
          const textOffsetX = textStyle.getOffsetX();
          const textOffsetY = textStyle.getOffsetY();
          const textRotateWithView = textStyle.getRotateWithView();
          const textRotation = textStyle.getRotation();
          const textScale = textStyle.getScaleArray();
          const textText = textStyle.getText();
          const textTextAlign = textStyle.getTextAlign();
          const textTextBaseline = textStyle.getTextBaseline();
          this.textState_ = {
            font: textFont !== void 0 ? textFont : defaultFont,
            textAlign: textTextAlign !== void 0 ? textTextAlign : defaultTextAlign,
            textBaseline: textTextBaseline !== void 0 ? textTextBaseline : defaultTextBaseline
          };
          this.text_ = textText !== void 0 ? Array.isArray(textText) ? textText.reduce((acc, t, i) => acc += i % 2 ? " " : t, "") : textText : "";
          this.textOffsetX_ = textOffsetX !== void 0 ? this.pixelRatio_ * textOffsetX : 0;
          this.textOffsetY_ = textOffsetY !== void 0 ? this.pixelRatio_ * textOffsetY : 0;
          this.textRotateWithView_ = textRotateWithView !== void 0 ? textRotateWithView : false;
          this.textRotation_ = textRotation !== void 0 ? textRotation : 0;
          this.textScale_ = [
            this.pixelRatio_ * textScale[0],
            this.pixelRatio_ * textScale[1]
          ];
        }
      }
    };
    Immediate_default = CanvasImmediateRenderer;
  }
});

// node_modules/ol/style.js
var init_style2 = __esm({
  "node_modules/ol/style.js"() {
    init_Circle();
    init_Fill();
    init_Icon();
    init_IconImage();
    init_Image2();
    init_RegularShape();
    init_Stroke();
    init_Style();
    init_Text();
  }
});

// node_modules/ol/render/canvas/hitdetect.js
function createHitDetectionImageData(size, transforms2, features, styleFunction, extent, resolution, rotation) {
  const width = size[0] * HIT_DETECT_RESOLUTION;
  const height = size[1] * HIT_DETECT_RESOLUTION;
  const context = createCanvasContext2D(width, height);
  context.imageSmoothingEnabled = false;
  const canvas = context.canvas;
  const renderer = new Immediate_default(
    context,
    HIT_DETECT_RESOLUTION,
    extent,
    null,
    rotation
  );
  const featureCount = features.length;
  const indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);
  const featuresByZIndex = {};
  for (let i = 1; i <= featureCount; ++i) {
    const feature = features[i - 1];
    const featureStyleFunction = feature.getStyleFunction() || styleFunction;
    if (!featureStyleFunction) {
      continue;
    }
    let styles = featureStyleFunction(feature, resolution);
    if (!styles) {
      continue;
    }
    if (!Array.isArray(styles)) {
      styles = [styles];
    }
    const index = i * indexFactor;
    const color = index.toString(16).padStart(7, "#00000");
    for (let j = 0, jj = styles.length; j < jj; ++j) {
      const originalStyle = styles[j];
      const geometry = originalStyle.getGeometryFunction()(feature);
      if (!geometry || !intersects(extent, geometry.getExtent())) {
        continue;
      }
      const style = originalStyle.clone();
      const fill = style.getFill();
      if (fill) {
        fill.setColor(color);
      }
      const stroke = style.getStroke();
      if (stroke) {
        stroke.setColor(color);
        stroke.setLineDash(null);
      }
      style.setText(void 0);
      const image = originalStyle.getImage();
      if (image) {
        const imgSize = image.getImageSize();
        if (!imgSize) {
          continue;
        }
        const imgContext = createCanvasContext2D(
          imgSize[0],
          imgSize[1],
          void 0,
          { alpha: false }
        );
        const img = imgContext.canvas;
        imgContext.fillStyle = color;
        imgContext.fillRect(0, 0, img.width, img.height);
        style.setImage(
          new Icon_default({
            img,
            anchor: image.getAnchor(),
            anchorXUnits: "pixels",
            anchorYUnits: "pixels",
            offset: image.getOrigin(),
            opacity: 1,
            size: image.getSize(),
            scale: image.getScale(),
            rotation: image.getRotation(),
            rotateWithView: image.getRotateWithView()
          })
        );
      }
      const zIndex = style.getZIndex() || 0;
      let byGeometryType = featuresByZIndex[zIndex];
      if (!byGeometryType) {
        byGeometryType = {};
        featuresByZIndex[zIndex] = byGeometryType;
        byGeometryType["Polygon"] = [];
        byGeometryType["Circle"] = [];
        byGeometryType["LineString"] = [];
        byGeometryType["Point"] = [];
      }
      const type = geometry.getType();
      if (type === "GeometryCollection") {
        const geometries = (
          /** @type {import("../../geom/GeometryCollection.js").default} */
          geometry.getGeometriesArrayRecursive()
        );
        for (let i2 = 0, ii = geometries.length; i2 < ii; ++i2) {
          const geometry2 = geometries[i2];
          byGeometryType[geometry2.getType().replace("Multi", "")].push(
            geometry2,
            style
          );
        }
      } else {
        byGeometryType[type.replace("Multi", "")].push(geometry, style);
      }
    }
  }
  const zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort(ascending);
  for (let i = 0, ii = zIndexKeys.length; i < ii; ++i) {
    const byGeometryType = featuresByZIndex[zIndexKeys[i]];
    for (const type in byGeometryType) {
      const geomAndStyle = byGeometryType[type];
      for (let j = 0, jj = geomAndStyle.length; j < jj; j += 2) {
        renderer.setStyle(geomAndStyle[j + 1]);
        for (let k = 0, kk = transforms2.length; k < kk; ++k) {
          renderer.setTransform(transforms2[k]);
          renderer.drawGeometry(geomAndStyle[j]);
        }
      }
    }
  }
  return context.getImageData(0, 0, canvas.width, canvas.height);
}
function hitDetect(pixel, features, imageData) {
  const resultFeatures = [];
  if (imageData) {
    const x = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);
    const y = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION);
    const index = (clamp(x, 0, imageData.width - 1) + clamp(y, 0, imageData.height - 1) * imageData.width) * 4;
    const r = imageData.data[index];
    const g = imageData.data[index + 1];
    const b = imageData.data[index + 2];
    const i = b + 256 * (g + 256 * r);
    const indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);
    if (i && i % indexFactor === 0) {
      resultFeatures.push(features[i / indexFactor - 1]);
    }
  }
  return resultFeatures;
}
var HIT_DETECT_RESOLUTION;
var init_hitdetect = __esm({
  "node_modules/ol/render/canvas/hitdetect.js"() {
    init_Immediate();
    init_style2();
    init_array();
    init_math();
    init_dom();
    init_extent();
    HIT_DETECT_RESOLUTION = 0.5;
  }
});

// node_modules/ol/renderer/vector.js
function defaultOrder(feature1, feature2) {
  return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);
}
function getSquaredTolerance(resolution, pixelRatio) {
  const tolerance = getTolerance(resolution, pixelRatio);
  return tolerance * tolerance;
}
function getTolerance(resolution, pixelRatio) {
  return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
}
function renderCircleGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  const fillStyle = style.getFill();
  const strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    const circleReplay = builderGroup.getBuilder(style.getZIndex(), "Circle");
    circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    circleReplay.drawCircle(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      "Text"
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
function renderFeature(replayGroup, feature, style, squaredTolerance, listener, transform2, declutterBuilderGroup) {
  let loading = false;
  const imageStyle = style.getImage();
  if (imageStyle) {
    const imageState = imageStyle.getImageState();
    if (imageState == ImageState_default.LOADED || imageState == ImageState_default.ERROR) {
      imageStyle.unlistenImageChange(listener);
    } else {
      if (imageState == ImageState_default.IDLE) {
        imageStyle.load();
      }
      imageStyle.listenImageChange(listener);
      loading = true;
    }
  }
  renderFeatureInternal(
    replayGroup,
    feature,
    style,
    squaredTolerance,
    transform2,
    declutterBuilderGroup
  );
  return loading;
}
function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, transform2, declutterBuilderGroup) {
  const geometry = style.getGeometryFunction()(feature);
  if (!geometry) {
    return;
  }
  const simplifiedGeometry = geometry.simplifyTransformed(
    squaredTolerance,
    transform2
  );
  const renderer = style.getRenderer();
  if (renderer) {
    renderGeometry(replayGroup, simplifiedGeometry, style, feature);
  } else {
    const geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
    geometryRenderer(
      replayGroup,
      simplifiedGeometry,
      style,
      feature,
      declutterBuilderGroup
    );
  }
}
function renderGeometry(replayGroup, geometry, style, feature) {
  if (geometry.getType() == "GeometryCollection") {
    const geometries = (
      /** @type {import("../geom/GeometryCollection.js").default} */
      geometry.getGeometries()
    );
    for (let i = 0, ii = geometries.length; i < ii; ++i) {
      renderGeometry(replayGroup, geometries[i], style, feature);
    }
    return;
  }
  const replay = replayGroup.getBuilder(style.getZIndex(), "Default");
  replay.drawCustom(
    /** @type {import("../geom/SimpleGeometry.js").default} */
    geometry,
    feature,
    style.getRenderer(),
    style.getHitDetectionRenderer()
  );
}
function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, declutterBuilderGroup) {
  const geometries = geometry.getGeometriesArray();
  let i, ii;
  for (i = 0, ii = geometries.length; i < ii; ++i) {
    const geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
    geometryRenderer(
      replayGroup,
      geometries[i],
      style,
      feature,
      declutterBuilderGroup
    );
  }
}
function renderLineStringGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  const strokeStyle = style.getStroke();
  if (strokeStyle) {
    const lineStringReplay = builderGroup.getBuilder(
      style.getZIndex(),
      "LineString"
    );
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawLineString(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      "Text"
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
function renderMultiLineStringGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  const strokeStyle = style.getStroke();
  if (strokeStyle) {
    const lineStringReplay = builderGroup.getBuilder(
      style.getZIndex(),
      "LineString"
    );
    lineStringReplay.setFillStrokeStyle(null, strokeStyle);
    lineStringReplay.drawMultiLineString(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      "Text"
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
function renderMultiPolygonGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  const fillStyle = style.getFill();
  const strokeStyle = style.getStroke();
  if (strokeStyle || fillStyle) {
    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), "Polygon");
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawMultiPolygon(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      "Text"
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
function renderPointGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  const imageStyle = style.getImage();
  const textStyle = style.getText();
  let declutterImageWithText;
  if (imageStyle) {
    if (imageStyle.getImageState() != ImageState_default.LOADED) {
      return;
    }
    let imageBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      const declutterMode = imageStyle.getDeclutterMode();
      if (declutterMode !== "none") {
        imageBuilderGroup = declutterBuilderGroup;
        if (declutterMode === "obstacle") {
          const imageReplay2 = builderGroup.getBuilder(
            style.getZIndex(),
            "Image"
          );
          imageReplay2.setImageStyle(imageStyle, declutterImageWithText);
          imageReplay2.drawPoint(geometry, feature);
        } else if (textStyle && textStyle.getText()) {
          declutterImageWithText = {};
        }
      }
    }
    const imageReplay = imageBuilderGroup.getBuilder(
      style.getZIndex(),
      "Image"
    );
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawPoint(geometry, feature);
  }
  if (textStyle && textStyle.getText()) {
    let textBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      textBuilderGroup = declutterBuilderGroup;
    }
    const textReplay = textBuilderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature);
  }
}
function renderMultiPointGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  const imageStyle = style.getImage();
  const textStyle = style.getText();
  let declutterImageWithText;
  if (imageStyle) {
    if (imageStyle.getImageState() != ImageState_default.LOADED) {
      return;
    }
    let imageBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      const declutterMode = imageStyle.getDeclutterMode();
      if (declutterMode !== "none") {
        imageBuilderGroup = declutterBuilderGroup;
        if (declutterMode === "obstacle") {
          const imageReplay2 = builderGroup.getBuilder(
            style.getZIndex(),
            "Image"
          );
          imageReplay2.setImageStyle(imageStyle, declutterImageWithText);
          imageReplay2.drawMultiPoint(geometry, feature);
        } else if (textStyle && textStyle.getText()) {
          declutterImageWithText = {};
        }
      }
    }
    const imageReplay = imageBuilderGroup.getBuilder(
      style.getZIndex(),
      "Image"
    );
    imageReplay.setImageStyle(imageStyle, declutterImageWithText);
    imageReplay.drawMultiPoint(geometry, feature);
  }
  if (textStyle && textStyle.getText()) {
    let textBuilderGroup = builderGroup;
    if (declutterBuilderGroup) {
      textBuilderGroup = declutterBuilderGroup;
    }
    const textReplay = textBuilderGroup.getBuilder(style.getZIndex(), "Text");
    textReplay.setTextStyle(textStyle, declutterImageWithText);
    textReplay.drawText(geometry, feature);
  }
}
function renderPolygonGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
  const fillStyle = style.getFill();
  const strokeStyle = style.getStroke();
  if (fillStyle || strokeStyle) {
    const polygonReplay = builderGroup.getBuilder(style.getZIndex(), "Polygon");
    polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
    polygonReplay.drawPolygon(geometry, feature);
  }
  const textStyle = style.getText();
  if (textStyle && textStyle.getText()) {
    const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
      style.getZIndex(),
      "Text"
    );
    textReplay.setTextStyle(textStyle);
    textReplay.drawText(geometry, feature);
  }
}
var SIMPLIFY_TOLERANCE, GEOMETRY_RENDERERS;
var init_vector = __esm({
  "node_modules/ol/renderer/vector.js"() {
    init_ImageState();
    init_util();
    SIMPLIFY_TOLERANCE = 0.5;
    GEOMETRY_RENDERERS = {
      "Point": renderPointGeometry,
      "LineString": renderLineStringGeometry,
      "Polygon": renderPolygonGeometry,
      "MultiPoint": renderMultiPointGeometry,
      "MultiLineString": renderMultiLineStringGeometry,
      "MultiPolygon": renderMultiPolygonGeometry,
      "GeometryCollection": renderGeometryCollectionGeometry,
      "Circle": renderCircleGeometry
    };
  }
});

// node_modules/ol/renderer/canvas/VectorLayer.js
var CanvasVectorLayerRenderer, VectorLayer_default;
var init_VectorLayer = __esm({
  "node_modules/ol/renderer/canvas/VectorLayer.js"() {
    init_BuilderGroup();
    init_Layer3();
    init_ExecutorGroup();
    init_EventType2();
    init_ViewHint();
    init_hitdetect();
    init_transform();
    init_extent();
    init_dom();
    init_vector();
    init_array();
    init_proj();
    init_util();
    init_coordinate();
    CanvasVectorLayerRenderer = class extends Layer_default3 {
      /**
       * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
       */
      constructor(vectorLayer) {
        super(vectorLayer);
        this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);
        this.animatingOrInteracting_;
        this.hitDetectionImageData_ = null;
        this.renderedFeatures_ = null;
        this.renderedRevision_ = -1;
        this.renderedResolution_ = NaN;
        this.renderedExtent_ = createEmpty();
        this.wrappedRenderedExtent_ = createEmpty();
        this.renderedRotation_;
        this.renderedCenter_ = null;
        this.renderedProjection_ = null;
        this.renderedRenderOrder_ = null;
        this.replayGroup_ = null;
        this.replayGroupChanged = true;
        this.declutterExecutorGroup = null;
        this.clipping = true;
        this.compositionContext_ = null;
        this.opacity_ = 1;
      }
      /**
       * @param {ExecutorGroup} executorGroup Executor group.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {import("rbush").default} [declutterTree] Declutter tree.
       */
      renderWorlds(executorGroup, frameState, declutterTree) {
        const extent = frameState.extent;
        const viewState = frameState.viewState;
        const center = viewState.center;
        const resolution = viewState.resolution;
        const projection = viewState.projection;
        const rotation = viewState.rotation;
        const projectionExtent = projection.getExtent();
        const vectorSource = this.getLayer().getSource();
        const pixelRatio = frameState.pixelRatio;
        const viewHints = frameState.viewHints;
        const snapToPixel = !(viewHints[ViewHint_default.ANIMATING] || viewHints[ViewHint_default.INTERACTING]);
        const context = this.compositionContext_;
        const width = Math.round(frameState.size[0] * pixelRatio);
        const height = Math.round(frameState.size[1] * pixelRatio);
        const multiWorld = vectorSource.getWrapX() && projection.canWrapX();
        const worldWidth = multiWorld ? getWidth(projectionExtent) : null;
        const endWorld = multiWorld ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1 : 1;
        let world = multiWorld ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth) : 0;
        do {
          const transform2 = this.getRenderTransform(
            center,
            resolution,
            rotation,
            pixelRatio,
            width,
            height,
            world * worldWidth
          );
          executorGroup.execute(
            context,
            1,
            transform2,
            rotation,
            snapToPixel,
            void 0,
            declutterTree
          );
        } while (++world < endWorld);
      }
      setupCompositionContext_() {
        if (this.opacity_ !== 1) {
          const compositionContext = createCanvasContext2D(
            this.context.canvas.width,
            this.context.canvas.height,
            canvasPool2
          );
          this.compositionContext_ = compositionContext;
        } else {
          this.compositionContext_ = this.context;
        }
      }
      releaseCompositionContext_() {
        if (this.opacity_ !== 1) {
          const alpha = this.context.globalAlpha;
          this.context.globalAlpha = this.opacity_;
          this.context.drawImage(this.compositionContext_.canvas, 0, 0);
          this.context.globalAlpha = alpha;
          releaseCanvas(this.compositionContext_);
          canvasPool2.push(this.compositionContext_.canvas);
          this.compositionContext_ = null;
        }
      }
      /**
       * Render declutter items for this layer
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       */
      renderDeclutter(frameState) {
        if (this.declutterExecutorGroup) {
          this.setupCompositionContext_();
          this.renderWorlds(
            this.declutterExecutorGroup,
            frameState,
            frameState.declutterTree
          );
          this.releaseCompositionContext_();
        }
      }
      /**
       * Render the layer.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {HTMLElement|null} target Target that may be used to render content to.
       * @return {HTMLElement|null} The rendered element.
       */
      renderFrame(frameState, target) {
        const pixelRatio = frameState.pixelRatio;
        const layerState = frameState.layerStatesArray[frameState.layerIndex];
        makeScale(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
        makeInverse(this.inversePixelTransform, this.pixelTransform);
        const canvasTransform = toString(this.pixelTransform);
        this.useContainer(target, canvasTransform, this.getBackground(frameState));
        const context = this.context;
        const canvas = context.canvas;
        const replayGroup = this.replayGroup_;
        const declutterExecutorGroup = this.declutterExecutorGroup;
        let render2 = replayGroup && !replayGroup.isEmpty() || declutterExecutorGroup && !declutterExecutorGroup.isEmpty();
        if (!render2) {
          const hasRenderListeners = this.getLayer().hasListener(EventType_default2.PRERENDER) || this.getLayer().hasListener(EventType_default2.POSTRENDER);
          if (!hasRenderListeners) {
            return null;
          }
        }
        const width = Math.round(frameState.size[0] * pixelRatio);
        const height = Math.round(frameState.size[1] * pixelRatio);
        if (canvas.width != width || canvas.height != height) {
          canvas.width = width;
          canvas.height = height;
          if (canvas.style.transform !== canvasTransform) {
            canvas.style.transform = canvasTransform;
          }
        } else if (!this.containerReused) {
          context.clearRect(0, 0, width, height);
        }
        this.preRender(context, frameState);
        const viewState = frameState.viewState;
        const projection = viewState.projection;
        this.opacity_ = layerState.opacity;
        this.setupCompositionContext_();
        let clipped = false;
        if (render2 && layerState.extent && this.clipping) {
          const layerExtent = fromUserExtent(layerState.extent, projection);
          render2 = intersects(layerExtent, frameState.extent);
          clipped = render2 && !containsExtent(layerExtent, frameState.extent);
          if (clipped) {
            this.clipUnrotated(this.compositionContext_, frameState, layerExtent);
          }
        }
        if (render2) {
          this.renderWorlds(replayGroup, frameState);
        }
        if (clipped) {
          this.compositionContext_.restore();
        }
        this.releaseCompositionContext_();
        this.postRender(context, frameState);
        if (this.renderedRotation_ !== viewState.rotation) {
          this.renderedRotation_ = viewState.rotation;
          this.hitDetectionImageData_ = null;
        }
        return this.container;
      }
      /**
       * Asynchronous layer level hit detection.
       * @param {import("../../pixel.js").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../../Feature").default>>} Promise
       * that resolves with an array of features.
       */
      getFeatures(pixel) {
        return new Promise((resolve) => {
          if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
            const size = [this.context.canvas.width, this.context.canvas.height];
            apply(this.pixelTransform, size);
            const center = this.renderedCenter_;
            const resolution = this.renderedResolution_;
            const rotation = this.renderedRotation_;
            const projection = this.renderedProjection_;
            const extent = this.wrappedRenderedExtent_;
            const layer = this.getLayer();
            const transforms2 = [];
            const width = size[0] * HIT_DETECT_RESOLUTION;
            const height = size[1] * HIT_DETECT_RESOLUTION;
            transforms2.push(
              this.getRenderTransform(
                center,
                resolution,
                rotation,
                HIT_DETECT_RESOLUTION,
                width,
                height,
                0
              ).slice()
            );
            const source = layer.getSource();
            const projectionExtent = projection.getExtent();
            if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent)) {
              let startX = extent[0];
              const worldWidth = getWidth(projectionExtent);
              let world = 0;
              let offsetX;
              while (startX < projectionExtent[0]) {
                --world;
                offsetX = worldWidth * world;
                transforms2.push(
                  this.getRenderTransform(
                    center,
                    resolution,
                    rotation,
                    HIT_DETECT_RESOLUTION,
                    width,
                    height,
                    offsetX
                  ).slice()
                );
                startX += worldWidth;
              }
              world = 0;
              startX = extent[2];
              while (startX > projectionExtent[2]) {
                ++world;
                offsetX = worldWidth * world;
                transforms2.push(
                  this.getRenderTransform(
                    center,
                    resolution,
                    rotation,
                    HIT_DETECT_RESOLUTION,
                    width,
                    height,
                    offsetX
                  ).slice()
                );
                startX -= worldWidth;
              }
            }
            this.hitDetectionImageData_ = createHitDetectionImageData(
              size,
              transforms2,
              this.renderedFeatures_,
              layer.getStyleFunction(),
              extent,
              resolution,
              rotation
            );
          }
          resolve(
            hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_)
          );
        });
      }
      /**
       * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
       * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
       * @return {T|undefined} Callback result.
       * @template T
       */
      forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
        if (!this.replayGroup_) {
          return void 0;
        }
        const resolution = frameState.viewState.resolution;
        const rotation = frameState.viewState.rotation;
        const layer = this.getLayer();
        const features = {};
        const featureCallback = function(feature, geometry, distanceSq) {
          const key = getUid(feature);
          const match = features[key];
          if (!match) {
            if (distanceSq === 0) {
              features[key] = true;
              return callback(feature, layer, geometry);
            }
            matches.push(
              features[key] = {
                feature,
                layer,
                geometry,
                distanceSq,
                callback
              }
            );
          } else if (match !== true && distanceSq < match.distanceSq) {
            if (distanceSq === 0) {
              features[key] = true;
              matches.splice(matches.lastIndexOf(match), 1);
              return callback(feature, layer, geometry);
            }
            match.geometry = geometry;
            match.distanceSq = distanceSq;
          }
          return void 0;
        };
        let result;
        const executorGroups = [this.replayGroup_];
        if (this.declutterExecutorGroup) {
          executorGroups.push(this.declutterExecutorGroup);
        }
        executorGroups.some((executorGroup) => {
          return result = executorGroup.forEachFeatureAtCoordinate(
            coordinate,
            resolution,
            rotation,
            hitTolerance,
            featureCallback,
            executorGroup === this.declutterExecutorGroup && frameState.declutterTree ? frameState.declutterTree.all().map((item) => item.value) : null
          );
        });
        return result;
      }
      /**
       * Perform action necessary to get the layer rendered after new fonts have loaded
       */
      handleFontsChanged() {
        const layer = this.getLayer();
        if (layer.getVisible() && this.replayGroup_) {
          layer.changed();
        }
      }
      /**
       * Handle changes in image style state.
       * @param {import("../../events/Event.js").default} event Image style change event.
       * @private
       */
      handleStyleImageChange_(event) {
        this.renderIfReadyAndVisible();
      }
      /**
       * Determine whether render should be called.
       * @param {import("../../Map.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       */
      prepareFrame(frameState) {
        const vectorLayer = this.getLayer();
        const vectorSource = vectorLayer.getSource();
        if (!vectorSource) {
          return false;
        }
        const animating = frameState.viewHints[ViewHint_default.ANIMATING];
        const interacting = frameState.viewHints[ViewHint_default.INTERACTING];
        const updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
        const updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
        if (this.ready && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
          this.animatingOrInteracting_ = true;
          return true;
        }
        this.animatingOrInteracting_ = false;
        const frameStateExtent = frameState.extent;
        const viewState = frameState.viewState;
        const projection = viewState.projection;
        const resolution = viewState.resolution;
        const pixelRatio = frameState.pixelRatio;
        const vectorLayerRevision = vectorLayer.getRevision();
        const vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
        let vectorLayerRenderOrder = vectorLayer.getRenderOrder();
        if (vectorLayerRenderOrder === void 0) {
          vectorLayerRenderOrder = defaultOrder;
        }
        const center = viewState.center.slice();
        const extent = buffer(
          frameStateExtent,
          vectorLayerRenderBuffer * resolution
        );
        const renderedExtent = extent.slice();
        const loadExtents = [extent.slice()];
        const projectionExtent = projection.getExtent();
        if (vectorSource.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, frameState.extent)) {
          const worldWidth = getWidth(projectionExtent);
          const gutter = Math.max(getWidth(extent) / 2, worldWidth);
          extent[0] = projectionExtent[0] - gutter;
          extent[2] = projectionExtent[2] + gutter;
          wrapX2(center, projection);
          const loadExtent = wrapX(loadExtents[0], projection);
          if (loadExtent[0] < projectionExtent[0] && loadExtent[2] < projectionExtent[2]) {
            loadExtents.push([
              loadExtent[0] + worldWidth,
              loadExtent[1],
              loadExtent[2] + worldWidth,
              loadExtent[3]
            ]);
          } else if (loadExtent[0] > projectionExtent[0] && loadExtent[2] > projectionExtent[2]) {
            loadExtents.push([
              loadExtent[0] - worldWidth,
              loadExtent[1],
              loadExtent[2] - worldWidth,
              loadExtent[3]
            ]);
          }
        }
        if (this.ready && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && containsExtent(this.wrappedRenderedExtent_, extent)) {
          if (!equals(this.renderedExtent_, renderedExtent)) {
            this.hitDetectionImageData_ = null;
            this.renderedExtent_ = renderedExtent;
          }
          this.renderedCenter_ = center;
          this.replayGroupChanged = false;
          return true;
        }
        this.replayGroup_ = null;
        const replayGroup = new BuilderGroup_default(
          getTolerance(resolution, pixelRatio),
          extent,
          resolution,
          pixelRatio
        );
        let declutterBuilderGroup;
        if (this.getLayer().getDeclutter()) {
          declutterBuilderGroup = new BuilderGroup_default(
            getTolerance(resolution, pixelRatio),
            extent,
            resolution,
            pixelRatio
          );
        }
        const userProjection2 = getUserProjection();
        let userTransform;
        if (userProjection2) {
          for (let i = 0, ii = loadExtents.length; i < ii; ++i) {
            const extent2 = loadExtents[i];
            const userExtent2 = toUserExtent(extent2, projection);
            vectorSource.loadFeatures(
              userExtent2,
              toUserResolution(resolution, projection),
              userProjection2
            );
          }
          userTransform = getTransformFromProjections(userProjection2, projection);
        } else {
          for (let i = 0, ii = loadExtents.length; i < ii; ++i) {
            vectorSource.loadFeatures(loadExtents[i], resolution, projection);
          }
        }
        const squaredTolerance = getSquaredTolerance(resolution, pixelRatio);
        let ready = true;
        const render2 = (
          /**
           * @param {import("../../Feature.js").default} feature Feature.
           */
          (feature) => {
            let styles;
            const styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
            if (styleFunction) {
              styles = styleFunction(feature, resolution);
            }
            if (styles) {
              const dirty = this.renderFeature(
                feature,
                squaredTolerance,
                styles,
                replayGroup,
                userTransform,
                declutterBuilderGroup
              );
              ready = ready && !dirty;
            }
          }
        );
        const userExtent = toUserExtent(extent, projection);
        const features = vectorSource.getFeaturesInExtent(userExtent);
        if (vectorLayerRenderOrder) {
          features.sort(vectorLayerRenderOrder);
        }
        for (let i = 0, ii = features.length; i < ii; ++i) {
          render2(features[i]);
        }
        this.renderedFeatures_ = features;
        this.ready = ready;
        const replayGroupInstructions = replayGroup.finish();
        const executorGroup = new ExecutorGroup_default(
          extent,
          resolution,
          pixelRatio,
          vectorSource.getOverlaps(),
          replayGroupInstructions,
          vectorLayer.getRenderBuffer()
        );
        if (declutterBuilderGroup) {
          this.declutterExecutorGroup = new ExecutorGroup_default(
            extent,
            resolution,
            pixelRatio,
            vectorSource.getOverlaps(),
            declutterBuilderGroup.finish(),
            vectorLayer.getRenderBuffer()
          );
        }
        this.renderedResolution_ = resolution;
        this.renderedRevision_ = vectorLayerRevision;
        this.renderedRenderOrder_ = vectorLayerRenderOrder;
        this.renderedExtent_ = renderedExtent;
        this.wrappedRenderedExtent_ = extent;
        this.renderedCenter_ = center;
        this.renderedProjection_ = projection;
        this.replayGroup_ = executorGroup;
        this.hitDetectionImageData_ = null;
        this.replayGroupChanged = true;
        return true;
      }
      /**
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {number} squaredTolerance Squared render tolerance.
       * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
       * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
       * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
       * @param {import("../../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
       * @return {boolean} `true` if an image is loading.
       */
      renderFeature(feature, squaredTolerance, styles, builderGroup, transform2, declutterBuilderGroup) {
        if (!styles) {
          return false;
        }
        let loading = false;
        if (Array.isArray(styles)) {
          for (let i = 0, ii = styles.length; i < ii; ++i) {
            loading = renderFeature(
              builderGroup,
              feature,
              styles[i],
              squaredTolerance,
              this.boundHandleStyleImageChange_,
              transform2,
              declutterBuilderGroup
            ) || loading;
          }
        } else {
          loading = renderFeature(
            builderGroup,
            feature,
            styles,
            squaredTolerance,
            this.boundHandleStyleImageChange_,
            transform2,
            declutterBuilderGroup
          );
        }
        return loading;
      }
    };
    VectorLayer_default = CanvasVectorLayerRenderer;
  }
});

// node_modules/ol/layer/Vector.js
var Vector_exports = {};
__export(Vector_exports, {
  default: () => Vector_default
});
var VectorLayer, Vector_default;
var init_Vector = __esm({
  "node_modules/ol/layer/Vector.js"() {
    init_BaseVector();
    init_VectorLayer();
    VectorLayer = class extends BaseVector_default {
      /**
       * @param {import("./BaseVector.js").Options<VectorSourceType>} [options] Options.
       */
      constructor(options) {
        super(options);
      }
      createRenderer() {
        return new VectorLayer_default(this);
      }
    };
    Vector_default = VectorLayer;
  }
});

// node_modules/ol/structs/RBush.js
var RBush2, RBush_default;
var init_RBush = __esm({
  "node_modules/ol/structs/RBush.js"() {
    init_rbush();
    init_extent();
    init_util();
    init_obj();
    RBush2 = class {
      /**
       * @param {number} [maxEntries] Max entries.
       */
      constructor(maxEntries) {
        this.rbush_ = new RBush(maxEntries);
        this.items_ = {};
      }
      /**
       * Insert a value into the RBush.
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {T} value Value.
       */
      insert(extent, value) {
        const item = {
          minX: extent[0],
          minY: extent[1],
          maxX: extent[2],
          maxY: extent[3],
          value
        };
        this.rbush_.insert(item);
        this.items_[getUid(value)] = item;
      }
      /**
       * Bulk-insert values into the RBush.
       * @param {Array<import("../extent.js").Extent>} extents Extents.
       * @param {Array<T>} values Values.
       */
      load(extents, values) {
        const items = new Array(values.length);
        for (let i = 0, l = values.length; i < l; i++) {
          const extent = extents[i];
          const value = values[i];
          const item = {
            minX: extent[0],
            minY: extent[1],
            maxX: extent[2],
            maxY: extent[3],
            value
          };
          items[i] = item;
          this.items_[getUid(value)] = item;
        }
        this.rbush_.load(items);
      }
      /**
       * Remove a value from the RBush.
       * @param {T} value Value.
       * @return {boolean} Removed.
       */
      remove(value) {
        const uid = getUid(value);
        const item = this.items_[uid];
        delete this.items_[uid];
        return this.rbush_.remove(item) !== null;
      }
      /**
       * Update the extent of a value in the RBush.
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {T} value Value.
       */
      update(extent, value) {
        const item = this.items_[getUid(value)];
        const bbox2 = [item.minX, item.minY, item.maxX, item.maxY];
        if (!equals2(bbox2, extent)) {
          this.remove(value);
          this.insert(extent, value);
        }
      }
      /**
       * Return all values in the RBush.
       * @return {Array<T>} All.
       */
      getAll() {
        const items = this.rbush_.all();
        return items.map(function(item) {
          return item.value;
        });
      }
      /**
       * Return all values in the given extent.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {Array<T>} All in extent.
       */
      getInExtent(extent) {
        const bbox2 = {
          minX: extent[0],
          minY: extent[1],
          maxX: extent[2],
          maxY: extent[3]
        };
        const items = this.rbush_.search(bbox2);
        return items.map(function(item) {
          return item.value;
        });
      }
      /**
       * Calls a callback function with each value in the tree.
       * If the callback returns a truthy value, this value is returned without
       * checking the rest of the tree.
       * @param {function(T): *} callback Callback.
       * @return {*} Callback return value.
       */
      forEach(callback) {
        return this.forEach_(this.getAll(), callback);
      }
      /**
       * Calls a callback function with each value in the provided extent.
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {function(T): *} callback Callback.
       * @return {*} Callback return value.
       */
      forEachInExtent(extent, callback) {
        return this.forEach_(this.getInExtent(extent), callback);
      }
      /**
       * @param {Array<T>} values Values.
       * @param {function(T): *} callback Callback.
       * @private
       * @return {*} Callback return value.
       */
      forEach_(values, callback) {
        let result;
        for (let i = 0, l = values.length; i < l; i++) {
          result = callback(values[i]);
          if (result) {
            return result;
          }
        }
        return result;
      }
      /**
       * @return {boolean} Is empty.
       */
      isEmpty() {
        return isEmpty(this.items_);
      }
      /**
       * Remove all values from the RBush.
       */
      clear() {
        this.rbush_.clear();
        this.items_ = {};
      }
      /**
       * @param {import("../extent.js").Extent} [extent] Extent.
       * @return {import("../extent.js").Extent} Extent.
       */
      getExtent(extent) {
        const data = this.rbush_.toJSON();
        return createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, extent);
      }
      /**
       * @param {RBush} rbush R-Tree.
       */
      concat(rbush) {
        this.rbush_.load(rbush.rbush_.all());
        for (const i in rbush.items_) {
          this.items_[i] = rbush.items_[i];
        }
      }
    };
    RBush_default = RBush2;
  }
});

// node_modules/ol/geom/Circle.js
var Circle, Circle_default2;
var init_Circle2 = __esm({
  "node_modules/ol/geom/Circle.js"() {
    init_SimpleGeometry();
    init_extent();
    init_deflate();
    init_transform2();
    Circle = class _Circle extends SimpleGeometry_default {
      /**
       * @param {!import("../coordinate.js").Coordinate} center Center.
       *     For internal use, flat coordinates in combination with `layout` and no
       *     `radius` are also accepted.
       * @param {number} [radius] Radius in units of the projection.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(center, radius, layout) {
        super();
        if (layout !== void 0 && radius === void 0) {
          this.setFlatCoordinates(layout, center);
        } else {
          radius = radius ? radius : 0;
          this.setCenterAndRadius(center, radius, layout);
        }
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!Circle} Clone.
       * @api
       */
      clone() {
        const circle = new _Circle(
          this.flatCoordinates.slice(),
          void 0,
          this.layout
        );
        circle.applyProperties(this);
        return circle;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        const flatCoordinates = this.flatCoordinates;
        const dx = x - flatCoordinates[0];
        const dy = y - flatCoordinates[1];
        const squaredDistance3 = dx * dx + dy * dy;
        if (squaredDistance3 < minSquaredDistance) {
          if (squaredDistance3 === 0) {
            for (let i = 0; i < this.stride; ++i) {
              closestPoint[i] = flatCoordinates[i];
            }
          } else {
            const delta = this.getRadius() / Math.sqrt(squaredDistance3);
            closestPoint[0] = flatCoordinates[0] + delta * dx;
            closestPoint[1] = flatCoordinates[1] + delta * dy;
            for (let i = 2; i < this.stride; ++i) {
              closestPoint[i] = flatCoordinates[i];
            }
          }
          closestPoint.length = this.stride;
          return squaredDistance3;
        }
        return minSquaredDistance;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */
      containsXY(x, y) {
        const flatCoordinates = this.flatCoordinates;
        const dx = x - flatCoordinates[0];
        const dy = y - flatCoordinates[1];
        return dx * dx + dy * dy <= this.getRadiusSquared_();
      }
      /**
       * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
       * @return {import("../coordinate.js").Coordinate} Center.
       * @api
       */
      getCenter() {
        return this.flatCoordinates.slice(0, this.stride);
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      computeExtent(extent) {
        const flatCoordinates = this.flatCoordinates;
        const radius = flatCoordinates[this.stride] - flatCoordinates[0];
        return createOrUpdate(
          flatCoordinates[0] - radius,
          flatCoordinates[1] - radius,
          flatCoordinates[0] + radius,
          flatCoordinates[1] + radius,
          extent
        );
      }
      /**
       * Return the radius of the circle.
       * @return {number} Radius.
       * @api
       */
      getRadius() {
        return Math.sqrt(this.getRadiusSquared_());
      }
      /**
       * @private
       * @return {number} Radius squared.
       */
      getRadiusSquared_() {
        const dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];
        const dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
        return dx * dx + dy * dy;
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */
      getType() {
        return "Circle";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      intersectsExtent(extent) {
        const circleExtent = this.getExtent();
        if (intersects(extent, circleExtent)) {
          const center = this.getCenter();
          if (extent[0] <= center[0] && extent[2] >= center[0]) {
            return true;
          }
          if (extent[1] <= center[1] && extent[3] >= center[1]) {
            return true;
          }
          return forEachCorner(extent, this.intersectsCoordinate.bind(this));
        }
        return false;
      }
      /**
       * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.
       * @param {import("../coordinate.js").Coordinate} center Center.
       * @api
       */
      setCenter(center) {
        const stride = this.stride;
        const radius = this.flatCoordinates[stride] - this.flatCoordinates[0];
        const flatCoordinates = center.slice();
        flatCoordinates[stride] = flatCoordinates[0] + radius;
        for (let i = 1; i < stride; ++i) {
          flatCoordinates[stride + i] = center[i];
        }
        this.setFlatCoordinates(this.layout, flatCoordinates);
        this.changed();
      }
      /**
       * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as
       * number) of the circle.
       * @param {!import("../coordinate.js").Coordinate} center Center.
       * @param {number} radius Radius.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */
      setCenterAndRadius(center, radius, layout) {
        this.setLayout(layout, center, 0);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        const flatCoordinates = this.flatCoordinates;
        let offset2 = deflateCoordinate(flatCoordinates, 0, center, this.stride);
        flatCoordinates[offset2++] = flatCoordinates[0] + radius;
        for (let i = 1, ii = this.stride; i < ii; ++i) {
          flatCoordinates[offset2++] = flatCoordinates[i];
        }
        flatCoordinates.length = offset2;
        this.changed();
      }
      getCoordinates() {
        return null;
      }
      setCoordinates(coordinates2, layout) {
      }
      /**
       * Set the radius of the circle. The radius is in the units of the projection.
       * @param {number} radius Radius.
       * @api
       */
      setRadius(radius) {
        this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;
        this.changed();
      }
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @param {number} angle Rotation angle in counter-clockwise radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       */
      rotate(angle, anchor) {
        const center = this.getCenter();
        const stride = this.getStride();
        this.setCenter(
          rotate3(center, 0, center.length, stride, angle, anchor, center)
        );
        this.changed();
      }
    };
    Circle.prototype.transform;
    Circle_default2 = Circle;
  }
});

// node_modules/ol/geom/GeometryCollection.js
var init_GeometryCollection = __esm({
  "node_modules/ol/geom/GeometryCollection.js"() {
  }
});

// node_modules/ol/geom/MultiLineString.js
var MultiLineString, MultiLineString_default;
var init_MultiLineString = __esm({
  "node_modules/ol/geom/MultiLineString.js"() {
    init_LineString();
    init_SimpleGeometry();
    init_closest();
    init_extent();
    init_deflate();
    init_simplify();
    init_array();
    init_inflate();
    init_interpolate();
    init_intersectsextent();
    MultiLineString = class _MultiLineString extends SimpleGeometry_default {
      /**
       * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
       *     Coordinates or LineString geometries. (For internal use, flat coordinates in
       *     combination with `layout` and `ends` are also accepted.)
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @param {Array<number>} [ends] Flat coordinate ends for internal use.
       */
      constructor(coordinates2, layout, ends) {
        super();
        this.ends_ = [];
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        if (Array.isArray(coordinates2[0])) {
          this.setCoordinates(
            /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
            coordinates2,
            layout
          );
        } else if (layout !== void 0 && ends) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
          this.ends_ = ends;
        } else {
          const lineStrings = (
            /** @type {Array<LineString>} */
            coordinates2
          );
          const flatCoordinates = [];
          const ends2 = [];
          for (let i = 0, ii = lineStrings.length; i < ii; ++i) {
            const lineString = lineStrings[i];
            extend(flatCoordinates, lineString.getFlatCoordinates());
            ends2.push(flatCoordinates.length);
          }
          const layout2 = lineStrings.length === 0 ? this.getLayout() : lineStrings[0].getLayout();
          this.setFlatCoordinates(layout2, flatCoordinates);
          this.ends_ = ends2;
        }
      }
      /**
       * Append the passed linestring to the multilinestring.
       * @param {LineString} lineString LineString.
       * @api
       */
      appendLineString(lineString) {
        extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());
        this.ends_.push(this.flatCoordinates.length);
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiLineString} Clone.
       * @api
       */
      clone() {
        const multiLineString = new _MultiLineString(
          this.flatCoordinates.slice(),
          this.layout,
          this.ends_.slice()
        );
        multiLineString.applyProperties(this);
        return multiLineString;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            arrayMaxSquaredDelta(
              this.flatCoordinates,
              0,
              this.ends_,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestArrayPoint(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          this.maxDelta_,
          false,
          x,
          y,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * Returns the coordinate at `m` using linear interpolation, or `null` if no
       * such coordinate exists.
       *
       * `extrapolate` controls extrapolation beyond the range of Ms in the
       * MultiLineString. If `extrapolate` is `true` then Ms less than the first
       * M will return the first coordinate and Ms greater than the last M will
       * return the last coordinate.
       *
       * `interpolate` controls interpolation between consecutive LineStrings
       * within the MultiLineString. If `interpolate` is `true` the coordinates
       * will be linearly interpolated between the last coordinate of one LineString
       * and the first coordinate of the next LineString.  If `interpolate` is
       * `false` then the function will return `null` for Ms falling between
       * LineStrings.
       *
       * @param {number} m M.
       * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
       * @param {boolean} [interpolate] Interpolate. Default is `false`.
       * @return {import("../coordinate.js").Coordinate|null} Coordinate.
       * @api
       */
      getCoordinateAtM(m, extrapolate, interpolate) {
        if (this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0) {
          return null;
        }
        extrapolate = extrapolate !== void 0 ? extrapolate : false;
        interpolate = interpolate !== void 0 ? interpolate : false;
        return lineStringsCoordinateAtM(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          m,
          extrapolate,
          interpolate
        );
      }
      /**
       * Return the coordinates of the multilinestring.
       * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
       * @api
       */
      getCoordinates() {
        return inflateCoordinatesArray(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride
        );
      }
      /**
       * @return {Array<number>} Ends.
       */
      getEnds() {
        return this.ends_;
      }
      /**
       * Return the linestring at the specified index.
       * @param {number} index Index.
       * @return {LineString} LineString.
       * @api
       */
      getLineString(index) {
        if (index < 0 || this.ends_.length <= index) {
          return null;
        }
        return new LineString_default(
          this.flatCoordinates.slice(
            index === 0 ? 0 : this.ends_[index - 1],
            this.ends_[index]
          ),
          this.layout
        );
      }
      /**
       * Return the linestrings of this multilinestring.
       * @return {Array<LineString>} LineStrings.
       * @api
       */
      getLineStrings() {
        const flatCoordinates = this.flatCoordinates;
        const ends = this.ends_;
        const layout = this.layout;
        const lineStrings = [];
        let offset2 = 0;
        for (let i = 0, ii = ends.length; i < ii; ++i) {
          const end = ends[i];
          const lineString = new LineString_default(
            flatCoordinates.slice(offset2, end),
            layout
          );
          lineStrings.push(lineString);
          offset2 = end;
        }
        return lineStrings;
      }
      /**
       * @return {Array<number>} Flat midpoints.
       */
      getFlatMidpoints() {
        const midpoints = [];
        const flatCoordinates = this.flatCoordinates;
        let offset2 = 0;
        const ends = this.ends_;
        const stride = this.stride;
        for (let i = 0, ii = ends.length; i < ii; ++i) {
          const end = ends[i];
          const midpoint = interpolatePoint(
            flatCoordinates,
            offset2,
            end,
            stride,
            0.5
          );
          extend(midpoints, midpoint);
          offset2 = end;
        }
        return midpoints;
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {MultiLineString} Simplified MultiLineString.
       * @protected
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        const simplifiedEnds = [];
        simplifiedFlatCoordinates.length = douglasPeuckerArray(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          squaredTolerance,
          simplifiedFlatCoordinates,
          0,
          simplifiedEnds
        );
        return new _MultiLineString(simplifiedFlatCoordinates, "XY", simplifiedEnds);
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */
      getType() {
        return "MultiLineString";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      intersectsExtent(extent) {
        return intersectsLineStringArray(
          this.flatCoordinates,
          0,
          this.ends_,
          this.stride,
          extent
        );
      }
      /**
       * Set the coordinates of the multilinestring.
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 2);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        const ends = deflateCoordinatesArray(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride,
          this.ends_
        );
        this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
        this.changed();
      }
    };
    MultiLineString_default = MultiLineString;
  }
});

// node_modules/ol/geom/MultiPoint.js
var MultiPoint, MultiPoint_default;
var init_MultiPoint = __esm({
  "node_modules/ol/geom/MultiPoint.js"() {
    init_Point();
    init_SimpleGeometry();
    init_extent();
    init_deflate();
    init_array();
    init_inflate();
    init_math();
    MultiPoint = class _MultiPoint extends SimpleGeometry_default {
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `layout` are also accepted.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       */
      constructor(coordinates2, layout) {
        super();
        if (layout && !Array.isArray(coordinates2[0])) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
        } else {
          this.setCoordinates(
            /** @type {Array<import("../coordinate.js").Coordinate>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Append the passed point to this multipoint.
       * @param {Point} point Point.
       * @api
       */
      appendPoint(point) {
        extend(this.flatCoordinates, point.getFlatCoordinates());
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiPoint} Clone.
       * @api
       */
      clone() {
        const multiPoint = new _MultiPoint(
          this.flatCoordinates.slice(),
          this.layout
        );
        multiPoint.applyProperties(this);
        return multiPoint;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        const flatCoordinates = this.flatCoordinates;
        const stride = this.stride;
        for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
          const squaredDistance3 = squaredDistance(
            x,
            y,
            flatCoordinates[i],
            flatCoordinates[i + 1]
          );
          if (squaredDistance3 < minSquaredDistance) {
            minSquaredDistance = squaredDistance3;
            for (let j = 0; j < stride; ++j) {
              closestPoint[j] = flatCoordinates[i + j];
            }
            closestPoint.length = stride;
          }
        }
        return minSquaredDistance;
      }
      /**
       * Return the coordinates of the multipoint.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       */
      getCoordinates() {
        return inflateCoordinates(
          this.flatCoordinates,
          0,
          this.flatCoordinates.length,
          this.stride
        );
      }
      /**
       * Return the point at the specified index.
       * @param {number} index Index.
       * @return {Point} Point.
       * @api
       */
      getPoint(index) {
        const n = this.flatCoordinates.length / this.stride;
        if (index < 0 || n <= index) {
          return null;
        }
        return new Point_default(
          this.flatCoordinates.slice(
            index * this.stride,
            (index + 1) * this.stride
          ),
          this.layout
        );
      }
      /**
       * Return the points of this multipoint.
       * @return {Array<Point>} Points.
       * @api
       */
      getPoints() {
        const flatCoordinates = this.flatCoordinates;
        const layout = this.layout;
        const stride = this.stride;
        const points = [];
        for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
          const point = new Point_default(flatCoordinates.slice(i, i + stride), layout);
          points.push(point);
        }
        return points;
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */
      getType() {
        return "MultiPoint";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      intersectsExtent(extent) {
        const flatCoordinates = this.flatCoordinates;
        const stride = this.stride;
        for (let i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
          const x = flatCoordinates[i];
          const y = flatCoordinates[i + 1];
          if (containsXY(extent, x, y)) {
            return true;
          }
        }
        return false;
      }
      /**
       * Set the coordinates of the multipoint.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 1);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        this.flatCoordinates.length = deflateCoordinates(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride
        );
        this.changed();
      }
    };
    MultiPoint_default = MultiPoint;
  }
});

// node_modules/ol/geom/flat/center.js
function linearRingss2(flatCoordinates, offset2, endss, stride) {
  const flatCenters = [];
  let extent = createEmpty();
  for (let i = 0, ii = endss.length; i < ii; ++i) {
    const ends = endss[i];
    extent = createOrUpdateFromFlatCoordinates(
      flatCoordinates,
      offset2,
      ends[0],
      stride
    );
    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
    offset2 = ends[ends.length - 1];
  }
  return flatCenters;
}
var init_center = __esm({
  "node_modules/ol/geom/flat/center.js"() {
    init_extent();
  }
});

// node_modules/ol/geom/MultiPolygon.js
var MultiPolygon, MultiPolygon_default;
var init_MultiPolygon = __esm({
  "node_modules/ol/geom/MultiPolygon.js"() {
    init_MultiPoint();
    init_Polygon();
    init_SimpleGeometry();
    init_closest();
    init_extent();
    init_deflate();
    init_array();
    init_interiorpoint();
    init_inflate();
    init_intersectsextent();
    init_orient();
    init_area();
    init_center();
    init_contains();
    init_simplify();
    MultiPolygon = class _MultiPolygon extends SimpleGeometry_default {
      /**
       * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
       */
      constructor(coordinates2, layout, endss) {
        super();
        this.endss_ = [];
        this.flatInteriorPointsRevision_ = -1;
        this.flatInteriorPoints_ = null;
        this.maxDelta_ = -1;
        this.maxDeltaRevision_ = -1;
        this.orientedRevision_ = -1;
        this.orientedFlatCoordinates_ = null;
        if (!endss && !Array.isArray(coordinates2[0])) {
          const polygons = (
            /** @type {Array<Polygon>} */
            coordinates2
          );
          const flatCoordinates = [];
          const thisEndss = [];
          for (let i = 0, ii = polygons.length; i < ii; ++i) {
            const polygon = polygons[i];
            const offset2 = flatCoordinates.length;
            const ends = polygon.getEnds();
            for (let j = 0, jj = ends.length; j < jj; ++j) {
              ends[j] += offset2;
            }
            extend(flatCoordinates, polygon.getFlatCoordinates());
            thisEndss.push(ends);
          }
          layout = polygons.length === 0 ? this.getLayout() : polygons[0].getLayout();
          coordinates2 = flatCoordinates;
          endss = thisEndss;
        }
        if (layout !== void 0 && endss) {
          this.setFlatCoordinates(
            layout,
            /** @type {Array<number>} */
            coordinates2
          );
          this.endss_ = endss;
        } else {
          this.setCoordinates(
            /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
            coordinates2,
            layout
          );
        }
      }
      /**
       * Append the passed polygon to this multipolygon.
       * @param {Polygon} polygon Polygon.
       * @api
       */
      appendPolygon(polygon) {
        let ends;
        if (!this.flatCoordinates) {
          this.flatCoordinates = polygon.getFlatCoordinates().slice();
          ends = polygon.getEnds().slice();
          this.endss_.push();
        } else {
          const offset2 = this.flatCoordinates.length;
          extend(this.flatCoordinates, polygon.getFlatCoordinates());
          ends = polygon.getEnds().slice();
          for (let i = 0, ii = ends.length; i < ii; ++i) {
            ends[i] += offset2;
          }
        }
        this.endss_.push(ends);
        this.changed();
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiPolygon} Clone.
       * @api
       */
      clone() {
        const len = this.endss_.length;
        const newEndss = new Array(len);
        for (let i = 0; i < len; ++i) {
          newEndss[i] = this.endss_[i].slice();
        }
        const multiPolygon = new _MultiPolygon(
          this.flatCoordinates.slice(),
          this.layout,
          newEndss
        );
        multiPolygon.applyProperties(this);
        return multiPolygon;
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      closestPointXY(x, y, closestPoint, minSquaredDistance) {
        if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
          return minSquaredDistance;
        }
        if (this.maxDeltaRevision_ != this.getRevision()) {
          this.maxDelta_ = Math.sqrt(
            multiArrayMaxSquaredDelta(
              this.flatCoordinates,
              0,
              this.endss_,
              this.stride,
              0
            )
          );
          this.maxDeltaRevision_ = this.getRevision();
        }
        return assignClosestMultiArrayPoint(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride,
          this.maxDelta_,
          true,
          x,
          y,
          closestPoint,
          minSquaredDistance
        );
      }
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */
      containsXY(x, y) {
        return linearRingssContainsXY(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride,
          x,
          y
        );
      }
      /**
       * Return the area of the multipolygon on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      getArea() {
        return linearRingss(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride
        );
      }
      /**
       * Get the coordinate array for this geometry.  This array has the structure
       * of a GeoJSON coordinate array for multi-polygons.
       *
       * @param {boolean} [right] Orient coordinates according to the right-hand
       *     rule (counter-clockwise for exterior and clockwise for interior rings).
       *     If `false`, coordinates will be oriented according to the left-hand rule
       *     (clockwise for exterior and counter-clockwise for interior rings).
       *     By default, coordinate orientation will depend on how the geometry was
       *     constructed.
       * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
       * @api
       */
      getCoordinates(right) {
        let flatCoordinates;
        if (right !== void 0) {
          flatCoordinates = this.getOrientedFlatCoordinates().slice();
          orientLinearRingsArray(
            flatCoordinates,
            0,
            this.endss_,
            this.stride,
            right
          );
        } else {
          flatCoordinates = this.flatCoordinates;
        }
        return inflateMultiCoordinatesArray(
          flatCoordinates,
          0,
          this.endss_,
          this.stride
        );
      }
      /**
       * @return {Array<Array<number>>} Endss.
       */
      getEndss() {
        return this.endss_;
      }
      /**
       * @return {Array<number>} Flat interior points.
       */
      getFlatInteriorPoints() {
        if (this.flatInteriorPointsRevision_ != this.getRevision()) {
          const flatCenters = linearRingss2(
            this.flatCoordinates,
            0,
            this.endss_,
            this.stride
          );
          this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(
            this.getOrientedFlatCoordinates(),
            0,
            this.endss_,
            this.stride,
            flatCenters
          );
          this.flatInteriorPointsRevision_ = this.getRevision();
        }
        return (
          /** @type {Array<number>} */
          this.flatInteriorPoints_
        );
      }
      /**
       * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
       * @return {MultiPoint} Interior points as XYM coordinates, where M is
       * the length of the horizontal intersection that the point belongs to.
       * @api
       */
      getInteriorPoints() {
        return new MultiPoint_default(this.getFlatInteriorPoints().slice(), "XYM");
      }
      /**
       * @return {Array<number>} Oriented flat coordinates.
       */
      getOrientedFlatCoordinates() {
        if (this.orientedRevision_ != this.getRevision()) {
          const flatCoordinates = this.flatCoordinates;
          if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {
            this.orientedFlatCoordinates_ = flatCoordinates;
          } else {
            this.orientedFlatCoordinates_ = flatCoordinates.slice();
            this.orientedFlatCoordinates_.length = orientLinearRingsArray(
              this.orientedFlatCoordinates_,
              0,
              this.endss_,
              this.stride
            );
          }
          this.orientedRevision_ = this.getRevision();
        }
        return (
          /** @type {Array<number>} */
          this.orientedFlatCoordinates_
        );
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {MultiPolygon} Simplified MultiPolygon.
       * @protected
       */
      getSimplifiedGeometryInternal(squaredTolerance) {
        const simplifiedFlatCoordinates = [];
        const simplifiedEndss = [];
        simplifiedFlatCoordinates.length = quantizeMultiArray(
          this.flatCoordinates,
          0,
          this.endss_,
          this.stride,
          Math.sqrt(squaredTolerance),
          simplifiedFlatCoordinates,
          0,
          simplifiedEndss
        );
        return new _MultiPolygon(simplifiedFlatCoordinates, "XY", simplifiedEndss);
      }
      /**
       * Return the polygon at the specified index.
       * @param {number} index Index.
       * @return {Polygon} Polygon.
       * @api
       */
      getPolygon(index) {
        if (index < 0 || this.endss_.length <= index) {
          return null;
        }
        let offset2;
        if (index === 0) {
          offset2 = 0;
        } else {
          const prevEnds = this.endss_[index - 1];
          offset2 = prevEnds[prevEnds.length - 1];
        }
        const ends = this.endss_[index].slice();
        const end = ends[ends.length - 1];
        if (offset2 !== 0) {
          for (let i = 0, ii = ends.length; i < ii; ++i) {
            ends[i] -= offset2;
          }
        }
        return new Polygon_default(
          this.flatCoordinates.slice(offset2, end),
          this.layout,
          ends
        );
      }
      /**
       * Return the polygons of this multipolygon.
       * @return {Array<Polygon>} Polygons.
       * @api
       */
      getPolygons() {
        const layout = this.layout;
        const flatCoordinates = this.flatCoordinates;
        const endss = this.endss_;
        const polygons = [];
        let offset2 = 0;
        for (let i = 0, ii = endss.length; i < ii; ++i) {
          const ends = endss[i].slice();
          const end = ends[ends.length - 1];
          if (offset2 !== 0) {
            for (let j = 0, jj = ends.length; j < jj; ++j) {
              ends[j] -= offset2;
            }
          }
          const polygon = new Polygon_default(
            flatCoordinates.slice(offset2, end),
            layout,
            ends
          );
          polygons.push(polygon);
          offset2 = end;
        }
        return polygons;
      }
      /**
       * Get the type of this geometry.
       * @return {import("./Geometry.js").Type} Geometry type.
       * @api
       */
      getType() {
        return "MultiPolygon";
      }
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      intersectsExtent(extent) {
        return intersectsLinearRingMultiArray(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride,
          extent
        );
      }
      /**
       * Set the coordinates of the multipolygon.
       * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
       * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
       * @api
       */
      setCoordinates(coordinates2, layout) {
        this.setLayout(layout, coordinates2, 3);
        if (!this.flatCoordinates) {
          this.flatCoordinates = [];
        }
        const endss = deflateMultiCoordinatesArray(
          this.flatCoordinates,
          0,
          coordinates2,
          this.stride,
          this.endss_
        );
        if (endss.length === 0) {
          this.flatCoordinates.length = 0;
        } else {
          const lastEnds = endss[endss.length - 1];
          this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
        }
        this.changed();
      }
    };
    MultiPolygon_default = MultiPolygon;
  }
});

// node_modules/ol/geom.js
var init_geom = __esm({
  "node_modules/ol/geom.js"() {
    init_Circle2();
    init_Geometry();
    init_GeometryCollection();
    init_LinearRing();
    init_LineString();
    init_MultiLineString();
    init_MultiPoint();
    init_MultiPolygon();
    init_Point();
    init_Polygon();
    init_SimpleGeometry();
  }
});

// node_modules/ol/render/Feature.js
function toGeometry(renderFeature2) {
  const geometryType = renderFeature2.getType();
  switch (geometryType) {
    case "Point":
      return new Point_default(renderFeature2.getFlatCoordinates());
    case "MultiPoint":
      return new MultiPoint_default(renderFeature2.getFlatCoordinates(), "XY");
    case "LineString":
      return new LineString_default(renderFeature2.getFlatCoordinates(), "XY");
    case "MultiLineString":
      return new MultiLineString_default(
        renderFeature2.getFlatCoordinates(),
        "XY",
        /** @type {Array<number>} */
        renderFeature2.getEnds()
      );
    case "Polygon":
      const flatCoordinates = renderFeature2.getFlatCoordinates();
      const ends = (
        /** @type {Array<number>} */
        renderFeature2.getEnds()
      );
      const endss = inflateEnds(flatCoordinates, ends);
      return endss.length > 1 ? new MultiPolygon_default(flatCoordinates, "XY", endss) : new Polygon_default(flatCoordinates, "XY", ends);
    default:
      throw new Error("Invalid geometry type:" + geometryType);
  }
}
function toFeature(renderFeature2, geometryName) {
  const id = renderFeature2.getId();
  const geometry = toGeometry(renderFeature2);
  const properties = renderFeature2.getProperties();
  const feature = new Feature_default();
  if (geometryName !== void 0) {
    feature.setGeometryName(geometryName);
  }
  feature.setGeometry(geometry);
  if (id !== void 0) {
    feature.setId(id);
  }
  feature.setProperties(properties, true);
  return feature;
}
var tmpTransform2, RenderFeature, Feature_default2;
var init_Feature2 = __esm({
  "node_modules/ol/render/Feature.js"() {
    init_Feature();
    init_geom();
    init_transform();
    init_extent();
    init_simplify();
    init_array();
    init_interiorpoint();
    init_proj();
    init_orient();
    init_interpolate();
    init_center();
    init_functions();
    init_transform2();
    tmpTransform2 = create();
    RenderFeature = class _RenderFeature {
      /**
       * @param {Type} type Geometry type.
       * @param {Array<number>} flatCoordinates Flat coordinates. These always need
       *     to be right-handed for polygons.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @param {Object<string, *>} properties Properties.
       * @param {number|string|undefined} id Feature id.
       */
      constructor(type, flatCoordinates, ends, stride, properties, id) {
        this.styleFunction;
        this.extent_;
        this.id_ = id;
        this.type_ = type;
        this.flatCoordinates_ = flatCoordinates;
        this.flatInteriorPoints_ = null;
        this.flatMidpoints_ = null;
        this.ends_ = ends;
        this.properties_ = properties;
        this.squaredTolerance_;
        this.stride_ = stride;
        this.simplifiedGeometry_;
      }
      /**
       * Get a feature property by its key.
       * @param {string} key Key
       * @return {*} Value for the requested key.
       * @api
       */
      get(key) {
        return this.properties_[key];
      }
      /**
       * Get the extent of this feature's geometry.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getExtent() {
        if (!this.extent_) {
          this.extent_ = this.type_ === "Point" ? createOrUpdateFromCoordinate(this.flatCoordinates_) : createOrUpdateFromFlatCoordinates(
            this.flatCoordinates_,
            0,
            this.flatCoordinates_.length,
            2
          );
        }
        return this.extent_;
      }
      /**
       * @return {Array<number>} Flat interior points.
       */
      getFlatInteriorPoint() {
        if (!this.flatInteriorPoints_) {
          const flatCenter = getCenter(this.getExtent());
          this.flatInteriorPoints_ = getInteriorPointOfArray(
            this.flatCoordinates_,
            0,
            /** @type {Array<number>} */
            this.ends_,
            2,
            flatCenter,
            0
          );
        }
        return this.flatInteriorPoints_;
      }
      /**
       * @return {Array<number>} Flat interior points.
       */
      getFlatInteriorPoints() {
        if (!this.flatInteriorPoints_) {
          const ends = inflateEnds(this.flatCoordinates_, this.ends_);
          const flatCenters = linearRingss2(this.flatCoordinates_, 0, ends, 2);
          this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(
            this.flatCoordinates_,
            0,
            ends,
            2,
            flatCenters
          );
        }
        return this.flatInteriorPoints_;
      }
      /**
       * @return {Array<number>} Flat midpoint.
       */
      getFlatMidpoint() {
        if (!this.flatMidpoints_) {
          this.flatMidpoints_ = interpolatePoint(
            this.flatCoordinates_,
            0,
            this.flatCoordinates_.length,
            2,
            0.5
          );
        }
        return this.flatMidpoints_;
      }
      /**
       * @return {Array<number>} Flat midpoints.
       */
      getFlatMidpoints() {
        if (!this.flatMidpoints_) {
          this.flatMidpoints_ = [];
          const flatCoordinates = this.flatCoordinates_;
          let offset2 = 0;
          const ends = (
            /** @type {Array<number>} */
            this.ends_
          );
          for (let i = 0, ii = ends.length; i < ii; ++i) {
            const end = ends[i];
            const midpoint = interpolatePoint(flatCoordinates, offset2, end, 2, 0.5);
            extend(this.flatMidpoints_, midpoint);
            offset2 = end;
          }
        }
        return this.flatMidpoints_;
      }
      /**
       * Get the feature identifier.  This is a stable identifier for the feature and
       * is set when reading data from a remote source.
       * @return {number|string|undefined} Id.
       * @api
       */
      getId() {
        return this.id_;
      }
      /**
       * @return {Array<number>} Flat coordinates.
       */
      getOrientedFlatCoordinates() {
        return this.flatCoordinates_;
      }
      /**
       * For API compatibility with {@link module:ol/Feature~Feature}, this method is useful when
       * determining the geometry type in style function (see {@link #getType}).
       * @return {RenderFeature} Feature.
       * @api
       */
      getGeometry() {
        return this;
      }
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {RenderFeature} Simplified geometry.
       */
      getSimplifiedGeometry(squaredTolerance) {
        return this;
      }
      /**
       * Get a transformed and simplified version of the geometry.
       * @param {number} squaredTolerance Squared tolerance.
       * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
       * @return {RenderFeature} Simplified geometry.
       */
      simplifyTransformed(squaredTolerance, transform2) {
        return this;
      }
      /**
       * Get the feature properties.
       * @return {Object<string, *>} Feature properties.
       * @api
       */
      getProperties() {
        return this.properties_;
      }
      /**
       * Get an object of all property names and values.  This has the same behavior as getProperties,
       * but is here to conform with the {@link module:ol/Feature~Feature} interface.
       * @return {Object<string, *>?} Object.
       */
      getPropertiesInternal() {
        return this.properties_;
      }
      /**
       * @return {number} Stride.
       */
      getStride() {
        return this.stride_;
      }
      /**
       * @return {import('../style/Style.js').StyleFunction|undefined} Style
       */
      getStyleFunction() {
        return this.styleFunction;
      }
      /**
       * Get the type of this feature's geometry.
       * @return {Type} Geometry type.
       * @api
       */
      getType() {
        return this.type_;
      }
      /**
       * Transform geometry coordinates from tile pixel space to projected.
       *
       * @param {import("../proj.js").ProjectionLike} projection The data projection
       */
      transform(projection) {
        projection = get3(projection);
        const pixelExtent = projection.getExtent();
        const projectedExtent = projection.getWorldExtent();
        if (pixelExtent && projectedExtent) {
          const scale5 = getHeight(projectedExtent) / getHeight(pixelExtent);
          compose(
            tmpTransform2,
            projectedExtent[0],
            projectedExtent[3],
            scale5,
            -scale5,
            0,
            0,
            0
          );
          transform2D(
            this.flatCoordinates_,
            0,
            this.flatCoordinates_.length,
            2,
            tmpTransform2,
            this.flatCoordinates_
          );
        }
      }
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       */
      applyTransform(transformFn) {
        transformFn(this.flatCoordinates_, this.flatCoordinates_, this.stride_);
      }
      /**
       * @return {RenderFeature} A cloned render feature.
       */
      clone() {
        return new _RenderFeature(
          this.type_,
          this.flatCoordinates_.slice(),
          this.ends_.slice(),
          this.stride_,
          Object.assign({}, this.properties_),
          this.id_
        );
      }
      /**
       * @return {Array<number>} Ends.
       */
      getEnds() {
        return this.ends_;
      }
      /**
       * Add transform and resolution based geometry simplification to this instance.
       * @return {RenderFeature} This render feature.
       */
      enableSimplifyTransformed() {
        this.simplifyTransformed = memoizeOne((squaredTolerance, transform2) => {
          if (squaredTolerance === this.squaredTolerance_) {
            return this.simplifiedGeometry_;
          }
          this.simplifiedGeometry_ = this.clone();
          if (transform2) {
            this.simplifiedGeometry_.applyTransform(transform2);
          }
          const simplifiedFlatCoordinates = this.simplifiedGeometry_.getFlatCoordinates();
          let simplifiedEnds;
          switch (this.type_) {
            case "LineString":
              simplifiedFlatCoordinates.length = douglasPeucker(
                simplifiedFlatCoordinates,
                0,
                this.simplifiedGeometry_.flatCoordinates_.length,
                this.simplifiedGeometry_.stride_,
                squaredTolerance,
                simplifiedFlatCoordinates,
                0
              );
              simplifiedEnds = [simplifiedFlatCoordinates.length];
              break;
            case "MultiLineString":
              simplifiedEnds = [];
              simplifiedFlatCoordinates.length = douglasPeuckerArray(
                simplifiedFlatCoordinates,
                0,
                this.simplifiedGeometry_.ends_,
                this.simplifiedGeometry_.stride_,
                squaredTolerance,
                simplifiedFlatCoordinates,
                0,
                simplifiedEnds
              );
              break;
            case "Polygon":
              simplifiedEnds = [];
              simplifiedFlatCoordinates.length = quantizeArray(
                simplifiedFlatCoordinates,
                0,
                this.simplifiedGeometry_.ends_,
                this.simplifiedGeometry_.stride_,
                Math.sqrt(squaredTolerance),
                simplifiedFlatCoordinates,
                0,
                simplifiedEnds
              );
              break;
            default:
          }
          if (simplifiedEnds) {
            this.simplifiedGeometry_ = new _RenderFeature(
              this.type_,
              simplifiedFlatCoordinates,
              simplifiedEnds,
              2,
              this.properties_,
              this.id_
            );
          }
          this.squaredTolerance_ = squaredTolerance;
          return this.simplifiedGeometry_;
        });
        return this;
      }
    };
    RenderFeature.prototype.getFlatCoordinates = RenderFeature.prototype.getOrientedFlatCoordinates;
    Feature_default2 = RenderFeature;
  }
});

// node_modules/ol/source/VectorEventType.js
var VectorEventType_default;
var init_VectorEventType = __esm({
  "node_modules/ol/source/VectorEventType.js"() {
    VectorEventType_default = {
      /**
       * Triggered when a feature is added to the source.
       * @event module:ol/source/Vector.VectorSourceEvent#addfeature
       * @api
       */
      ADDFEATURE: "addfeature",
      /**
       * Triggered when a feature is updated.
       * @event module:ol/source/Vector.VectorSourceEvent#changefeature
       * @api
       */
      CHANGEFEATURE: "changefeature",
      /**
       * Triggered when the clear method is called on the source.
       * @event module:ol/source/Vector.VectorSourceEvent#clear
       * @api
       */
      CLEAR: "clear",
      /**
       * Triggered when a feature is removed from the source.
       * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
       * @event module:ol/source/Vector.VectorSourceEvent#removefeature
       * @api
       */
      REMOVEFEATURE: "removefeature",
      /**
       * Triggered when features starts loading.
       * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
       * @api
       */
      FEATURESLOADSTART: "featuresloadstart",
      /**
       * Triggered when features finishes loading.
       * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
       * @api
       */
      FEATURESLOADEND: "featuresloadend",
      /**
       * Triggered if feature loading results in an error.
       * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
       * @api
       */
      FEATURESLOADERROR: "featuresloaderror"
    };
  }
});

// node_modules/ol/loadingstrategy.js
function all2(extent, resolution) {
  return [[-Infinity, -Infinity, Infinity, Infinity]];
}
function bbox(extent, resolution) {
  return [extent];
}
function tile(tileGrid) {
  return (
    /**
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("./proj.js").Projection} projection Projection.
     * @return {Array<import("./extent.js").Extent>} Extents.
     */
    function(extent, resolution, projection) {
      const z = tileGrid.getZForResolution(
        fromUserResolution(resolution, projection)
      );
      const tileRange = tileGrid.getTileRangeForExtentAndZ(
        fromUserExtent(extent, projection),
        z
      );
      const extents = [];
      const tileCoord = [z, 0, 0];
      for (tileCoord[1] = tileRange.minX; tileCoord[1] <= tileRange.maxX; ++tileCoord[1]) {
        for (tileCoord[2] = tileRange.minY; tileCoord[2] <= tileRange.maxY; ++tileCoord[2]) {
          extents.push(
            toUserExtent(tileGrid.getTileCoordExtent(tileCoord), projection)
          );
        }
      }
      return extents;
    }
  );
}
var init_loadingstrategy = __esm({
  "node_modules/ol/loadingstrategy.js"() {
    init_proj();
  }
});

// node_modules/ol/featureloader.js
function loadFeaturesXhr(url, format2, extent, resolution, projection, success, failure) {
  const xhr2 = new XMLHttpRequest();
  xhr2.open(
    "GET",
    typeof url === "function" ? url(extent, resolution, projection) : url,
    true
  );
  if (format2.getType() == "arraybuffer") {
    xhr2.responseType = "arraybuffer";
  }
  xhr2.withCredentials = withCredentials;
  xhr2.onload = function(event) {
    if (!xhr2.status || xhr2.status >= 200 && xhr2.status < 300) {
      const type = format2.getType();
      let source;
      if (type == "json") {
        source = JSON.parse(xhr2.responseText);
      } else if (type == "text") {
        source = xhr2.responseText;
      } else if (type == "xml") {
        source = xhr2.responseXML;
        if (!source) {
          source = new DOMParser().parseFromString(
            xhr2.responseText,
            "application/xml"
          );
        }
      } else if (type == "arraybuffer") {
        source = /** @type {ArrayBuffer} */
        xhr2.response;
      }
      if (source) {
        success(
          /** @type {Array<import("./Feature.js").default>} */
          format2.readFeatures(source, {
            extent,
            featureProjection: projection
          }),
          format2.readProjection(source)
        );
      } else {
        failure();
      }
    } else {
      failure();
    }
  };
  xhr2.onerror = failure;
  xhr2.send();
}
function xhr(url, format2) {
  return function(extent, resolution, projection, success, failure) {
    const source = (
      /** @type {import("./source/Vector").default} */
      this
    );
    loadFeaturesXhr(
      url,
      format2,
      extent,
      resolution,
      projection,
      /**
       * @param {Array<import("./Feature.js").default>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       */
      function(features, dataProjection) {
        source.addFeatures(features);
        if (success !== void 0) {
          success(features);
        }
      },
      /* FIXME handle error */
      failure ? failure : VOID
    );
  };
}
function setWithCredentials(xhrWithCredentials) {
  withCredentials = xhrWithCredentials;
}
var withCredentials;
var init_featureloader = __esm({
  "node_modules/ol/featureloader.js"() {
    init_functions();
    withCredentials = false;
  }
});

// node_modules/ol/source/Vector.js
var Vector_exports2 = {};
__export(Vector_exports2, {
  VectorSourceEvent: () => VectorSourceEvent,
  default: () => Vector_default2
});
var VectorSourceEvent, VectorSource, Vector_default2;
var init_Vector2 = __esm({
  "node_modules/ol/source/Vector.js"() {
    init_Collection();
    init_CollectionEventType();
    init_Event();
    init_EventType();
    init_ObjectEventType();
    init_RBush();
    init_Feature2();
    init_Source();
    init_VectorEventType();
    init_functions();
    init_loadingstrategy();
    init_asserts();
    init_extent();
    init_array();
    init_util();
    init_obj();
    init_events();
    init_featureloader();
    VectorSourceEvent = class extends Event_default {
      /**
       * @param {string} type Type.
       * @param {FeatureClass} [feature] Feature.
       * @param {Array<FeatureClass>} [features] Features.
       */
      constructor(type, feature, features) {
        super(type);
        this.feature = feature;
        this.features = features;
      }
    };
    VectorSource = class extends Source_default {
      /**
       * @param {Options<FeatureClass>} [options] Vector source options.
       */
      constructor(options) {
        options = options || {};
        super({
          attributions: options.attributions,
          interpolate: true,
          projection: void 0,
          state: "ready",
          wrapX: options.wrapX !== void 0 ? options.wrapX : true
        });
        this.on;
        this.once;
        this.un;
        this.loader_ = VOID;
        this.format_ = options.format;
        this.overlaps_ = options.overlaps === void 0 ? true : options.overlaps;
        this.url_ = options.url;
        if (options.loader !== void 0) {
          this.loader_ = options.loader;
        } else if (this.url_ !== void 0) {
          assert(this.format_, "`format` must be set when `url` is set");
          this.loader_ = xhr(
            this.url_,
            /** @type {import("../format/Feature.js").default} */
            this.format_
          );
        }
        this.strategy_ = options.strategy !== void 0 ? options.strategy : all2;
        const useSpatialIndex = options.useSpatialIndex !== void 0 ? options.useSpatialIndex : true;
        this.featuresRtree_ = useSpatialIndex ? new RBush_default() : null;
        this.loadedExtentsRtree_ = new RBush_default();
        this.loadingExtentsCount_ = 0;
        this.nullGeometryFeatures_ = {};
        this.idIndex_ = {};
        this.uidIndex_ = {};
        this.featureChangeKeys_ = {};
        this.featuresCollection_ = null;
        let collection;
        let features;
        if (Array.isArray(options.features)) {
          features = options.features;
        } else if (options.features) {
          collection = options.features;
          features = collection.getArray();
        }
        if (!useSpatialIndex && collection === void 0) {
          collection = new Collection_default(features);
        }
        if (features !== void 0) {
          this.addFeaturesInternal(features);
        }
        if (collection !== void 0) {
          this.bindFeaturesCollection_(collection);
        }
      }
      /**
       * Add a single feature to the source.  If you want to add a batch of features
       * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
       * instead. A feature will not be added to the source if feature with
       * the same id is already there. The reason for this behavior is to avoid
       * feature duplication when using bbox or tile loading strategies.
       * Note: this also applies if an {@link module:ol/Collection~Collection} is used for features,
       * meaning that if a feature with a duplicate id is added in the collection, it will
       * be removed from it right away.
       * @param {FeatureClass} feature Feature to add.
       * @api
       */
      addFeature(feature) {
        this.addFeatureInternal(feature);
        this.changed();
      }
      /**
       * Add a feature without firing a `change` event.
       * @param {FeatureClass} feature Feature.
       * @protected
       */
      addFeatureInternal(feature) {
        const featureKey = getUid(feature);
        if (!this.addToIndex_(featureKey, feature)) {
          if (this.featuresCollection_) {
            this.featuresCollection_.remove(feature);
          }
          return;
        }
        this.setupChangeEvents_(featureKey, feature);
        const geometry = feature.getGeometry();
        if (geometry) {
          const extent = geometry.getExtent();
          if (this.featuresRtree_) {
            this.featuresRtree_.insert(extent, feature);
          }
        } else {
          this.nullGeometryFeatures_[featureKey] = feature;
        }
        this.dispatchEvent(
          new VectorSourceEvent(VectorEventType_default.ADDFEATURE, feature)
        );
      }
      /**
       * @param {string} featureKey Unique identifier for the feature.
       * @param {FeatureClass} feature The feature.
       * @private
       */
      setupChangeEvents_(featureKey, feature) {
        if (feature instanceof Feature_default2) {
          return;
        }
        this.featureChangeKeys_[featureKey] = [
          listen(feature, EventType_default.CHANGE, this.handleFeatureChange_, this),
          listen(
            feature,
            ObjectEventType_default.PROPERTYCHANGE,
            this.handleFeatureChange_,
            this
          )
        ];
      }
      /**
       * @param {string} featureKey Unique identifier for the feature.
       * @param {FeatureClass} feature The feature.
       * @return {boolean} The feature is "valid", in the sense that it is also a
       *     candidate for insertion into the Rtree.
       * @private
       */
      addToIndex_(featureKey, feature) {
        let valid = true;
        if (feature.getId() !== void 0) {
          const id = String(feature.getId());
          if (!(id in this.idIndex_)) {
            this.idIndex_[id] = feature;
          } else if (feature instanceof Feature_default2) {
            const indexedFeature = this.idIndex_[id];
            if (!(indexedFeature instanceof Feature_default2)) {
              valid = false;
            } else {
              if (!Array.isArray(indexedFeature)) {
                this.idIndex_[id] = [indexedFeature, feature];
              } else {
                indexedFeature.push(feature);
              }
            }
          } else {
            valid = false;
          }
        }
        if (valid) {
          assert(
            !(featureKey in this.uidIndex_),
            "The passed `feature` was already added to the source"
          );
          this.uidIndex_[featureKey] = feature;
        }
        return valid;
      }
      /**
       * Add a batch of features to the source.
       * @param {Array<FeatureClass>} features Features to add.
       * @api
       */
      addFeatures(features) {
        this.addFeaturesInternal(features);
        this.changed();
      }
      /**
       * Add features without firing a `change` event.
       * @param {Array<FeatureClass>} features Features.
       * @protected
       */
      addFeaturesInternal(features) {
        const extents = [];
        const newFeatures = [];
        const geometryFeatures = [];
        for (let i = 0, length = features.length; i < length; i++) {
          const feature = features[i];
          const featureKey = getUid(feature);
          if (this.addToIndex_(featureKey, feature)) {
            newFeatures.push(feature);
          }
        }
        for (let i = 0, length = newFeatures.length; i < length; i++) {
          const feature = newFeatures[i];
          const featureKey = getUid(feature);
          this.setupChangeEvents_(featureKey, feature);
          const geometry = feature.getGeometry();
          if (geometry) {
            const extent = geometry.getExtent();
            extents.push(extent);
            geometryFeatures.push(feature);
          } else {
            this.nullGeometryFeatures_[featureKey] = feature;
          }
        }
        if (this.featuresRtree_) {
          this.featuresRtree_.load(extents, geometryFeatures);
        }
        if (this.hasListener(VectorEventType_default.ADDFEATURE)) {
          for (let i = 0, length = newFeatures.length; i < length; i++) {
            this.dispatchEvent(
              new VectorSourceEvent(VectorEventType_default.ADDFEATURE, newFeatures[i])
            );
          }
        }
      }
      /**
       * @param {!Collection<FeatureClass>} collection Collection.
       * @private
       */
      bindFeaturesCollection_(collection) {
        let modifyingCollection = false;
        this.addEventListener(
          VectorEventType_default.ADDFEATURE,
          /**
           * @param {VectorSourceEvent<FeatureClass>} evt The vector source event
           */
          function(evt) {
            if (!modifyingCollection) {
              modifyingCollection = true;
              collection.push(evt.feature);
              modifyingCollection = false;
            }
          }
        );
        this.addEventListener(
          VectorEventType_default.REMOVEFEATURE,
          /**
           * @param {VectorSourceEvent<FeatureClass>} evt The vector source event
           */
          function(evt) {
            if (!modifyingCollection) {
              modifyingCollection = true;
              collection.remove(evt.feature);
              modifyingCollection = false;
            }
          }
        );
        collection.addEventListener(
          CollectionEventType_default.ADD,
          /**
           * @param {import("../Collection.js").CollectionEvent<FeatureClass>} evt The collection event
           */
          (evt) => {
            if (!modifyingCollection) {
              modifyingCollection = true;
              this.addFeature(evt.element);
              modifyingCollection = false;
            }
          }
        );
        collection.addEventListener(
          CollectionEventType_default.REMOVE,
          /**
           * @param {import("../Collection.js").CollectionEvent<FeatureClass>} evt The collection event
           */
          (evt) => {
            if (!modifyingCollection) {
              modifyingCollection = true;
              this.removeFeature(evt.element);
              modifyingCollection = false;
            }
          }
        );
        this.featuresCollection_ = collection;
      }
      /**
       * Remove all features from the source.
       * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
       * @api
       */
      clear(fast) {
        if (fast) {
          for (const featureId in this.featureChangeKeys_) {
            const keys = this.featureChangeKeys_[featureId];
            keys.forEach(unlistenByKey);
          }
          if (!this.featuresCollection_) {
            this.featureChangeKeys_ = {};
            this.idIndex_ = {};
            this.uidIndex_ = {};
          }
        } else {
          if (this.featuresRtree_) {
            const removeAndIgnoreReturn = (feature) => {
              this.removeFeatureInternal(feature);
            };
            this.featuresRtree_.forEach(removeAndIgnoreReturn);
            for (const id in this.nullGeometryFeatures_) {
              this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
            }
          }
        }
        if (this.featuresCollection_) {
          this.featuresCollection_.clear();
        }
        if (this.featuresRtree_) {
          this.featuresRtree_.clear();
        }
        this.nullGeometryFeatures_ = {};
        const clearEvent = new VectorSourceEvent(VectorEventType_default.CLEAR);
        this.dispatchEvent(clearEvent);
        this.changed();
      }
      /**
       * Iterate through all features on the source, calling the provided callback
       * with each one.  If the callback returns any "truthy" value, iteration will
       * stop and the function will return the same value.
       * Note: this function only iterate through the feature that have a defined geometry.
       *
       * @param {function(FeatureClass): T} callback Called with each feature
       *     on the source.  Return a truthy value to stop iteration.
       * @return {T|undefined} The return value from the last call to the callback.
       * @template T
       * @api
       */
      forEachFeature(callback) {
        if (this.featuresRtree_) {
          return this.featuresRtree_.forEach(callback);
        }
        if (this.featuresCollection_) {
          this.featuresCollection_.forEach(callback);
        }
      }
      /**
       * Iterate through all features whose geometries contain the provided
       * coordinate, calling the callback with each feature.  If the callback returns
       * a "truthy" value, iteration will stop and the function will return the same
       * value.
       *
       * For {@link module:ol/render/Feature~RenderFeature} features, the callback will be
       * called for all features.
       *
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {function(FeatureClass): T} callback Called with each feature
       *     whose goemetry contains the provided coordinate.
       * @return {T|undefined} The return value from the last call to the callback.
       * @template T
       */
      forEachFeatureAtCoordinateDirect(coordinate, callback) {
        const extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
        return this.forEachFeatureInExtent(extent, function(feature) {
          const geometry = feature.getGeometry();
          if (geometry instanceof Feature_default2 || geometry.intersectsCoordinate(coordinate)) {
            return callback(feature);
          }
          return void 0;
        });
      }
      /**
       * Iterate through all features whose bounding box intersects the provided
       * extent (note that the feature's geometry may not intersect the extent),
       * calling the callback with each feature.  If the callback returns a "truthy"
       * value, iteration will stop and the function will return the same value.
       *
       * If you are interested in features whose geometry intersects an extent, call
       * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
       *
       * When `useSpatialIndex` is set to false, this method will loop through all
       * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
       *
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {function(FeatureClass): T} callback Called with each feature
       *     whose bounding box intersects the provided extent.
       * @return {T|undefined} The return value from the last call to the callback.
       * @template T
       * @api
       */
      forEachFeatureInExtent(extent, callback) {
        if (this.featuresRtree_) {
          return this.featuresRtree_.forEachInExtent(extent, callback);
        }
        if (this.featuresCollection_) {
          this.featuresCollection_.forEach(callback);
        }
      }
      /**
       * Iterate through all features whose geometry intersects the provided extent,
       * calling the callback with each feature.  If the callback returns a "truthy"
       * value, iteration will stop and the function will return the same value.
       *
       * If you only want to test for bounding box intersection, call the
       * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
       *
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {function(FeatureClass): T} callback Called with each feature
       *     whose geometry intersects the provided extent.
       * @return {T|undefined} The return value from the last call to the callback.
       * @template T
       * @api
       */
      forEachFeatureIntersectingExtent(extent, callback) {
        return this.forEachFeatureInExtent(
          extent,
          /**
           * @param {FeatureClass} feature Feature.
           * @return {T|undefined} The return value from the last call to the callback.
           */
          function(feature) {
            const geometry = feature.getGeometry();
            if (geometry instanceof Feature_default2 || geometry.intersectsExtent(extent)) {
              const result = callback(feature);
              if (result) {
                return result;
              }
            }
          }
        );
      }
      /**
       * Get the features collection associated with this source. Will be `null`
       * unless the source was configured with `useSpatialIndex` set to `false`, or
       * with an {@link module:ol/Collection~Collection} as `features`.
       * @return {Collection<FeatureClass>|null} The collection of features.
       * @api
       */
      getFeaturesCollection() {
        return this.featuresCollection_;
      }
      /**
       * Get a snapshot of the features currently on the source in random order. The returned array
       * is a copy, the features are references to the features in the source.
       * @return {Array<FeatureClass>} Features.
       * @api
       */
      getFeatures() {
        let features;
        if (this.featuresCollection_) {
          features = this.featuresCollection_.getArray().slice(0);
        } else if (this.featuresRtree_) {
          features = this.featuresRtree_.getAll();
          if (!isEmpty(this.nullGeometryFeatures_)) {
            extend(features, Object.values(this.nullGeometryFeatures_));
          }
        }
        return features;
      }
      /**
       * Get all features whose geometry intersects the provided coordinate.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @return {Array<import("../Feature.js").default>} Features.
       * @api
       */
      getFeaturesAtCoordinate(coordinate) {
        const features = [];
        this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
          features.push(feature);
        });
        return features;
      }
      /**
       * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
       * all features intersecting the given extent in random order (so it may include
       * features whose geometries do not intersect the extent).
       *
       * When `useSpatialIndex` is set to false, this method will return all
       * features.
       *
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {import("../proj/Projection.js").default} [projection] Include features
       * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
       * @return {Array<FeatureClass>} Features.
       * @api
       */
      getFeaturesInExtent(extent, projection) {
        if (this.featuresRtree_) {
          const multiWorld = projection && projection.canWrapX() && this.getWrapX();
          if (!multiWorld) {
            return this.featuresRtree_.getInExtent(extent);
          }
          const extents = wrapAndSliceX(extent, projection);
          return [].concat(
            ...extents.map((anExtent) => this.featuresRtree_.getInExtent(anExtent))
          );
        }
        if (this.featuresCollection_) {
          return this.featuresCollection_.getArray().slice(0);
        }
        return [];
      }
      /**
       * Get the closest feature to the provided coordinate.
       *
       * This method is not available when the source is configured with
       * `useSpatialIndex` set to `false` and the features in this source are of type
       * {@link module:ol/Feature~Feature}.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {function(FeatureClass):boolean} [filter] Feature filter function.
       *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
       *     and it should return a boolean value. By default, no filtering is made.
       * @return {FeatureClass} Closest feature.
       * @api
       */
      getClosestFeatureToCoordinate(coordinate, filter) {
        const x = coordinate[0];
        const y = coordinate[1];
        let closestFeature = null;
        const closestPoint = [NaN, NaN];
        let minSquaredDistance = Infinity;
        const extent = [-Infinity, -Infinity, Infinity, Infinity];
        filter = filter ? filter : TRUE;
        this.featuresRtree_.forEachInExtent(
          extent,
          /**
           * @param {FeatureClass} feature Feature.
           */
          function(feature) {
            if (filter(feature)) {
              const geometry = feature.getGeometry();
              const previousMinSquaredDistance = minSquaredDistance;
              minSquaredDistance = geometry instanceof Feature_default2 ? 0 : geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);
              if (minSquaredDistance < previousMinSquaredDistance) {
                closestFeature = feature;
                const minDistance = Math.sqrt(minSquaredDistance);
                extent[0] = x - minDistance;
                extent[1] = y - minDistance;
                extent[2] = x + minDistance;
                extent[3] = y + minDistance;
              }
            }
          }
        );
        return closestFeature;
      }
      /**
       * Get the extent of the features currently in the source.
       *
       * This method is not available when the source is configured with
       * `useSpatialIndex` set to `false`.
       * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
       *     will be created. Instead, that extent's coordinates will be overwritten.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      getExtent(extent) {
        return this.featuresRtree_.getExtent(extent);
      }
      /**
       * Get a feature by its identifier (the value returned by feature.getId()). When `RenderFeature`s
       * are used, `getFeatureById()` can return an array of `RenderFeature`s. This allows for handling
       * of `GeometryCollection` geometries, where format readers create one `RenderFeature` per
       * `GeometryCollection` member.
       * Note that the index treats string and numeric identifiers as the same.  So
       * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
       *
       * @param {string|number} id Feature identifier.
       * @return {FeatureClass|Array<RenderFeature>|null} The feature (or `null` if not found).
       * @api
       */
      getFeatureById(id) {
        const feature = this.idIndex_[id.toString()];
        return feature !== void 0 ? feature : null;
      }
      /**
       * Get a feature by its internal unique identifier (using `getUid`).
       *
       * @param {string} uid Feature identifier.
       * @return {FeatureClass|null} The feature (or `null` if not found).
       */
      getFeatureByUid(uid) {
        const feature = this.uidIndex_[uid];
        return feature !== void 0 ? feature : null;
      }
      /**
       * Get the format associated with this source.
       *
       * @return {import("../format/Feature.js").default|undefined} The feature format.
       * @api
       */
      getFormat() {
        return this.format_;
      }
      /**
       * @return {boolean} The source can have overlapping geometries.
       */
      getOverlaps() {
        return this.overlaps_;
      }
      /**
       * Get the url associated with this source.
       *
       * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
       * @api
       */
      getUrl() {
        return this.url_;
      }
      /**
       * @param {Event} event Event.
       * @private
       */
      handleFeatureChange_(event) {
        const feature = (
          /** @type {FeatureClass} */
          event.target
        );
        const featureKey = getUid(feature);
        const geometry = feature.getGeometry();
        if (!geometry) {
          if (!(featureKey in this.nullGeometryFeatures_)) {
            if (this.featuresRtree_) {
              this.featuresRtree_.remove(feature);
            }
            this.nullGeometryFeatures_[featureKey] = feature;
          }
        } else {
          const extent = geometry.getExtent();
          if (featureKey in this.nullGeometryFeatures_) {
            delete this.nullGeometryFeatures_[featureKey];
            if (this.featuresRtree_) {
              this.featuresRtree_.insert(extent, feature);
            }
          } else {
            if (this.featuresRtree_) {
              this.featuresRtree_.update(extent, feature);
            }
          }
        }
        const id = feature.getId();
        if (id !== void 0) {
          const sid = id.toString();
          if (this.idIndex_[sid] !== feature) {
            this.removeFromIdIndex_(feature);
            this.idIndex_[sid] = feature;
          }
        } else {
          this.removeFromIdIndex_(feature);
          this.uidIndex_[featureKey] = feature;
        }
        this.changed();
        this.dispatchEvent(
          new VectorSourceEvent(VectorEventType_default.CHANGEFEATURE, feature)
        );
      }
      /**
       * Returns true if the feature is contained within the source.
       * @param {FeatureClass} feature Feature.
       * @return {boolean} Has feature.
       * @api
       */
      hasFeature(feature) {
        const id = feature.getId();
        if (id !== void 0) {
          return id in this.idIndex_;
        }
        return getUid(feature) in this.uidIndex_;
      }
      /**
       * @return {boolean} Is empty.
       */
      isEmpty() {
        if (this.featuresRtree_) {
          return this.featuresRtree_.isEmpty() && isEmpty(this.nullGeometryFeatures_);
        }
        if (this.featuresCollection_) {
          return this.featuresCollection_.getLength() === 0;
        }
        return true;
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {number} resolution Resolution.
       * @param {import("../proj/Projection.js").default} projection Projection.
       */
      loadFeatures(extent, resolution, projection) {
        const loadedExtentsRtree = this.loadedExtentsRtree_;
        const extentsToLoad = this.strategy_(extent, resolution, projection);
        for (let i = 0, ii = extentsToLoad.length; i < ii; ++i) {
          const extentToLoad = extentsToLoad[i];
          const alreadyLoaded = loadedExtentsRtree.forEachInExtent(
            extentToLoad,
            /**
             * @param {{extent: import("../extent.js").Extent}} object Object.
             * @return {boolean} Contains.
             */
            function(object) {
              return containsExtent(object.extent, extentToLoad);
            }
          );
          if (!alreadyLoaded) {
            ++this.loadingExtentsCount_;
            this.dispatchEvent(
              new VectorSourceEvent(VectorEventType_default.FEATURESLOADSTART)
            );
            this.loader_.call(
              this,
              extentToLoad,
              resolution,
              projection,
              (features) => {
                --this.loadingExtentsCount_;
                this.dispatchEvent(
                  new VectorSourceEvent(
                    VectorEventType_default.FEATURESLOADEND,
                    void 0,
                    features
                  )
                );
              },
              () => {
                --this.loadingExtentsCount_;
                this.dispatchEvent(
                  new VectorSourceEvent(VectorEventType_default.FEATURESLOADERROR)
                );
              }
            );
            loadedExtentsRtree.insert(extentToLoad, { extent: extentToLoad.slice() });
          }
        }
        this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
      }
      refresh() {
        this.clear(true);
        this.loadedExtentsRtree_.clear();
        super.refresh();
      }
      /**
       * Remove an extent from the list of loaded extents.
       * @param {import("../extent.js").Extent} extent Extent.
       * @api
       */
      removeLoadedExtent(extent) {
        const loadedExtentsRtree = this.loadedExtentsRtree_;
        let obj;
        loadedExtentsRtree.forEachInExtent(extent, function(object) {
          if (equals2(object.extent, extent)) {
            obj = object;
            return true;
          }
        });
        if (obj) {
          loadedExtentsRtree.remove(obj);
        }
      }
      /**
       * Remove a single feature from the source.  If you want to remove all features
       * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
       * instead.
       * @param {FeatureClass} feature Feature to remove.
       * @api
       */
      removeFeature(feature) {
        if (!feature) {
          return;
        }
        const featureKey = getUid(feature);
        if (featureKey in this.nullGeometryFeatures_) {
          delete this.nullGeometryFeatures_[featureKey];
        } else {
          if (this.featuresRtree_) {
            this.featuresRtree_.remove(feature);
          }
        }
        const result = this.removeFeatureInternal(feature);
        if (result) {
          this.changed();
        }
      }
      /**
       * Remove feature without firing a `change` event.
       * @param {FeatureClass} feature Feature.
       * @return {FeatureClass|undefined} The removed feature
       *     (or undefined if the feature was not found).
       * @protected
       */
      removeFeatureInternal(feature) {
        const featureKey = getUid(feature);
        const featureChangeKeys = this.featureChangeKeys_[featureKey];
        if (!featureChangeKeys) {
          return;
        }
        featureChangeKeys.forEach(unlistenByKey);
        delete this.featureChangeKeys_[featureKey];
        const id = feature.getId();
        if (id !== void 0) {
          delete this.idIndex_[id.toString()];
        }
        delete this.uidIndex_[featureKey];
        this.dispatchEvent(
          new VectorSourceEvent(VectorEventType_default.REMOVEFEATURE, feature)
        );
        return feature;
      }
      /**
       * Remove a feature from the id index.  Called internally when the feature id
       * may have changed.
       * @param {FeatureClass} feature The feature.
       * @return {boolean} Removed the feature from the index.
       * @private
       */
      removeFromIdIndex_(feature) {
        let removed = false;
        for (const id in this.idIndex_) {
          const indexedFeature = this.idIndex_[id];
          if (feature instanceof Feature_default2 && Array.isArray(indexedFeature) && indexedFeature.includes(feature)) {
            indexedFeature.splice(indexedFeature.indexOf(feature), 1);
          } else if (this.idIndex_[id] === feature) {
            delete this.idIndex_[id];
            removed = true;
            break;
          }
        }
        return removed;
      }
      /**
       * Set the new loader of the source. The next render cycle will use the
       * new loader.
       * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
       * @api
       */
      setLoader(loader) {
        this.loader_ = loader;
      }
      /**
       * Points the source to a new url. The next render cycle will use the new url.
       * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
       * @api
       */
      setUrl(url) {
        assert(this.format_, "`format` must be set when `url` is set");
        this.url_ = url;
        this.setLoader(xhr(url, this.format_));
      }
    };
    Vector_default2 = VectorSource;
  }
});

// node_modules/ol-geocoder/dist/ol-geocoder.js
var require_ol_geocoder = __commonJS({
  "node_modules/ol-geocoder/dist/ol-geocoder.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = t((init_Control(), __toCommonJS(Control_exports)), (init_Style(), __toCommonJS(Style_exports)), (init_Icon(), __toCommonJS(Icon_exports)), (init_Vector(), __toCommonJS(Vector_exports)), (init_Vector2(), __toCommonJS(Vector_exports2)), (init_Point(), __toCommonJS(Point_exports)), (init_Feature(), __toCommonJS(Feature_exports)), (init_proj(), __toCommonJS(proj_exports))) : "function" == typeof define && define.amd ? define(["ol/control/Control", "ol/style/Style", "ol/style/Icon", "ol/layer/Vector", "ol/source/Vector", "ol/geom/Point", "ol/Feature", "ol/proj"], t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).Geocoder = t(e.ol.control.Control, e.ol.style.Style, e.ol.style.Icon, e.ol.layer.Vector, e.ol.source.Vector, e.ol.geom.Point, e.ol.Feature, e.ol.proj);
    }(exports, function(e, t, s, r, n, o, a, i) {
      "use strict";
      function l(e2) {
        return e2 && "object" == typeof e2 && "default" in e2 ? e2 : { default: e2 };
      }
      function c(e2) {
        if (e2 && e2.__esModule)
          return e2;
        var t2 = /* @__PURE__ */ Object.create(null);
        return e2 && Object.keys(e2).forEach(function(s2) {
          if ("default" !== s2) {
            var r2 = Object.getOwnPropertyDescriptor(e2, s2);
            Object.defineProperty(t2, s2, r2.get ? r2 : { enumerable: true, get: function() {
              return e2[s2];
            } });
          }
        }), t2.default = e2, Object.freeze(t2);
      }
      var d = l(e), u = l(t), p = l(s), h = l(r), m = l(n), g = l(o), y = l(a), f = c(i), b = "gcd-container", v = "gcd-button-control", w = "gcd-input-query", x = "gcd-input-label", $ = "gcd-input-search", k = { namespace: "ol-geocoder", spin: "gcd-pseudo-rotate", hidden: "gcd-hidden", address: "gcd-address", country: "gcd-country", city: "gcd-city", road: "gcd-road", olControl: "ol-control", glass: { container: "gcd-gl-container", control: "gcd-gl-control", button: "gcd-gl-btn", input: "gcd-gl-input", expanded: "gcd-gl-expanded", search: "gcd-gl-search", result: "gcd-gl-result" }, inputText: { container: "gcd-txt-container", control: "gcd-txt-control", label: "gcd-txt-label", input: "gcd-txt-input", search: "gcd-txt-search", icon: "gcd-txt-glass", result: "gcd-txt-result" } }, S = { containerId: b, buttonControlId: v, inputQueryId: w, inputLabelId: x, inputSearchId: $, cssClasses: k };
      const q = Object.freeze({ __proto__: null, containerId: b, buttonControlId: v, inputQueryId: w, inputLabelId: x, inputSearchId: $, cssClasses: k, default: S }), L = "addresschosen", C = "nominatim", j = "reverse", E = "glass-button", T = "text-input", I = "osm", N = "mapquest", P = "photon", A = "bing", R = "opencage", F = { provider: I, label: "", placeholder: "Search for an address", featureStyle: null, targetType: E, lang: "en-US", limit: 5, keepOpen: false, preventDefault: false, preventPanning: false, preventMarker: false, defaultFlyResolution: 10, debug: false };
      function _(e2, t2 = "Assertion failed") {
        if (!e2) {
          if ("undefined" != typeof Error)
            throw new Error(t2);
          throw t2;
        }
      }
      function M(e2) {
        const t2 = function() {
          if ("performance" in window == 0 && (window.performance = {}), "now" in window.performance == 0) {
            let e3 = Date.now();
            performance.timing && performance.timing.navigationStart && (e3 = performance.timing.navigationStart), window.performance.now = () => Date.now() - e3;
          }
          return window.performance.now();
        }().toString(36);
        return e2 ? e2 + t2 : t2;
      }
      function O(e2) {
        return /^\d+$/u.test(e2);
      }
      function D(e2, t2, s2) {
        if (Array.isArray(e2))
          return void e2.forEach((e3) => D(e3, t2));
        const r2 = Array.isArray(t2) ? t2 : t2.split(/\s+/u);
        let n2 = r2.length;
        for (; n2--; )
          Q(e2, r2[n2]) || z(e2, r2[n2], s2);
      }
      function V(e2, t2, s2) {
        if (Array.isArray(e2))
          return void e2.forEach((e3) => V(e3, t2, s2));
        const r2 = Array.isArray(t2) ? t2 : t2.split(/\s+/u);
        let n2 = r2.length;
        for (; n2--; )
          Q(e2, r2[n2]) && H(e2, r2[n2], s2);
      }
      function Q(e2, t2) {
        return e2.classList ? e2.classList.contains(t2) : G(t2).test(e2.className);
      }
      function B(e2, t2) {
        return e2.replace(/\{\s*([\w-]+)\s*\}/gu, (e3, s2) => {
          const r2 = void 0 === t2[s2] ? "" : t2[s2];
          return String(r2).replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;");
        });
      }
      function U(e2, t2) {
        let s2;
        if (Array.isArray(e2)) {
          if (s2 = document.createElement(e2[0]), e2[1].id && (s2.id = e2[1].id), e2[1].classname && (s2.className = e2[1].classname), e2[1].attr) {
            const { attr: t3 } = e2[1];
            if (Array.isArray(t3)) {
              let e3 = -1;
              for (; ++e3 < t3.length; )
                s2.setAttribute(t3[e3].name, t3[e3].value);
            } else
              s2.setAttribute(t3.name, t3.value);
          }
        } else
          s2 = document.createElement(e2);
        s2.innerHTML = t2;
        const r2 = document.createDocumentFragment();
        for (; s2.childNodes[0]; )
          r2.append(s2.childNodes[0]);
        return s2.append(r2), s2;
      }
      function G(e2) {
        return new RegExp(`(^|\\s+) ${e2} (\\s+|$)`, "u");
      }
      function z(e2, t2, s2) {
        e2.classList ? e2.classList.add(t2) : e2.className = `${e2.className} ${t2}`.trim(), s2 && O(s2) && window.setTimeout(() => H(e2, t2), s2);
      }
      function H(e2, t2, s2) {
        e2.classList ? e2.classList.remove(t2) : e2.className = e2.className.replace(G(t2), " ").trim(), s2 && O(s2) && window.setTimeout(() => z(e2, t2), s2);
      }
      const K = q.cssClasses;
      class J {
        constructor(e2) {
          this.options = e2, this.els = this.createControl();
        }
        createControl() {
          let e2, t2, s2;
          return this.options.targetType === T ? (t2 = `${K.namespace} ${K.inputText.container}`, e2 = U(["div", { id: q.containerId, classname: t2 }], J.input), s2 = { container: e2, control: e2.querySelector(`.${K.inputText.control}`), label: e2.querySelector(`.${K.inputText.label}`), input: e2.querySelector(`.${K.inputText.input}`), search: e2.querySelector(`.${K.inputText.search}`), result: e2.querySelector(`.${K.inputText.result}`) }, s2.label.innerHTML = this.options.label) : (t2 = `${K.namespace} ${K.glass.container}`, e2 = U(["div", { id: q.containerId, classname: t2 }], J.glass), s2 = { container: e2, control: e2.querySelector(`.${K.glass.control}`), button: e2.querySelector(`.${K.glass.button}`), input: e2.querySelector(`.${K.glass.input}`), search: e2.querySelector(`.${K.glass.search}`), result: e2.querySelector(`.${K.glass.result}`) }), s2.input.placeholder = this.options.placeholder, s2;
        }
      }
      function W(e2) {
        return new Promise((t2, s2) => {
          const r2 = function(e3, t3) {
            t3 && "object" == typeof t3 && (e3 += (/\?/u.test(e3) ? "&" : "?") + X(t3));
            return e3;
          }(e2.url, e2.data), n2 = { method: "GET", mode: "cors", credentials: "same-origin" };
          e2.jsonp ? function(e3, t3, s3) {
            const { head: r3 } = document, n3 = document.createElement("script"), o2 = `f${Math.round(Math.random() * Date.now())}`;
            n3.setAttribute("src", `${e3 + (e3.indexOf("?") > 0 ? "&" : "?") + t3}=${o2}`), window[o2] = (e4) => {
              window[o2] = void 0, setTimeout(() => r3.removeChild(n3), 0), s3(e4);
            }, r3.append(n3);
          }(r2, e2.callbackName, t2) : fetch(r2, n2).then((e3) => e3.json()).then(t2).catch(s2);
        });
      }
      function X(e2) {
        return Object.keys(e2).reduce((t2, s2) => (t2.push("object" == typeof e2[s2] ? X(e2[s2]) : `${encodeURIComponent(s2)}=${encodeURIComponent(e2[s2])}`), t2), []).join("&");
      }
      J.glass = `
  <div class="${K.glass.control} ${K.olControl}">
    <button type="button" id="${q.buttonControlId}" class="${K.glass.button}"></button>
    <input type="text" id="${q.inputQueryId}" class="${K.glass.input}" autocomplete="off" placeholder="Search ...">
    <a id="${q.inputSearchId}" class="${K.glass.search} ${K.hidden}"></a>
  </div>
  <ul class="${K.glass.result}"></ul>
`, J.input = `
  <div class="${K.inputText.control}">
    <label type="button" id="${q.inputSearchId}" class="${K.inputText.label}"></label>
    <input type="text" id="${q.inputQueryId}" class="${K.inputText.input}" autocomplete="off" placeholder="Search ...">
    <span class="${K.inputText.icon}"></span>
    <button type="button" id="${q.inputSearchId}" class="${K.inputText.search} ${K.hidden}"></button>
  </div>
  <ul class="${K.inputText.result}"></ul>
`;
      class Y {
        constructor() {
          this.settings = { url: "https://photon.komoot.io/api/", params: { q: "", limit: 10, lang: "en" }, langs: ["de", "it", "fr", "en"] };
        }
        getParameters(e2) {
          return e2.lang = e2.lang.toLowerCase(), { url: this.settings.url, params: { q: e2.query, limit: e2.limit || this.settings.params.limit, lang: this.settings.langs.includes(e2.lang) ? e2.lang : this.settings.params.lang } };
        }
        handleResponse(e2) {
          return 0 === e2.features.length ? [] : e2.features.map((e3) => ({ lon: e3.geometry.coordinates[0], lat: e3.geometry.coordinates[1], address: { name: e3.properties.name, postcode: e3.properties.postcode, city: e3.properties.city, state: e3.properties.state, country: e3.properties.country }, original: { formatted: e3.properties.name, details: e3.properties } }));
        }
      }
      class Z {
        constructor(e2) {
          this.settings = { url: "https://nominatim.openstreetmap.org/search", ...e2, params: { q: "", format: "json", addressdetails: 1, limit: 10, countrycodes: "", viewbox: "", "accept-language": "en-US" } };
        }
        getParameters(e2) {
          return { url: this.settings.url, params: { q: e2.query, format: this.settings.params.format, addressdetails: this.settings.params.addressdetails, limit: e2.limit || this.settings.params.limit, countrycodes: e2.countrycodes || this.settings.params.countrycodes, viewbox: e2.viewbox || this.settings.params.viewbox, "accept-language": e2.lang || this.settings.params["accept-language"] } };
        }
        handleResponse(e2) {
          return 0 === e2.length ? [] : e2.map((e3) => ({ lon: e3.lon, lat: e3.lat, bbox: e3.boundingbox, address: { name: e3.display_name, road: e3.address.road || "", houseNumber: e3.address.house_number || "", postcode: e3.address.postcode, city: e3.address.city || e3.address.town, state: e3.address.state, country: e3.address.country }, original: { formatted: e3.display_name, details: e3.address } }));
        }
      }
      class ee {
        constructor() {
          this.settings = { url: "https://open.mapquestapi.com/nominatim/v1/search.php", params: { q: "", key: "", format: "json", addressdetails: 1, limit: 10, countrycodes: "", "accept-language": "en-US" } };
        }
        getParameters(e2) {
          return { url: this.settings.url, params: { q: e2.query, key: e2.key, format: "json", addressdetails: 1, limit: e2.limit || this.settings.params.limit, countrycodes: e2.countrycodes || this.settings.params.countrycodes, "accept-language": e2.lang || this.settings.params["accept-language"] } };
        }
        handleResponse(e2) {
          return 0 === e2.length ? [] : e2.map((e3) => ({ lon: e3.lon, lat: e3.lat, address: { name: e3.address.neighbourhood || "", road: e3.address.road || "", postcode: e3.address.postcode, city: e3.address.city || e3.address.town, state: e3.address.state, country: e3.address.country }, original: { formatted: e3.display_name, details: e3.address } }));
        }
      }
      class te {
        constructor() {
          this.settings = { url: "https://dev.virtualearth.net/REST/v1/Locations", callbackName: "jsonp", params: { query: "", key: "", includeNeighborhood: 0, maxResults: 10 } };
        }
        getParameters(e2) {
          return { url: this.settings.url, callbackName: this.settings.callbackName, params: { query: e2.query, key: e2.key, includeNeighborhood: e2.includeNeighborhood || this.settings.params.includeNeighborhood, maxResults: e2.maxResults || this.settings.params.maxResults } };
        }
        handleResponse(e2) {
          const { resources: t2 } = e2.resourceSets[0];
          return 0 === t2.length ? [] : t2.map((e3) => ({ lon: e3.point.coordinates[1], lat: e3.point.coordinates[0], address: { name: e3.name }, original: { formatted: e3.address.formattedAddress, details: e3.address } }));
        }
      }
      class se {
        constructor() {
          this.settings = { url: "https://api.opencagedata.com/geocode/v1/json?", params: { q: "", key: "", limit: 10, countrycode: "", pretty: 1, no_annotations: 1 } };
        }
        getParameters(e2) {
          return { url: this.settings.url, params: { q: e2.query, key: e2.key, limit: e2.limit || this.settings.params.limit, countrycode: e2.countrycodes || this.settings.params.countrycodes } };
        }
        handleResponse(e2) {
          return 0 === e2.results.length ? [] : e2.results.map((e3) => ({ lon: e3.geometry.lng, lat: e3.geometry.lat, address: { name: e3.components.house_number || "", road: e3.components.road || "", postcode: e3.components.postcode, city: e3.components.city || e3.components.town, state: e3.components.state, country: e3.components.country }, original: { formatted: e3.formatted, details: e3.components } }));
        }
      }
      const re = q.cssClasses;
      class ne {
        constructor(e2, t2) {
          this.Base = e2, this.layerName = M("geocoder-layer-"), this.layer = new h.default({ name: this.layerName, source: new m.default(), displayInLayerSwitcher: false }), this.options = e2.options, this.options.provider = "string" == typeof this.options.provider ? this.options.provider.toLowerCase() : this.options.provider, this.provider = this.newProvider(), this.els = t2, this.lastQuery = "", this.container = this.els.container, this.registeredListeners = { mapClick: false }, this.setListeners();
        }
        setListeners() {
          const e2 = (e3) => {
            e3.stopPropagation(), Q(this.els.control, re.glass.expanded) ? this.collapse() : this.expand();
          };
          this.els.input.addEventListener("keypress", (e3) => {
            const t2 = e3.target.value.trim();
            (e3.key ? "Enter" === e3.key : e3.which ? 13 === e3.which : !!e3.keyCode && 13 === e3.keyCode) && (e3.preventDefault(), this.query(t2));
          }, false), this.els.input.addEventListener("click", (e3) => e3.stopPropagation(), false), this.els.input.addEventListener("input", (e3) => {
            0 !== e3.target.value.trim().length ? V(this.els.search, re.hidden) : D(this.els.search, re.hidden);
          }, false), this.els.search.addEventListener("click", () => {
            this.els.input.focus(), this.query(this.els.input.value);
          }, false), this.options.targetType === E && this.els.button.addEventListener("click", e2, false);
        }
        query(e2) {
          this.provider || (this.provider = this.newProvider());
          const t2 = this.provider.getParameters({ query: e2, key: this.options.key, lang: this.options.lang, countrycodes: this.options.countrycodes, viewbox: this.options.viewbox, limit: this.options.limit });
          if (this.lastQuery === e2 && this.els.result.firstChild)
            return;
          this.lastQuery = e2, this.clearResults(), D(this.els.search, re.spin);
          const s2 = { url: t2.url, data: t2.params };
          t2.callbackName && (s2.jsonp = true, s2.callbackName = t2.callbackName), W(s2).then((e3) => {
            this.options.debug && console.info(e3), V(this.els.search, re.spin);
            const t3 = this.provider.handleResponse(e3);
            t3 && (this.createList(t3), this.listenMapClick());
          }).catch(() => {
            V(this.els.search, re.spin);
            const e3 = U("li", "<h5>Error! No internet connection?</h5>");
            this.els.result.append(e3);
          });
        }
        createList(e2) {
          const t2 = this.els.result;
          e2.forEach((s2) => {
            let r2;
            if (this.options.provider === I)
              r2 = `<span class="${re.road}">${s2.address.name}</span>`;
            else
              r2 = this.addressTemplate(s2.address);
            if (1 == e2.length)
              this.chosen(s2, r2, s2.address, s2.original);
            else {
              const e3 = U("li", `<a href="#">${r2}</a>`);
              e3.addEventListener("click", (e4) => {
                e4.preventDefault(), this.chosen(s2, r2, s2.address, s2.original);
              }, false), t2.append(e3);
            }
          });
        }
        chosen(e2, t2, s2, r2) {
          const n2 = this.Base.getMap(), o2 = [Number.parseFloat(e2.lon), Number.parseFloat(e2.lat)], a2 = n2.getView().getProjection(), i2 = f.transform(o2, "EPSG:4326", a2);
          let { bbox: l2 } = e2;
          l2 && (l2 = f.transformExtent([parseFloat(l2[2]), parseFloat(l2[0]), parseFloat(l2[3]), parseFloat(l2[1])], "EPSG:4326", a2));
          const c2 = { formatted: t2, details: s2, original: r2 };
          if (false === this.options.keepOpen && this.clearResults(true), true === this.options.preventDefault || true === this.options.preventMarker)
            this.Base.dispatchEvent({ type: L, address: c2, coordinate: i2, bbox: l2, place: e2 });
          else {
            const t3 = this.createFeature(i2, c2);
            this.Base.dispatchEvent({ type: L, address: c2, feature: t3, coordinate: i2, bbox: l2, place: e2 });
          }
          true !== this.options.preventDefault && true !== this.options.preventPanning && (l2 ? n2.getView().fit(l2, { duration: 500 }) : n2.getView().animate({ center: i2, resolution: this.options.defaultFlyResolution, duration: 500 }));
        }
        createFeature(e2) {
          const t2 = new y.default(new g.default(e2));
          return this.addLayer(), t2.setStyle(this.options.featureStyle), t2.setId(M("geocoder-ft-")), this.getSource().addFeature(t2), t2;
        }
        addressTemplate(e2) {
          const t2 = [];
          return e2.name && t2.push(['<span class="', re.road, '">{name}</span>'].join("")), (e2.road || e2.building || e2.house_number) && t2.push(['<span class="', re.road, '">{building} {road} {house_number}</span>'].join("")), (e2.city || e2.town || e2.village) && t2.push(['<span class="', re.city, '">{postcode} {city} {town} {village}</span>'].join("")), (e2.state || e2.country) && t2.push(['<span class="', re.country, '">{state} {country}</span>'].join("")), B(t2.join("<br>"), e2);
        }
        newProvider() {
          switch (this.options.provider) {
            case I:
              return new Z(this.options);
            case N:
              return new ee();
            case P:
              return new Y();
            case A:
              return new te();
            case R:
              return new se();
            default:
              return this.options.provider;
          }
        }
        expand() {
          V(this.els.input, re.spin), D(this.els.control, re.glass.expanded), window.setTimeout(() => this.els.input.focus(), 100), this.listenMapClick();
        }
        collapse() {
          this.els.input.value = "", this.els.input.blur(), D(this.els.search, re.hidden), V(this.els.control, re.glass.expanded), this.clearResults();
        }
        listenMapClick() {
          if (this.registeredListeners.mapClick)
            return;
          const e2 = this, t2 = this.Base.getMap().getTargetElement();
          this.registeredListeners.mapClick = true, t2.addEventListener("click", { handleEvent(s2) {
            e2.clearResults(true), t2.removeEventListener(s2.type, this, false), e2.registeredListeners.mapClick = false;
          } }, false);
        }
        clearResults(e2) {
          e2 && this.options.targetType === E ? this.collapse() : function(e3) {
            for (; e3.firstChild; )
              e3.firstChild.remove();
          }(this.els.result);
        }
        getSource() {
          return this.layer.getSource();
        }
        addLayer() {
          let e2 = false;
          const t2 = this.Base.getMap();
          t2.getLayers().forEach((t3) => {
            t3 === this.layer && (e2 = true);
          }), e2 || t2.addLayer(this.layer);
        }
      }
      class oe extends d.default {
        constructor(e2 = C, t2) {
          _("string" == typeof e2, "@param `type` should be string!"), _(e2 === C || e2 === j, `@param 'type' should be '${C}'
      or '${j}'!`);
          const s2 = { ...F, featureStyle: [new u.default({ image: new p.default({ scale: 0.7, src: "//cdn.rawgit.com/jonataswalker/map-utils/master/images/marker.png" }) })], ...t2 };
          let r2, n2;
          const o2 = new J(s2);
          if (e2 === C && (r2 = o2.els.container), super({ element: r2, ...s2 }), !(this instanceof oe))
            return new oe();
          this.options = s2, this.container = r2, e2 === C && (n2 = new ne(this, o2.els), this.layer = n2.layer);
        }
        getLayer() {
          return this.layer;
        }
        getSource() {
          return this.getLayer().getSource();
        }
        setProvider(e2) {
          this.options.provider = e2;
        }
        setProviderKey(e2) {
          this.options.key = e2;
        }
      }
      return oe;
    });
  }
});

// node_modules/ol/renderer/Map.js
init_Disposable();
init_functions();
init_util();
init_transform();
init_extent();
init_IconImageCache();
init_Layer();
init_coordinate();
var MapRenderer = class extends Disposable_default {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(map) {
    super();
    this.map_ = map;
  }
  /**
   * @abstract
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(type, frameState) {
    abstract();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @protected
   */
  calculateMatrices2D(frameState) {
    const viewState = frameState.viewState;
    const coordinateToPixelTransform = frameState.coordinateToPixelTransform;
    const pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
    compose(
      coordinateToPixelTransform,
      frameState.size[0] / 2,
      frameState.size[1] / 2,
      1 / viewState.resolution,
      -1 / viewState.resolution,
      -viewState.rotation,
      -viewState.center[0],
      -viewState.center[1]
    );
    makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
   * @param {S} thisArg Value to use as `this` when executing `callback`.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
   * @return {T|undefined} Callback result.
   * @template S,T,U
   */
  forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
    let result;
    const viewState = frameState.viewState;
    function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {
      return callback.call(thisArg, feature, managed ? layer : null, geometry);
    }
    const projection = viewState.projection;
    const translatedCoordinate = wrapX2(coordinate.slice(), projection);
    const offsets = [[0, 0]];
    if (projection.canWrapX() && checkWrapped) {
      const projectionExtent = projection.getExtent();
      const worldWidth = getWidth(projectionExtent);
      offsets.push([-worldWidth, 0], [worldWidth, 0]);
    }
    const layerStates = frameState.layerStatesArray;
    const numLayers = layerStates.length;
    const matches = (
      /** @type {Array<HitMatch<T>>} */
      []
    );
    const tmpCoord = [];
    for (let i = 0; i < offsets.length; i++) {
      for (let j = numLayers - 1; j >= 0; --j) {
        const layerState = layerStates[j];
        const layer = layerState.layer;
        if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter.call(thisArg2, layer)) {
          const layerRenderer = layer.getRenderer();
          const source = layer.getSource();
          if (layerRenderer && source) {
            const coordinates2 = source.getWrapX() ? translatedCoordinate : coordinate;
            const callback2 = forEachFeatureAtCoordinate.bind(
              null,
              layerState.managed
            );
            tmpCoord[0] = coordinates2[0] + offsets[i][0];
            tmpCoord[1] = coordinates2[1] + offsets[i][1];
            result = layerRenderer.forEachFeatureAtCoordinate(
              tmpCoord,
              frameState,
              hitTolerance,
              callback2,
              matches
            );
          }
          if (result) {
            return result;
          }
        }
      }
    }
    if (matches.length === 0) {
      return void 0;
    }
    const order = 1 / matches.length;
    matches.forEach((m, i) => m.distanceSq += i * order);
    matches.sort((a, b) => a.distanceSq - b.distanceSq);
    matches.some((m) => {
      return result = m.callback(m.feature, m.layer, m.geometry);
    });
    return result;
  }
  /**
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {import("../Map.js").FrameState} frameState FrameState.
   * @param {number} hitTolerance Hit tolerance in pixels.
   * @param {boolean} checkWrapped Check for wrapped geometries.
   * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
   *     function, only layers which are visible and for which this function
   *     returns `true` will be tested for features.  By default, all visible
   *     layers will be tested.
   * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
   * @return {boolean} Is there a feature at the given coordinate?
   * @template U
   */
  hasFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
    const hasFeature = this.forEachFeatureAtCoordinate(
      coordinate,
      frameState,
      hitTolerance,
      checkWrapped,
      TRUE,
      this,
      layerFilter,
      thisArg
    );
    return hasFeature !== void 0;
  }
  /**
   * @return {import("../Map.js").default} Map.
   */
  getMap() {
    return this.map_;
  }
  /**
   * Render.
   * @abstract
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(frameState) {
    abstract();
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  flushDeclutterItems(frameState) {
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @protected
   */
  scheduleExpireIconCache(frameState) {
    if (shared.canExpireCache()) {
      frameState.postRenderFunctions.push(expireIconCache);
    }
  }
};
function expireIconCache(map, frameState) {
  shared.expire();
}
var Map_default = MapRenderer;

// node_modules/ol/renderer/Composite.js
init_ObjectEventType();
init_Event2();
init_EventType2();
init_css();
init_canvas();
init_Layer();
init_events();
init_dom();
var CompositeMapRenderer = class extends Map_default {
  /**
   * @param {import("../Map.js").default} map Map.
   */
  constructor(map) {
    super(map);
    this.fontChangeListenerKey_ = listen(
      checkedFonts,
      ObjectEventType_default.PROPERTYCHANGE,
      map.redrawText.bind(map)
    );
    this.element_ = document.createElement("div");
    const style = this.element_.style;
    style.position = "absolute";
    style.width = "100%";
    style.height = "100%";
    style.zIndex = "0";
    this.element_.className = CLASS_UNSELECTABLE + " ol-layers";
    const container = map.getViewport();
    container.insertBefore(this.element_, container.firstChild || null);
    this.children_ = [];
    this.renderedVisible_ = true;
    this.declutterLayers_ = [];
  }
  /**
   * @param {import("../render/EventType.js").default} type Event type.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  dispatchRenderEvent(type, frameState) {
    const map = this.getMap();
    if (map.hasListener(type)) {
      const event = new Event_default2(type, void 0, frameState);
      map.dispatchEvent(event);
    }
  }
  disposeInternal() {
    unlistenByKey(this.fontChangeListenerKey_);
    this.element_.parentNode.removeChild(this.element_);
    super.disposeInternal();
  }
  /**
   * Render.
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  renderFrame(frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element_.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    this.calculateMatrices2D(frameState);
    this.dispatchRenderEvent(EventType_default2.PRECOMPOSE, frameState);
    const layerStatesArray = frameState.layerStatesArray.sort(function(a, b) {
      return a.zIndex - b.zIndex;
    });
    const viewState = frameState.viewState;
    this.children_.length = 0;
    const declutterLayers = this.declutterLayers_;
    declutterLayers.length = 0;
    let previousElement = null;
    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      const layerState = layerStatesArray[i];
      frameState.layerIndex = i;
      const layer = layerState.layer;
      const sourceState = layer.getSourceState();
      if (!inView(layerState, viewState) || sourceState != "ready" && sourceState != "undefined") {
        layer.unrender();
        continue;
      }
      const element = layer.render(frameState, previousElement);
      if (!element) {
        continue;
      }
      if (element !== previousElement) {
        this.children_.push(element);
        previousElement = element;
      }
      if ("getDeclutter" in layer) {
        declutterLayers.push(
          /** @type {import("../layer/BaseVector.js").default} */
          layer
        );
      }
    }
    this.flushDeclutterItems(frameState);
    replaceChildren(this.element_, this.children_);
    this.dispatchRenderEvent(EventType_default2.POSTCOMPOSE, frameState);
    if (!this.renderedVisible_) {
      this.element_.style.display = "";
      this.renderedVisible_ = true;
    }
    this.scheduleExpireIconCache(frameState);
  }
  /**
   * @param {import("../Map.js").FrameState} frameState Frame state.
   */
  flushDeclutterItems(frameState) {
    const layers = this.declutterLayers_;
    for (let i = layers.length - 1; i >= 0; --i) {
      layers[i].renderDeclutter(frameState);
    }
    layers.length = 0;
  }
};
var Composite_default = CompositeMapRenderer;

// node_modules/ol/layer/Group.js
init_Base();
init_Collection();
init_CollectionEventType();
init_Event();
init_EventType();
init_ObjectEventType();
init_asserts();
init_obj();
init_extent();
init_util();
init_events();
var GroupEvent = class extends Event_default {
  /**
   * @param {EventType} type The event type.
   * @param {BaseLayer} layer The layer.
   */
  constructor(type, layer) {
    super(type);
    this.layer = layer;
  }
};
var Property2 = {
  LAYERS: "layers"
};
var LayerGroup = class _LayerGroup extends Base_default {
  /**
   * @param {Options} [options] Layer options.
   */
  constructor(options) {
    options = options || {};
    const baseOptions = (
      /** @type {Options} */
      Object.assign({}, options)
    );
    delete baseOptions.layers;
    let layers = options.layers;
    super(baseOptions);
    this.on;
    this.once;
    this.un;
    this.layersListenerKeys_ = [];
    this.listenerKeys_ = {};
    this.addChangeListener(Property2.LAYERS, this.handleLayersChanged_);
    if (layers) {
      if (Array.isArray(layers)) {
        layers = new Collection_default(layers.slice(), { unique: true });
      } else {
        assert(
          typeof /** @type {?} */
          layers.getArray === "function",
          "Expected `layers` to be an array or a `Collection`"
        );
      }
    } else {
      layers = new Collection_default(void 0, { unique: true });
    }
    this.setLayers(layers);
  }
  /**
   * @private
   */
  handleLayerChange_() {
    this.changed();
  }
  /**
   * @private
   */
  handleLayersChanged_() {
    this.layersListenerKeys_.forEach(unlistenByKey);
    this.layersListenerKeys_.length = 0;
    const layers = this.getLayers();
    this.layersListenerKeys_.push(
      listen(layers, CollectionEventType_default.ADD, this.handleLayersAdd_, this),
      listen(layers, CollectionEventType_default.REMOVE, this.handleLayersRemove_, this)
    );
    for (const id in this.listenerKeys_) {
      this.listenerKeys_[id].forEach(unlistenByKey);
    }
    clear(this.listenerKeys_);
    const layersArray = layers.getArray();
    for (let i = 0, ii = layersArray.length; i < ii; i++) {
      const layer = layersArray[i];
      this.registerLayerListeners_(layer);
      this.dispatchEvent(new GroupEvent("addlayer", layer));
    }
    this.changed();
  }
  /**
   * @param {BaseLayer} layer The layer.
   */
  registerLayerListeners_(layer) {
    const listenerKeys = [
      listen(
        layer,
        ObjectEventType_default.PROPERTYCHANGE,
        this.handleLayerChange_,
        this
      ),
      listen(layer, EventType_default.CHANGE, this.handleLayerChange_, this)
    ];
    if (layer instanceof _LayerGroup) {
      listenerKeys.push(
        listen(layer, "addlayer", this.handleLayerGroupAdd_, this),
        listen(layer, "removelayer", this.handleLayerGroupRemove_, this)
      );
    }
    this.listenerKeys_[getUid(layer)] = listenerKeys;
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupAdd_(event) {
    this.dispatchEvent(new GroupEvent("addlayer", event.layer));
  }
  /**
   * @param {GroupEvent} event The layer group event.
   */
  handleLayerGroupRemove_(event) {
    this.dispatchEvent(new GroupEvent("removelayer", event.layer));
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersAdd_(collectionEvent) {
    const layer = collectionEvent.element;
    this.registerLayerListeners_(layer);
    this.dispatchEvent(new GroupEvent("addlayer", layer));
    this.changed();
  }
  /**
   * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
   * @private
   */
  handleLayersRemove_(collectionEvent) {
    const layer = collectionEvent.element;
    const key = getUid(layer);
    this.listenerKeys_[key].forEach(unlistenByKey);
    delete this.listenerKeys_[key];
    this.dispatchEvent(new GroupEvent("removelayer", layer));
    this.changed();
  }
  /**
   * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @return {!Collection<import("./Base.js").default>} Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  getLayers() {
    return (
      /** @type {!Collection<import("./Base.js").default>} */
      this.get(Property2.LAYERS)
    );
  }
  /**
   * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
   * in this group.
   * @param {!Collection<import("./Base.js").default>} layers Collection of
   *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
   * @observable
   * @api
   */
  setLayers(layers) {
    const collection = this.getLayers();
    if (collection) {
      const currentLayers = collection.getArray();
      for (let i = 0, ii = currentLayers.length; i < ii; ++i) {
        this.dispatchEvent(new GroupEvent("removelayer", currentLayers[i]));
      }
    }
    this.set(Property2.LAYERS, layers);
  }
  /**
   * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
   * @return {Array<import("./Layer.js").default>} Array of layers.
   */
  getLayersArray(array) {
    array = array !== void 0 ? array : [];
    this.getLayers().forEach(function(layer) {
      layer.getLayersArray(array);
    });
    return array;
  }
  /**
   * Get the layer states list and use this groups z-index as the default
   * for all layers in this and nested groups, if it is unset at this point.
   * If dest is not provided and this group's z-index is undefined
   * 0 is used a the default z-index.
   * @param {Array<import("./Layer.js").State>} [dest] Optional list
   * of layer states (to be modified in place).
   * @return {Array<import("./Layer.js").State>} List of layer states.
   */
  getLayerStatesArray(dest) {
    const states = dest !== void 0 ? dest : [];
    const pos = states.length;
    this.getLayers().forEach(function(layer) {
      layer.getLayerStatesArray(states);
    });
    const ownLayerState = this.getLayerState();
    let defaultZIndex = ownLayerState.zIndex;
    if (!dest && ownLayerState.zIndex === void 0) {
      defaultZIndex = 0;
    }
    for (let i = pos, ii = states.length; i < ii; i++) {
      const layerState = states[i];
      layerState.opacity *= ownLayerState.opacity;
      layerState.visible = layerState.visible && ownLayerState.visible;
      layerState.maxResolution = Math.min(
        layerState.maxResolution,
        ownLayerState.maxResolution
      );
      layerState.minResolution = Math.max(
        layerState.minResolution,
        ownLayerState.minResolution
      );
      layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
      layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
      if (ownLayerState.extent !== void 0) {
        if (layerState.extent !== void 0) {
          layerState.extent = getIntersection(
            layerState.extent,
            ownLayerState.extent
          );
        } else {
          layerState.extent = ownLayerState.extent;
        }
      }
      if (layerState.zIndex === void 0) {
        layerState.zIndex = defaultZIndex;
      }
    }
    return states;
  }
  /**
   * @return {import("../source/Source.js").State} Source state.
   */
  getSourceState() {
    return "ready";
  }
};
var Group_default = LayerGroup;

// node_modules/ol/MapEvent.js
init_Event();
var MapEvent = class extends Event_default {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {?import("./Map.js").FrameState} [frameState] Frame state.
   */
  constructor(type, map, frameState) {
    super(type);
    this.map = map;
    this.frameState = frameState !== void 0 ? frameState : null;
  }
};
var MapEvent_default = MapEvent;

// node_modules/ol/MapBrowserEvent.js
var MapBrowserEvent = class extends MapEvent_default {
  /**
   * @param {string} type Event type.
   * @param {import("./Map.js").default} map Map.
   * @param {EVENT} originalEvent Original event.
   * @param {boolean} [dragging] Is the map currently being dragged?
   * @param {import("./Map.js").FrameState} [frameState] Frame state.
   * @param {Array<PointerEvent>} [activePointers] Active pointers.
   */
  constructor(type, map, originalEvent, dragging, frameState, activePointers) {
    super(type, map, frameState);
    this.originalEvent = originalEvent;
    this.pixel_ = null;
    this.coordinate_ = null;
    this.dragging = dragging !== void 0 ? dragging : false;
    this.activePointers = activePointers;
  }
  /**
   * The map pixel relative to the viewport corresponding to the original event.
   * @type {import("./pixel.js").Pixel}
   * @api
   */
  get pixel() {
    if (!this.pixel_) {
      this.pixel_ = this.map.getEventPixel(this.originalEvent);
    }
    return this.pixel_;
  }
  set pixel(pixel) {
    this.pixel_ = pixel;
  }
  /**
   * The coordinate corresponding to the original browser event.  This will be in the user
   * projection if one is set.  Otherwise it will be in the view projection.
   * @type {import("./coordinate.js").Coordinate}
   * @api
   */
  get coordinate() {
    if (!this.coordinate_) {
      this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
    }
    return this.coordinate_;
  }
  set coordinate(coordinate) {
    this.coordinate_ = coordinate;
  }
  /**
   * Prevents the default browser action.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
   * @api
   */
  preventDefault() {
    super.preventDefault();
    if ("preventDefault" in this.originalEvent) {
      this.originalEvent.preventDefault();
    }
  }
  /**
   * Prevents further propagation of the current event.
   * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
   * @api
   */
  stopPropagation() {
    super.stopPropagation();
    if ("stopPropagation" in this.originalEvent) {
      this.originalEvent.stopPropagation();
    }
  }
};
var MapBrowserEvent_default = MapBrowserEvent;

// node_modules/ol/MapBrowserEventType.js
init_EventType();
var MapBrowserEventType_default = {
  /**
   * A true single click with no dragging and no double click. Note that this
   * event is delayed by 250 ms to ensure that it is not a double click.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
   * @api
   */
  SINGLECLICK: "singleclick",
  /**
   * A click with no dragging. A double click will fire two of this.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
   * @api
   */
  CLICK: EventType_default.CLICK,
  /**
   * A true double click, with no dragging.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
   * @api
   */
  DBLCLICK: EventType_default.DBLCLICK,
  /**
   * Triggered when a pointer is dragged.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
   * @api
   */
  POINTERDRAG: "pointerdrag",
  /**
   * Triggered when a pointer is moved. Note that on touch devices this is
   * triggered when the map is panned, so is not the same as mousemove.
   * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
   * @api
   */
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};

// node_modules/ol/pointer/EventType.js
var EventType_default3 = {
  POINTERMOVE: "pointermove",
  POINTERDOWN: "pointerdown",
  POINTERUP: "pointerup",
  POINTEROVER: "pointerover",
  POINTEROUT: "pointerout",
  POINTERENTER: "pointerenter",
  POINTERLEAVE: "pointerleave",
  POINTERCANCEL: "pointercancel"
};

// node_modules/ol/MapBrowserEventHandler.js
init_EventType();
init_Target();
init_has();
init_events();
var MapBrowserEventHandler = class extends Target_default {
  /**
   * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
   * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
   */
  constructor(map, moveTolerance) {
    super(map);
    this.map_ = map;
    this.clickTimeoutId_;
    this.emulateClicks_ = false;
    this.dragging_ = false;
    this.dragListenerKeys_ = [];
    this.moveTolerance_ = moveTolerance === void 0 ? 1 : moveTolerance;
    this.down_ = null;
    const element = this.map_.getViewport();
    this.activePointers_ = [];
    this.trackedTouches_ = {};
    this.element_ = element;
    this.pointerdownListenerKey_ = listen(
      element,
      EventType_default3.POINTERDOWN,
      this.handlePointerDown_,
      this
    );
    this.originalPointerMoveEvent_;
    this.relayedListenerKey_ = listen(
      element,
      EventType_default3.POINTERMOVE,
      this.relayMoveEvent_,
      this
    );
    this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this);
    this.element_.addEventListener(
      EventType_default.TOUCHMOVE,
      this.boundHandleTouchMove_,
      PASSIVE_EVENT_LISTENERS ? { passive: false } : false
    );
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  emulateClick_(pointerEvent) {
    let newEvent = new MapBrowserEvent_default(
      MapBrowserEventType_default.CLICK,
      this.map_,
      pointerEvent
    );
    this.dispatchEvent(newEvent);
    if (this.clickTimeoutId_ !== void 0) {
      clearTimeout(this.clickTimeoutId_);
      this.clickTimeoutId_ = void 0;
      newEvent = new MapBrowserEvent_default(
        MapBrowserEventType_default.DBLCLICK,
        this.map_,
        pointerEvent
      );
      this.dispatchEvent(newEvent);
    } else {
      this.clickTimeoutId_ = setTimeout(() => {
        this.clickTimeoutId_ = void 0;
        const newEvent2 = new MapBrowserEvent_default(
          MapBrowserEventType_default.SINGLECLICK,
          this.map_,
          pointerEvent
        );
        this.dispatchEvent(newEvent2);
      }, 250);
    }
  }
  /**
   * Keeps track on how many pointers are currently active.
   *
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  updateActivePointers_(pointerEvent) {
    const event = pointerEvent;
    const id = event.pointerId;
    if (event.type == MapBrowserEventType_default.POINTERUP || event.type == MapBrowserEventType_default.POINTERCANCEL) {
      delete this.trackedTouches_[id];
      for (const pointerId in this.trackedTouches_) {
        if (this.trackedTouches_[pointerId].target !== event.target) {
          delete this.trackedTouches_[pointerId];
          break;
        }
      }
    } else if (event.type == MapBrowserEventType_default.POINTERDOWN || event.type == MapBrowserEventType_default.POINTERMOVE) {
      this.trackedTouches_[id] = event;
    }
    this.activePointers_ = Object.values(this.trackedTouches_);
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerUp_(pointerEvent) {
    this.updateActivePointers_(pointerEvent);
    const newEvent = new MapBrowserEvent_default(
      MapBrowserEventType_default.POINTERUP,
      this.map_,
      pointerEvent,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(newEvent);
    if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
      this.emulateClick_(this.down_);
    }
    if (this.activePointers_.length === 0) {
      this.dragListenerKeys_.forEach(unlistenByKey);
      this.dragListenerKeys_.length = 0;
      this.dragging_ = false;
      this.down_ = null;
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} If the left mouse button was pressed.
   * @private
   */
  isMouseActionButton_(pointerEvent) {
    return pointerEvent.button === 0;
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerDown_(pointerEvent) {
    this.emulateClicks_ = this.activePointers_.length === 0;
    this.updateActivePointers_(pointerEvent);
    const newEvent = new MapBrowserEvent_default(
      MapBrowserEventType_default.POINTERDOWN,
      this.map_,
      pointerEvent,
      void 0,
      void 0,
      this.activePointers_
    );
    this.dispatchEvent(newEvent);
    this.down_ = new PointerEvent(pointerEvent.type, pointerEvent);
    Object.defineProperty(this.down_, "target", {
      writable: false,
      value: pointerEvent.target
    });
    if (this.dragListenerKeys_.length === 0) {
      const doc = this.map_.getOwnerDocument();
      this.dragListenerKeys_.push(
        listen(
          doc,
          MapBrowserEventType_default.POINTERMOVE,
          this.handlePointerMove_,
          this
        ),
        listen(doc, MapBrowserEventType_default.POINTERUP, this.handlePointerUp_, this),
        /* Note that the listener for `pointercancel is set up on
         * `pointerEventHandler_` and not `documentPointerEventHandler_` like
         * the `pointerup` and `pointermove` listeners.
         *
         * The reason for this is the following: `TouchSource.vacuumTouches_()`
         * issues `pointercancel` events, when there was no `touchend` for a
         * `touchstart`. Now, let's say a first `touchstart` is registered on
         * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
         * But `documentPointerEventHandler_` doesn't know about the first
         * `touchstart`. If there is no `touchend` for the `touchstart`, we can
         * only receive a `touchcancel` from `pointerEventHandler_`, because it is
         * only registered there.
         */
        listen(
          this.element_,
          MapBrowserEventType_default.POINTERCANCEL,
          this.handlePointerUp_,
          this
        )
      );
      if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {
        this.dragListenerKeys_.push(
          listen(
            this.element_.getRootNode(),
            MapBrowserEventType_default.POINTERUP,
            this.handlePointerUp_,
            this
          )
        );
      }
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  handlePointerMove_(pointerEvent) {
    if (this.isMoving_(pointerEvent)) {
      this.updateActivePointers_(pointerEvent);
      this.dragging_ = true;
      const newEvent = new MapBrowserEvent_default(
        MapBrowserEventType_default.POINTERDRAG,
        this.map_,
        pointerEvent,
        this.dragging_,
        void 0,
        this.activePointers_
      );
      this.dispatchEvent(newEvent);
    }
  }
  /**
   * Wrap and relay a pointermove event.
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @private
   */
  relayMoveEvent_(pointerEvent) {
    this.originalPointerMoveEvent_ = pointerEvent;
    const dragging = !!(this.down_ && this.isMoving_(pointerEvent));
    this.dispatchEvent(
      new MapBrowserEvent_default(
        MapBrowserEventType_default.POINTERMOVE,
        this.map_,
        pointerEvent,
        dragging
      )
    );
  }
  /**
   * Flexible handling of a `touch-action: none` css equivalent: because calling
   * `preventDefault()` on a `pointermove` event does not stop native page scrolling
   * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
   * when an interaction (currently `DragPan` handles the event.
   * @param {TouchEvent} event Event.
   * @private
   */
  handleTouchMove_(event) {
    const originalEvent = this.originalPointerMoveEvent_;
    if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== "boolean" || event.cancelable === true)) {
      event.preventDefault();
    }
  }
  /**
   * @param {PointerEvent} pointerEvent Pointer
   * event.
   * @return {boolean} Is moving.
   * @private
   */
  isMoving_(pointerEvent) {
    return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    if (this.relayedListenerKey_) {
      unlistenByKey(this.relayedListenerKey_);
      this.relayedListenerKey_ = null;
    }
    this.element_.removeEventListener(
      EventType_default.TOUCHMOVE,
      this.boundHandleTouchMove_
    );
    if (this.pointerdownListenerKey_) {
      unlistenByKey(this.pointerdownListenerKey_);
      this.pointerdownListenerKey_ = null;
    }
    this.dragListenerKeys_.forEach(unlistenByKey);
    this.dragListenerKeys_.length = 0;
    this.element_ = null;
    super.disposeInternal();
  }
};
var MapBrowserEventHandler_default = MapBrowserEventHandler;

// node_modules/ol/MapProperty.js
var MapProperty_default = {
  LAYERGROUP: "layergroup",
  SIZE: "size",
  TARGET: "target",
  VIEW: "view"
};

// node_modules/ol/structs/PriorityQueue.js
init_asserts();
init_obj();
var DROP = Infinity;
var PriorityQueue = class {
  /**
   * @param {function(T): number} priorityFunction Priority function.
   * @param {function(T): string} keyFunction Key function.
   */
  constructor(priorityFunction, keyFunction) {
    this.priorityFunction_ = priorityFunction;
    this.keyFunction_ = keyFunction;
    this.elements_ = [];
    this.priorities_ = [];
    this.queuedElements_ = {};
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.elements_.length = 0;
    this.priorities_.length = 0;
    clear(this.queuedElements_);
  }
  /**
   * Remove and return the highest-priority element. O(log N).
   * @return {T} Element.
   */
  dequeue() {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const element = elements[0];
    if (elements.length == 1) {
      elements.length = 0;
      priorities.length = 0;
    } else {
      elements[0] = /** @type {T} */
      elements.pop();
      priorities[0] = /** @type {number} */
      priorities.pop();
      this.siftUp_(0);
    }
    const elementKey = this.keyFunction_(element);
    delete this.queuedElements_[elementKey];
    return element;
  }
  /**
   * Enqueue an element. O(log N).
   * @param {T} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(element) {
    assert(
      !(this.keyFunction_(element) in this.queuedElements_),
      "Tried to enqueue an `element` that was already added to the queue"
    );
    const priority = this.priorityFunction_(element);
    if (priority != DROP) {
      this.elements_.push(element);
      this.priorities_.push(priority);
      this.queuedElements_[this.keyFunction_(element)] = true;
      this.siftDown_(0, this.elements_.length - 1);
      return true;
    }
    return false;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.elements_.length;
  }
  /**
   * Gets the index of the left child of the node at the given index.
   * @param {number} index The index of the node to get the left child for.
   * @return {number} The index of the left child.
   * @private
   */
  getLeftChildIndex_(index) {
    return index * 2 + 1;
  }
  /**
   * Gets the index of the right child of the node at the given index.
   * @param {number} index The index of the node to get the right child for.
   * @return {number} The index of the right child.
   * @private
   */
  getRightChildIndex_(index) {
    return index * 2 + 2;
  }
  /**
   * Gets the index of the parent of the node at the given index.
   * @param {number} index The index of the node to get the parent for.
   * @return {number} The index of the parent.
   * @private
   */
  getParentIndex_(index) {
    return index - 1 >> 1;
  }
  /**
   * Make this a heap. O(N).
   * @private
   */
  heapify_() {
    let i;
    for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
      this.siftUp_(i);
    }
  }
  /**
   * @return {boolean} Is empty.
   */
  isEmpty() {
    return this.elements_.length === 0;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Is key queued.
   */
  isKeyQueued(key) {
    return key in this.queuedElements_;
  }
  /**
   * @param {T} element Element.
   * @return {boolean} Is queued.
   */
  isQueued(element) {
    return this.isKeyQueued(this.keyFunction_(element));
  }
  /**
   * @param {number} index The index of the node to move down.
   * @private
   */
  siftUp_(index) {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const count = elements.length;
    const element = elements[index];
    const priority = priorities[index];
    const startIndex = index;
    while (index < count >> 1) {
      const lIndex = this.getLeftChildIndex_(index);
      const rIndex = this.getRightChildIndex_(index);
      const smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
      elements[index] = elements[smallerChildIndex];
      priorities[index] = priorities[smallerChildIndex];
      index = smallerChildIndex;
    }
    elements[index] = element;
    priorities[index] = priority;
    this.siftDown_(startIndex, index);
  }
  /**
   * @param {number} startIndex The index of the root.
   * @param {number} index The index of the node to move up.
   * @private
   */
  siftDown_(startIndex, index) {
    const elements = this.elements_;
    const priorities = this.priorities_;
    const element = elements[index];
    const priority = priorities[index];
    while (index > startIndex) {
      const parentIndex = this.getParentIndex_(index);
      if (priorities[parentIndex] > priority) {
        elements[index] = elements[parentIndex];
        priorities[index] = priorities[parentIndex];
        index = parentIndex;
      } else {
        break;
      }
    }
    elements[index] = element;
    priorities[index] = priority;
  }
  /**
   * FIXME empty description for jsdoc
   */
  reprioritize() {
    const priorityFunction = this.priorityFunction_;
    const elements = this.elements_;
    const priorities = this.priorities_;
    let index = 0;
    const n = elements.length;
    let element, i, priority;
    for (i = 0; i < n; ++i) {
      element = elements[i];
      priority = priorityFunction(element);
      if (priority == DROP) {
        delete this.queuedElements_[this.keyFunction_(element)];
      } else {
        priorities[index] = priority;
        elements[index++] = element;
      }
    }
    elements.length = index;
    priorities.length = index;
    this.heapify_();
  }
};
var PriorityQueue_default = PriorityQueue;

// node_modules/ol/TileState.js
var TileState_default = {
  IDLE: 0,
  LOADING: 1,
  LOADED: 2,
  /**
   * Indicates that tile loading failed
   * @type {number}
   */
  ERROR: 3,
  EMPTY: 4
};

// node_modules/ol/TileQueue.js
init_EventType();
var TileQueue = class extends PriorityQueue_default {
  /**
   * @param {PriorityFunction} tilePriorityFunction Tile priority function.
   * @param {function(): ?} tileChangeCallback Function called on each tile change event.
   */
  constructor(tilePriorityFunction, tileChangeCallback) {
    super(
      /**
       * @param {Array} element Element.
       * @return {number} Priority.
       */
      function(element) {
        return tilePriorityFunction.apply(null, element);
      },
      /**
       * @param {Array} element Element.
       * @return {string} Key.
       */
      function(element) {
        return (
          /** @type {import("./Tile.js").default} */
          element[0].getKey()
        );
      }
    );
    this.boundHandleTileChange_ = this.handleTileChange.bind(this);
    this.tileChangeCallback_ = tileChangeCallback;
    this.tilesLoading_ = 0;
    this.tilesLoadingKeys_ = {};
  }
  /**
   * @param {Array} element Element.
   * @return {boolean} The element was added to the queue.
   */
  enqueue(element) {
    const added = super.enqueue(element);
    if (added) {
      const tile2 = element[0];
      tile2.addEventListener(EventType_default.CHANGE, this.boundHandleTileChange_);
    }
    return added;
  }
  /**
   * @return {number} Number of tiles loading.
   */
  getTilesLoading() {
    return this.tilesLoading_;
  }
  /**
   * @param {import("./events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(event) {
    const tile2 = (
      /** @type {import("./Tile.js").default} */
      event.target
    );
    const state = tile2.getState();
    if (state === TileState_default.LOADED || state === TileState_default.ERROR || state === TileState_default.EMPTY) {
      if (state !== TileState_default.ERROR) {
        tile2.removeEventListener(EventType_default.CHANGE, this.boundHandleTileChange_);
      }
      const tileKey = tile2.getKey();
      if (tileKey in this.tilesLoadingKeys_) {
        delete this.tilesLoadingKeys_[tileKey];
        --this.tilesLoading_;
      }
      this.tileChangeCallback_();
    }
  }
  /**
   * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
   * @param {number} maxNewLoads Maximum number of new tiles to load.
   */
  loadMoreTiles(maxTotalLoading, maxNewLoads) {
    let newLoads = 0;
    let state, tile2, tileKey;
    while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
      tile2 = /** @type {import("./Tile.js").default} */
      this.dequeue()[0];
      tileKey = tile2.getKey();
      state = tile2.getState();
      if (state === TileState_default.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
        this.tilesLoadingKeys_[tileKey] = true;
        ++this.tilesLoading_;
        ++newLoads;
        tile2.load();
      }
    }
  }
};
var TileQueue_default = TileQueue;
function getTilePriority(frameState, tile2, tileSourceKey, tileCenter, tileResolution) {
  if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
    return DROP;
  }
  if (!frameState.wantedTiles[tileSourceKey][tile2.getKey()]) {
    return DROP;
  }
  const center = frameState.viewState.center;
  const deltaX = tileCenter[0] - center[0];
  const deltaY = tileCenter[1] - center[1];
  return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
}

// node_modules/ol/control/Attribution.js
init_Control();
init_EventType();
init_css();
init_array();
init_dom();
var Attribution = class extends Control_default {
  /**
   * @param {Options} [options] Attribution options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    });
    this.ulElement_ = document.createElement("ul");
    this.collapsed_ = options.collapsed !== void 0 ? options.collapsed : true;
    this.userCollapsed_ = this.collapsed_;
    this.overrideCollapsible_ = options.collapsible !== void 0;
    this.collapsible_ = options.collapsible !== void 0 ? options.collapsible : true;
    if (!this.collapsible_) {
      this.collapsed_ = false;
    }
    const className = options.className !== void 0 ? options.className : "ol-attribution";
    const tipLabel = options.tipLabel !== void 0 ? options.tipLabel : "Attributions";
    const expandClassName = options.expandClassName !== void 0 ? options.expandClassName : className + "-expand";
    const collapseLabel = options.collapseLabel !== void 0 ? options.collapseLabel : "\u203A";
    const collapseClassName = options.collapseClassName !== void 0 ? options.collapseClassName : className + "-collapse";
    if (typeof collapseLabel === "string") {
      this.collapseLabel_ = document.createElement("span");
      this.collapseLabel_.textContent = collapseLabel;
      this.collapseLabel_.className = collapseClassName;
    } else {
      this.collapseLabel_ = collapseLabel;
    }
    const label = options.label !== void 0 ? options.label : "i";
    if (typeof label === "string") {
      this.label_ = document.createElement("span");
      this.label_.textContent = label;
      this.label_.className = expandClassName;
    } else {
      this.label_ = label;
    }
    const activeLabel = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
    this.toggleButton_ = document.createElement("button");
    this.toggleButton_.setAttribute("type", "button");
    this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
    this.toggleButton_.title = tipLabel;
    this.toggleButton_.appendChild(activeLabel);
    this.toggleButton_.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this),
      false
    );
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL + (this.collapsed_ && this.collapsible_ ? " " + CLASS_COLLAPSED : "") + (this.collapsible_ ? "" : " ol-uncollapsible");
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(this.toggleButton_);
    element.appendChild(this.ulElement_);
    this.renderedAttributions_ = [];
    this.renderedVisible_ = true;
  }
  /**
   * Collect a list of visible attributions and set the collapsible state.
   * @param {import("../Map.js").FrameState} frameState Frame state.
   * @return {Array<string>} Attributions.
   * @private
   */
  collectSourceAttributions_(frameState) {
    const visibleAttributions = Array.from(
      new Set(
        this.getMap().getAllLayers().flatMap((layer) => layer.getAttributions(frameState))
      )
    );
    const collapsible = !this.getMap().getAllLayers().some(
      (layer) => layer.getSource() && layer.getSource().getAttributionsCollapsible() === false
    );
    if (!this.overrideCollapsible_) {
      this.setCollapsible(collapsible);
    }
    return visibleAttributions;
  }
  /**
   * @private
   * @param {?import("../Map.js").FrameState} frameState Frame state.
   */
  updateElement_(frameState) {
    if (!frameState) {
      if (this.renderedVisible_) {
        this.element.style.display = "none";
        this.renderedVisible_ = false;
      }
      return;
    }
    const attributions = this.collectSourceAttributions_(frameState);
    const visible = attributions.length > 0;
    if (this.renderedVisible_ != visible) {
      this.element.style.display = visible ? "" : "none";
      this.renderedVisible_ = visible;
    }
    if (equals(attributions, this.renderedAttributions_)) {
      return;
    }
    removeChildren(this.ulElement_);
    for (let i = 0, ii = attributions.length; i < ii; ++i) {
      const element = document.createElement("li");
      element.innerHTML = attributions[i];
      this.ulElement_.appendChild(element);
    }
    this.renderedAttributions_ = attributions;
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(event) {
    event.preventDefault();
    this.handleToggle_();
    this.userCollapsed_ = this.collapsed_;
  }
  /**
   * @private
   */
  handleToggle_() {
    this.element.classList.toggle(CLASS_COLLAPSED);
    if (this.collapsed_) {
      replaceNode(this.collapseLabel_, this.label_);
    } else {
      replaceNode(this.label_, this.collapseLabel_);
    }
    this.collapsed_ = !this.collapsed_;
    this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
  }
  /**
   * Return `true` if the attribution is collapsible, `false` otherwise.
   * @return {boolean} True if the widget is collapsible.
   * @api
   */
  getCollapsible() {
    return this.collapsible_;
  }
  /**
   * Set whether the attribution should be collapsible.
   * @param {boolean} collapsible True if the widget is collapsible.
   * @api
   */
  setCollapsible(collapsible) {
    if (this.collapsible_ === collapsible) {
      return;
    }
    this.collapsible_ = collapsible;
    this.element.classList.toggle("ol-uncollapsible");
    if (this.userCollapsed_) {
      this.handleToggle_();
    }
  }
  /**
   * Collapse or expand the attribution according to the passed parameter. Will
   * not do anything if the attribution isn't collapsible or if the current
   * collapsed state is already the one requested.
   * @param {boolean} collapsed True if the widget is collapsed.
   * @api
   */
  setCollapsed(collapsed) {
    this.userCollapsed_ = collapsed;
    if (!this.collapsible_ || this.collapsed_ === collapsed) {
      return;
    }
    this.handleToggle_();
  }
  /**
   * Return `true` when the attribution is currently collapsed or `false`
   * otherwise.
   * @return {boolean} True if the widget is collapsed.
   * @api
   */
  getCollapsed() {
    return this.collapsed_;
  }
  /**
   * Update the attribution element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(mapEvent) {
    this.updateElement_(mapEvent.frameState);
  }
};
var Attribution_default = Attribution;

// node_modules/ol/control/Rotate.js
init_Control();
init_EventType();
init_css();
init_easing();
var Rotate = class extends Control_default {
  /**
   * @param {Options} [options] Rotate options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      render: options.render,
      target: options.target
    });
    const className = options.className !== void 0 ? options.className : "ol-rotate";
    const label = options.label !== void 0 ? options.label : "\u21E7";
    const compassClassName = options.compassClassName !== void 0 ? options.compassClassName : "ol-compass";
    this.label_ = null;
    if (typeof label === "string") {
      this.label_ = document.createElement("span");
      this.label_.className = compassClassName;
      this.label_.textContent = label;
    } else {
      this.label_ = label;
      this.label_.classList.add(compassClassName);
    }
    const tipLabel = options.tipLabel ? options.tipLabel : "Reset rotation";
    const button = document.createElement("button");
    button.className = className + "-reset";
    button.setAttribute("type", "button");
    button.title = tipLabel;
    button.appendChild(this.label_);
    button.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this),
      false
    );
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(button);
    this.callResetNorth_ = options.resetNorth ? options.resetNorth : void 0;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
    this.autoHide_ = options.autoHide !== void 0 ? options.autoHide : true;
    this.rotation_ = void 0;
    if (this.autoHide_) {
      this.element.classList.add(CLASS_HIDDEN);
    }
  }
  /**
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(event) {
    event.preventDefault();
    if (this.callResetNorth_ !== void 0) {
      this.callResetNorth_();
    } else {
      this.resetNorth_();
    }
  }
  /**
   * @private
   */
  resetNorth_() {
    const map = this.getMap();
    const view = map.getView();
    if (!view) {
      return;
    }
    const rotation = view.getRotation();
    if (rotation !== void 0) {
      if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
        view.animate({
          rotation: 0,
          duration: this.duration_,
          easing: easeOut
        });
      } else {
        view.setRotation(0);
      }
    }
  }
  /**
   * Update the rotate control element.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(mapEvent) {
    const frameState = mapEvent.frameState;
    if (!frameState) {
      return;
    }
    const rotation = frameState.viewState.rotation;
    if (rotation != this.rotation_) {
      const transform2 = "rotate(" + rotation + "rad)";
      if (this.autoHide_) {
        const contains2 = this.element.classList.contains(CLASS_HIDDEN);
        if (!contains2 && rotation === 0) {
          this.element.classList.add(CLASS_HIDDEN);
        } else if (contains2 && rotation !== 0) {
          this.element.classList.remove(CLASS_HIDDEN);
        }
      }
      this.label_.style.transform = transform2;
    }
    this.rotation_ = rotation;
  }
};
var Rotate_default = Rotate;

// node_modules/ol/control/Zoom.js
init_Control();
init_EventType();
init_css();
init_easing();
var Zoom = class extends Control_default {
  /**
   * @param {Options} [options] Zoom options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      element: document.createElement("div"),
      target: options.target
    });
    const className = options.className !== void 0 ? options.className : "ol-zoom";
    const delta = options.delta !== void 0 ? options.delta : 1;
    const zoomInClassName = options.zoomInClassName !== void 0 ? options.zoomInClassName : className + "-in";
    const zoomOutClassName = options.zoomOutClassName !== void 0 ? options.zoomOutClassName : className + "-out";
    const zoomInLabel = options.zoomInLabel !== void 0 ? options.zoomInLabel : "+";
    const zoomOutLabel = options.zoomOutLabel !== void 0 ? options.zoomOutLabel : "\u2013";
    const zoomInTipLabel = options.zoomInTipLabel !== void 0 ? options.zoomInTipLabel : "Zoom in";
    const zoomOutTipLabel = options.zoomOutTipLabel !== void 0 ? options.zoomOutTipLabel : "Zoom out";
    const inElement = document.createElement("button");
    inElement.className = zoomInClassName;
    inElement.setAttribute("type", "button");
    inElement.title = zoomInTipLabel;
    inElement.appendChild(
      typeof zoomInLabel === "string" ? document.createTextNode(zoomInLabel) : zoomInLabel
    );
    inElement.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this, delta),
      false
    );
    const outElement = document.createElement("button");
    outElement.className = zoomOutClassName;
    outElement.setAttribute("type", "button");
    outElement.title = zoomOutTipLabel;
    outElement.appendChild(
      typeof zoomOutLabel === "string" ? document.createTextNode(zoomOutLabel) : zoomOutLabel
    );
    outElement.addEventListener(
      EventType_default.CLICK,
      this.handleClick_.bind(this, -delta),
      false
    );
    const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
    const element = this.element;
    element.className = cssClasses;
    element.appendChild(inElement);
    element.appendChild(outElement);
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  /**
   * @param {number} delta Zoom delta.
   * @param {MouseEvent} event The event to handle
   * @private
   */
  handleClick_(delta, event) {
    event.preventDefault();
    this.zoomByDelta_(delta);
  }
  /**
   * @param {number} delta Zoom delta.
   * @private
   */
  zoomByDelta_(delta) {
    const map = this.getMap();
    const view = map.getView();
    if (!view) {
      return;
    }
    const currentZoom = view.getZoom();
    if (currentZoom !== void 0) {
      const newZoom = view.getConstrainedZoom(currentZoom + delta);
      if (this.duration_ > 0) {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.animate({
          zoom: newZoom,
          duration: this.duration_,
          easing: easeOut
        });
      } else {
        view.setZoom(newZoom);
      }
    }
  }
};
var Zoom_default = Zoom;

// node_modules/ol/control/defaults.js
init_Collection();
function defaults(options) {
  options = options ? options : {};
  const controls = new Collection_default();
  const zoomControl = options.zoom !== void 0 ? options.zoom : true;
  if (zoomControl) {
    controls.push(new Zoom_default(options.zoomOptions));
  }
  const rotateControl = options.rotate !== void 0 ? options.rotate : true;
  if (rotateControl) {
    controls.push(new Rotate_default(options.rotateOptions));
  }
  const attributionControl = options.attribution !== void 0 ? options.attribution : true;
  if (attributionControl) {
    controls.push(new Attribution_default(options.attributionOptions));
  }
  return controls;
}

// node_modules/ol/interaction/Property.js
var Property_default2 = {
  ACTIVE: "active"
};

// node_modules/ol/interaction/Interaction.js
init_Object();
init_easing();
var Interaction = class extends Object_default {
  /**
   * @param {InteractionOptions} [options] Options.
   */
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    if (options && options.handleEvent) {
      this.handleEvent = options.handleEvent;
    }
    this.map_ = null;
    this.setActive(true);
  }
  /**
   * Return whether the interaction is currently active.
   * @return {boolean} `true` if the interaction is active, `false` otherwise.
   * @observable
   * @api
   */
  getActive() {
    return (
      /** @type {boolean} */
      this.get(Property_default2.ACTIVE)
    );
  }
  /**
   * Get the map associated with this interaction.
   * @return {import("../Map.js").default|null} Map.
   * @api
   */
  getMap() {
    return this.map_;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(mapBrowserEvent) {
    return true;
  }
  /**
   * Activate or deactivate the interaction.
   * @param {boolean} active Active.
   * @observable
   * @api
   */
  setActive(active) {
    this.set(Property_default2.ACTIVE, active);
  }
  /**
   * Remove the interaction from its current map and attach it to the new map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(map) {
    this.map_ = map;
  }
};
function pan(view, delta, duration) {
  const currentCenter = view.getCenterInternal();
  if (currentCenter) {
    const center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
    view.animateInternal({
      duration: duration !== void 0 ? duration : 250,
      easing: linear,
      center: view.getConstrainedCenter(center)
    });
  }
}
function zoomByDelta(view, delta, anchor, duration) {
  const currentZoom = view.getZoom();
  if (currentZoom === void 0) {
    return;
  }
  const newZoom = view.getConstrainedZoom(currentZoom + delta);
  const newResolution = view.getResolutionForZoom(newZoom);
  if (view.getAnimating()) {
    view.cancelAnimations();
  }
  view.animate({
    resolution: newResolution,
    anchor,
    duration: duration !== void 0 ? duration : 250,
    easing: easeOut
  });
}
var Interaction_default = Interaction;

// node_modules/ol/interaction/DoubleClickZoom.js
var DoubleClickZoom = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    options = options ? options : {};
    this.delta_ = options.delta ? options.delta : 1;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
   * doubleclick) and eventually zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == MapBrowserEventType_default.DBLCLICK) {
      const browserEvent = (
        /** @type {MouseEvent} */
        mapBrowserEvent.originalEvent
      );
      const map = mapBrowserEvent.map;
      const anchor = mapBrowserEvent.coordinate;
      const delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
      const view = map.getView();
      zoomByDelta(view, delta, anchor, this.duration_);
      browserEvent.preventDefault();
      stopEvent = true;
    }
    return !stopEvent;
  }
};
var DoubleClickZoom_default = DoubleClickZoom;

// node_modules/ol/interaction/Pointer.js
var PointerInteraction = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      options
    );
    if (options.handleDownEvent) {
      this.handleDownEvent = options.handleDownEvent;
    }
    if (options.handleDragEvent) {
      this.handleDragEvent = options.handleDragEvent;
    }
    if (options.handleMoveEvent) {
      this.handleMoveEvent = options.handleMoveEvent;
    }
    if (options.handleUpEvent) {
      this.handleUpEvent = options.handleUpEvent;
    }
    if (options.stopDown) {
      this.stopDown = options.stopDown;
    }
    this.handlingDownUpSequence = false;
    this.targetPointers = [];
  }
  /**
   * Returns the current number of pointers involved in the interaction,
   * e.g. `2` when two fingers are used.
   * @return {number} The number of pointers.
   * @api
   */
  getPointerCount() {
    return this.targetPointers.length;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleDownEvent(mapBrowserEvent) {
    return false;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleDragEvent(mapBrowserEvent) {
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
   * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
   * detected.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   * @api
   */
  handleEvent(mapBrowserEvent) {
    if (!mapBrowserEvent.originalEvent) {
      return true;
    }
    let stopEvent = false;
    this.updateTrackedPointers_(mapBrowserEvent);
    if (this.handlingDownUpSequence) {
      if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERDRAG) {
        this.handleDragEvent(mapBrowserEvent);
        mapBrowserEvent.originalEvent.preventDefault();
      } else if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERUP) {
        const handledUp = this.handleUpEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
      }
    } else {
      if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERDOWN) {
        const handled = this.handleDownEvent(mapBrowserEvent);
        this.handlingDownUpSequence = handled;
        stopEvent = this.stopDown(handled);
      } else if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERMOVE) {
        this.handleMoveEvent(mapBrowserEvent);
      }
    }
    return !stopEvent;
  }
  /**
   * Handle pointer move events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @protected
   */
  handleMoveEvent(mapBrowserEvent) {
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   * @protected
   */
  handleUpEvent(mapBrowserEvent) {
    return false;
  }
  /**
   * This function is used to determine if "down" events should be propagated
   * to other interactions or should be stopped.
   * @param {boolean} handled Was the event handled by the interaction?
   * @return {boolean} Should the `down` event be stopped?
   */
  stopDown(handled) {
    return handled;
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @private
   */
  updateTrackedPointers_(mapBrowserEvent) {
    if (mapBrowserEvent.activePointers) {
      this.targetPointers = mapBrowserEvent.activePointers;
    }
  }
};
function centroid(pointerEvents) {
  const length = pointerEvents.length;
  let clientX = 0;
  let clientY = 0;
  for (let i = 0; i < length; i++) {
    clientX += pointerEvents[i].clientX;
    clientY += pointerEvents[i].clientY;
  }
  return { clientX: clientX / length, clientY: clientY / length };
}
var Pointer_default = PointerInteraction;

// node_modules/ol/events/condition.js
init_functions();
init_has();
init_asserts();
function all(var_args) {
  const conditions = arguments;
  return function(event) {
    let pass = true;
    for (let i = 0, ii = conditions.length; i < ii; ++i) {
      pass = pass && conditions[i](event);
      if (!pass) {
        break;
      }
    }
    return pass;
  };
}
var altKeyOnly = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
var altShiftKeysOnly = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
var focus = function(event) {
  const targetElement = event.map.getTargetElement();
  const activeElement = event.map.getOwnerDocument().activeElement;
  return targetElement.contains(activeElement);
};
var focusWithTabindex = function(event) {
  return event.map.getTargetElement().hasAttribute("tabindex") ? focus(event) : true;
};
var always = TRUE;
var click = function(mapBrowserEvent) {
  return mapBrowserEvent.type == MapBrowserEventType_default.CLICK;
};
var mouseActionButton = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {MouseEvent} */
    mapBrowserEvent.originalEvent
  );
  return originalEvent.button == 0 && !(WEBKIT && MAC && originalEvent.ctrlKey);
};
var never = FALSE;
var pointerMove = function(mapBrowserEvent) {
  return mapBrowserEvent.type == "pointermove";
};
var singleClick = function(mapBrowserEvent) {
  return mapBrowserEvent.type == MapBrowserEventType_default.SINGLECLICK;
};
var doubleClick = function(mapBrowserEvent) {
  return mapBrowserEvent.type == MapBrowserEventType_default.DBLCLICK;
};
var noModifierKeys = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
var platformModifierKeyOnly = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return !originalEvent.altKey && (MAC ? originalEvent.metaKey : originalEvent.ctrlKey) && !originalEvent.shiftKey;
};
var platformModifierKey = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return MAC ? originalEvent.metaKey : originalEvent.ctrlKey;
};
var shiftKeyOnly = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
};
var targetNotEditable = function(mapBrowserEvent) {
  const originalEvent = (
    /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
    mapBrowserEvent.originalEvent
  );
  const tagName = (
    /** @type {Element} */
    originalEvent.target.tagName
  );
  return tagName !== "INPUT" && tagName !== "SELECT" && tagName !== "TEXTAREA" && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
  // different type like `SVGElement`.
  // @ts-ignore
  !originalEvent.target.isContentEditable;
};
var mouseOnly = function(mapBrowserEvent) {
  const pointerEvent = (
    /** @type {import("../MapBrowserEvent").default} */
    mapBrowserEvent.originalEvent
  );
  assert(
    pointerEvent !== void 0,
    "mapBrowserEvent must originate from a pointer event"
  );
  return pointerEvent.pointerType == "mouse";
};
var touchOnly = function(mapBrowserEvent) {
  const pointerEvt = (
    /** @type {import("../MapBrowserEvent").default} */
    mapBrowserEvent.originalEvent
  );
  assert(
    pointerEvt !== void 0,
    "mapBrowserEvent must originate from a pointer event"
  );
  return pointerEvt.pointerType === "touch";
};
var penOnly = function(mapBrowserEvent) {
  const pointerEvt = (
    /** @type {import("../MapBrowserEvent").default} */
    mapBrowserEvent.originalEvent
  );
  assert(
    pointerEvt !== void 0,
    "mapBrowserEvent must originate from a pointer event"
  );
  return pointerEvt.pointerType === "pen";
};
var primaryAction = function(mapBrowserEvent) {
  const pointerEvent = (
    /** @type {import("../MapBrowserEvent").default} */
    mapBrowserEvent.originalEvent
  );
  assert(
    pointerEvent !== void 0,
    "mapBrowserEvent must originate from a pointer event"
  );
  return pointerEvent.isPrimary && pointerEvent.button === 0;
};

// node_modules/ol/interaction/DragPan.js
init_functions();
init_easing();
init_coordinate();
var DragPan = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super({
      stopDown: FALSE
    });
    options = options ? options : {};
    this.kinetic_ = options.kinetic;
    this.lastCentroid = null;
    this.lastPointersCount_;
    this.panning_ = false;
    const condition = options.condition ? options.condition : all(noModifierKeys, primaryAction);
    this.condition_ = options.onFocusOnly ? all(focusWithTabindex, condition) : condition;
    this.noKinetic_ = false;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(mapBrowserEvent) {
    const map = mapBrowserEvent.map;
    if (!this.panning_) {
      this.panning_ = true;
      map.getView().beginInteraction();
    }
    const targetPointers = this.targetPointers;
    const centroid2 = map.getEventPixel(centroid(targetPointers));
    if (targetPointers.length == this.lastPointersCount_) {
      if (this.kinetic_) {
        this.kinetic_.update(centroid2[0], centroid2[1]);
      }
      if (this.lastCentroid) {
        const delta = [
          this.lastCentroid[0] - centroid2[0],
          centroid2[1] - this.lastCentroid[1]
        ];
        const map2 = mapBrowserEvent.map;
        const view = map2.getView();
        scale2(delta, view.getResolution());
        rotate2(delta, view.getRotation());
        view.adjustCenterInternal(delta);
      }
    } else if (this.kinetic_) {
      this.kinetic_.begin();
    }
    this.lastCentroid = centroid2;
    this.lastPointersCount_ = targetPointers.length;
    mapBrowserEvent.originalEvent.preventDefault();
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(mapBrowserEvent) {
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (this.targetPointers.length === 0) {
      if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
        const distance2 = this.kinetic_.getDistance();
        const angle = this.kinetic_.getAngle();
        const center = view.getCenterInternal();
        const centerpx = map.getPixelFromCoordinateInternal(center);
        const dest = map.getCoordinateFromPixelInternal([
          centerpx[0] - distance2 * Math.cos(angle),
          centerpx[1] - distance2 * Math.sin(angle)
        ]);
        view.animateInternal({
          center: view.getConstrainedCenter(dest),
          duration: 500,
          easing: easeOut
        });
      }
      if (this.panning_) {
        this.panning_ = false;
        view.endInteraction();
      }
      return false;
    }
    if (this.kinetic_) {
      this.kinetic_.begin();
    }
    this.lastCentroid = null;
    return true;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      this.lastCentroid = null;
      if (view.getAnimating()) {
        view.cancelAnimations();
      }
      if (this.kinetic_) {
        this.kinetic_.begin();
      }
      this.noKinetic_ = this.targetPointers.length > 1;
      return true;
    }
    return false;
  }
};
var DragPan_default = DragPan;

// node_modules/ol/interaction/DragRotate.js
init_functions();
init_rotationconstraint();
var DragRotate = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    super({
      stopDown: FALSE
    });
    this.condition_ = options.condition ? options.condition : altShiftKeysOnly;
    this.lastAngle_ = void 0;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return;
    }
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (view.getConstraints().rotation === disable) {
      return;
    }
    const size = map.getSize();
    const offset2 = mapBrowserEvent.pixel;
    const theta = Math.atan2(size[1] / 2 - offset2[1], offset2[0] - size[0] / 2);
    if (this.lastAngle_ !== void 0) {
      const delta = theta - this.lastAngle_;
      view.adjustRotationInternal(-delta);
    }
    this.lastAngle_ = theta;
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return true;
    }
    const map = mapBrowserEvent.map;
    const view = map.getView();
    view.endInteraction(this.duration_);
    return false;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(mapBrowserEvent) {
    if (!mouseOnly(mapBrowserEvent)) {
      return false;
    }
    if (mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
      const map = mapBrowserEvent.map;
      map.getView().beginInteraction();
      this.lastAngle_ = void 0;
      return true;
    }
    return false;
  }
};
var DragRotate_default = DragRotate;

// node_modules/ol/render/Box.js
init_Disposable();
init_Polygon();
var RenderBox = class extends Disposable_default {
  /**
   * @param {string} className CSS class name.
   */
  constructor(className) {
    super();
    this.geometry_ = null;
    this.element_ = document.createElement("div");
    this.element_.style.position = "absolute";
    this.element_.style.pointerEvents = "auto";
    this.element_.className = "ol-box " + className;
    this.map_ = null;
    this.startPixel_ = null;
    this.endPixel_ = null;
  }
  /**
   * Clean up.
   */
  disposeInternal() {
    this.setMap(null);
  }
  /**
   * @private
   */
  render_() {
    const startPixel = this.startPixel_;
    const endPixel = this.endPixel_;
    const px = "px";
    const style = this.element_.style;
    style.left = Math.min(startPixel[0], endPixel[0]) + px;
    style.top = Math.min(startPixel[1], endPixel[1]) + px;
    style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
    style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
  }
  /**
   * @param {import("../Map.js").default|null} map Map.
   */
  setMap(map) {
    if (this.map_) {
      this.map_.getOverlayContainer().removeChild(this.element_);
      const style = this.element_.style;
      style.left = "inherit";
      style.top = "inherit";
      style.width = "inherit";
      style.height = "inherit";
    }
    this.map_ = map;
    if (this.map_) {
      this.map_.getOverlayContainer().appendChild(this.element_);
    }
  }
  /**
   * @param {import("../pixel.js").Pixel} startPixel Start pixel.
   * @param {import("../pixel.js").Pixel} endPixel End pixel.
   */
  setPixels(startPixel, endPixel) {
    this.startPixel_ = startPixel;
    this.endPixel_ = endPixel;
    this.createOrUpdateGeometry();
    this.render_();
  }
  /**
   * Creates or updates the cached geometry.
   */
  createOrUpdateGeometry() {
    const startPixel = this.startPixel_;
    const endPixel = this.endPixel_;
    const pixels = [
      startPixel,
      [startPixel[0], endPixel[1]],
      endPixel,
      [endPixel[0], startPixel[1]]
    ];
    const coordinates2 = pixels.map(
      this.map_.getCoordinateFromPixelInternal,
      this.map_
    );
    coordinates2[4] = coordinates2[0].slice();
    if (!this.geometry_) {
      this.geometry_ = new Polygon_default([coordinates2]);
    } else {
      this.geometry_.setCoordinates([coordinates2]);
    }
  }
  /**
   * @return {import("../geom/Polygon.js").default} Geometry.
   */
  getGeometry() {
    return this.geometry_;
  }
};
var Box_default = RenderBox;

// node_modules/ol/interaction/DragBox.js
init_Event();
var DragBoxEventType = {
  /**
   * Triggered upon drag box start.
   * @event DragBoxEvent#boxstart
   * @api
   */
  BOXSTART: "boxstart",
  /**
   * Triggered on drag when box is active.
   * @event DragBoxEvent#boxdrag
   * @api
   */
  BOXDRAG: "boxdrag",
  /**
   * Triggered upon drag box end.
   * @event DragBoxEvent#boxend
   * @api
   */
  BOXEND: "boxend",
  /**
   * Triggered upon drag box canceled.
   * @event DragBoxEvent#boxcancel
   * @api
   */
  BOXCANCEL: "boxcancel"
};
var DragBoxEvent = class extends Event_default {
  /**
   * @param {string} type The event type.
   * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
   */
  constructor(type, coordinate, mapBrowserEvent) {
    super(type);
    this.coordinate = coordinate;
    this.mapBrowserEvent = mapBrowserEvent;
  }
};
var DragBox = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    this.on;
    this.once;
    this.un;
    options = options ? options : {};
    this.box_ = new Box_default(options.className || "ol-dragbox");
    this.minArea_ = options.minArea !== void 0 ? options.minArea : 64;
    if (options.onBoxEnd) {
      this.onBoxEnd = options.onBoxEnd;
    }
    this.startPixel_ = null;
    this.condition_ = options.condition ? options.condition : mouseActionButton;
    this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : this.defaultBoxEndCondition;
  }
  /**
   * The default condition for determining whether the boxend event
   * should fire.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
   *     leading to the box end.
   * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
   * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
   * @return {boolean} Whether or not the boxend condition should be fired.
   */
  defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {
    const width = endPixel[0] - startPixel[0];
    const height = endPixel[1] - startPixel[1];
    return width * width + height * height >= this.minArea_;
  }
  /**
   * Returns geometry of last drawn box.
   * @return {import("../geom/Polygon.js").default} Geometry.
   * @api
   */
  getGeometry() {
    return this.box_.getGeometry();
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(mapBrowserEvent) {
    this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
    this.dispatchEvent(
      new DragBoxEvent(
        DragBoxEventType.BOXDRAG,
        mapBrowserEvent.coordinate,
        mapBrowserEvent
      )
    );
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(mapBrowserEvent) {
    this.box_.setMap(null);
    const completeBox = this.boxEndCondition_(
      mapBrowserEvent,
      this.startPixel_,
      mapBrowserEvent.pixel
    );
    if (completeBox) {
      this.onBoxEnd(mapBrowserEvent);
    }
    this.dispatchEvent(
      new DragBoxEvent(
        completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL,
        mapBrowserEvent.coordinate,
        mapBrowserEvent
      )
    );
    return false;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.condition_(mapBrowserEvent)) {
      this.startPixel_ = mapBrowserEvent.pixel;
      this.box_.setMap(mapBrowserEvent.map);
      this.box_.setPixels(this.startPixel_, this.startPixel_);
      this.dispatchEvent(
        new DragBoxEvent(
          DragBoxEventType.BOXSTART,
          mapBrowserEvent.coordinate,
          mapBrowserEvent
        )
      );
      return true;
    }
    return false;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(event) {
  }
};
var DragBox_default = DragBox;

// node_modules/ol/interaction/DragZoom.js
init_easing();
var DragZoom = class extends DragBox_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    const condition = options.condition ? options.condition : shiftKeyOnly;
    super({
      condition,
      className: options.className || "ol-dragzoom",
      minArea: options.minArea
    });
    this.duration_ = options.duration !== void 0 ? options.duration : 200;
    this.out_ = options.out !== void 0 ? options.out : false;
  }
  /**
   * Function to execute just before `onboxend` is fired
   * @param {import("../MapBrowserEvent.js").default} event Event.
   */
  onBoxEnd(event) {
    const map = this.getMap();
    const view = (
      /** @type {!import("../View.js").default} */
      map.getView()
    );
    let geometry = this.getGeometry();
    if (this.out_) {
      const rotatedExtent = view.rotatedExtentForGeometry(geometry);
      const resolution = view.getResolutionForExtentInternal(rotatedExtent);
      const factor = view.getResolution() / resolution;
      geometry = geometry.clone();
      geometry.scale(factor * factor);
    }
    view.fitInternal(geometry, {
      duration: this.duration_,
      easing: easeOut
    });
  }
};
var DragZoom_default = DragZoom;

// node_modules/ol/events/Key.js
var Key_default = {
  LEFT: "ArrowLeft",
  UP: "ArrowUp",
  RIGHT: "ArrowRight",
  DOWN: "ArrowDown"
};

// node_modules/ol/interaction/KeyboardPan.js
init_EventType();
init_coordinate();
var KeyboardPan = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    options = options || {};
    this.defaultCondition_ = function(mapBrowserEvent) {
      return noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);
    };
    this.condition_ = options.condition !== void 0 ? options.condition : this.defaultCondition_;
    this.duration_ = options.duration !== void 0 ? options.duration : 100;
    this.pixelDelta_ = options.pixelDelta !== void 0 ? options.pixelDelta : 128;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides the direction to pan to (if an arrow key was
   * pressed).
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == EventType_default.KEYDOWN) {
      const keyEvent = (
        /** @type {KeyboardEvent} */
        mapBrowserEvent.originalEvent
      );
      const key = keyEvent.key;
      if (this.condition_(mapBrowserEvent) && (key == Key_default.DOWN || key == Key_default.LEFT || key == Key_default.RIGHT || key == Key_default.UP)) {
        const map = mapBrowserEvent.map;
        const view = map.getView();
        const mapUnitsDelta = view.getResolution() * this.pixelDelta_;
        let deltaX = 0, deltaY = 0;
        if (key == Key_default.DOWN) {
          deltaY = -mapUnitsDelta;
        } else if (key == Key_default.LEFT) {
          deltaX = -mapUnitsDelta;
        } else if (key == Key_default.RIGHT) {
          deltaX = mapUnitsDelta;
        } else {
          deltaY = mapUnitsDelta;
        }
        const delta = [deltaX, deltaY];
        rotate2(delta, view.getRotation());
        pan(view, delta, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }
    return !stopEvent;
  }
};
var KeyboardPan_default = KeyboardPan;

// node_modules/ol/interaction/KeyboardZoom.js
init_EventType();
var KeyboardZoom = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    super();
    options = options ? options : {};
    this.condition_ = options.condition ? options.condition : function(mapBrowserEvent) {
      return !platformModifierKey(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);
    };
    this.delta_ = options.delta ? options.delta : 1;
    this.duration_ = options.duration !== void 0 ? options.duration : 100;
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
   * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
   * key pressed was '+' or '-').
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(mapBrowserEvent) {
    let stopEvent = false;
    if (mapBrowserEvent.type == EventType_default.KEYDOWN || mapBrowserEvent.type == EventType_default.KEYPRESS) {
      const keyEvent = (
        /** @type {KeyboardEvent} */
        mapBrowserEvent.originalEvent
      );
      const key = keyEvent.key;
      if (this.condition_(mapBrowserEvent) && (key === "+" || key === "-")) {
        const map = mapBrowserEvent.map;
        const delta = key === "+" ? this.delta_ : -this.delta_;
        const view = map.getView();
        zoomByDelta(view, delta, void 0, this.duration_);
        keyEvent.preventDefault();
        stopEvent = true;
      }
    }
    return !stopEvent;
  }
};
var KeyboardZoom_default = KeyboardZoom;

// node_modules/ol/Kinetic.js
var Kinetic = class {
  /**
   * @param {number} decay Rate of decay (must be negative).
   * @param {number} minVelocity Minimum velocity (pixels/millisecond).
   * @param {number} delay Delay to consider to calculate the kinetic
   *     initial values (milliseconds).
   */
  constructor(decay, minVelocity, delay) {
    this.decay_ = decay;
    this.minVelocity_ = minVelocity;
    this.delay_ = delay;
    this.points_ = [];
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  }
  /**
   * FIXME empty description for jsdoc
   */
  begin() {
    this.points_.length = 0;
    this.angle_ = 0;
    this.initialVelocity_ = 0;
  }
  /**
   * @param {number} x X.
   * @param {number} y Y.
   */
  update(x, y) {
    this.points_.push(x, y, Date.now());
  }
  /**
   * @return {boolean} Whether we should do kinetic animation.
   */
  end() {
    if (this.points_.length < 6) {
      return false;
    }
    const delay = Date.now() - this.delay_;
    const lastIndex = this.points_.length - 3;
    if (this.points_[lastIndex + 2] < delay) {
      return false;
    }
    let firstIndex = lastIndex - 3;
    while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
      firstIndex -= 3;
    }
    const duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
    if (duration < 1e3 / 60) {
      return false;
    }
    const dx = this.points_[lastIndex] - this.points_[firstIndex];
    const dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
    this.angle_ = Math.atan2(dy, dx);
    this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
    return this.initialVelocity_ > this.minVelocity_;
  }
  /**
   * @return {number} Total distance travelled (pixels).
   */
  getDistance() {
    return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
  }
  /**
   * @return {number} Angle of the kinetic panning animation (radians).
   */
  getAngle() {
    return this.angle_;
  }
};
var Kinetic_default = Kinetic;

// node_modules/ol/interaction/MouseWheelZoom.js
init_EventType();
init_has();
init_math();
var MouseWheelZoom = class extends Interaction_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    super(
      /** @type {import("./Interaction.js").InteractionOptions} */
      options
    );
    this.totalDelta_ = 0;
    this.lastDelta_ = 0;
    this.maxDelta_ = options.maxDelta !== void 0 ? options.maxDelta : 1;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
    this.timeout_ = options.timeout !== void 0 ? options.timeout : 80;
    this.useAnchor_ = options.useAnchor !== void 0 ? options.useAnchor : true;
    this.constrainResolution_ = options.constrainResolution !== void 0 ? options.constrainResolution : false;
    const condition = options.condition ? options.condition : always;
    this.condition_ = options.onFocusOnly ? all(focusWithTabindex, condition) : condition;
    this.lastAnchor_ = null;
    this.startTime_ = void 0;
    this.timeoutId_;
    this.mode_ = void 0;
    this.trackpadEventGap_ = 400;
    this.trackpadTimeoutId_;
    this.deltaPerZoom_ = 300;
  }
  /**
   * @private
   */
  endInteraction_() {
    this.trackpadTimeoutId_ = void 0;
    const map = this.getMap();
    if (!map) {
      return;
    }
    const view = map.getView();
    view.endInteraction(
      void 0,
      this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0,
      this.lastAnchor_
    );
  }
  /**
   * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
   * zooms the map.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} `false` to stop event propagation.
   */
  handleEvent(mapBrowserEvent) {
    if (!this.condition_(mapBrowserEvent)) {
      return true;
    }
    const type = mapBrowserEvent.type;
    if (type !== EventType_default.WHEEL) {
      return true;
    }
    const map = mapBrowserEvent.map;
    const wheelEvent = (
      /** @type {WheelEvent} */
      mapBrowserEvent.originalEvent
    );
    wheelEvent.preventDefault();
    if (this.useAnchor_) {
      this.lastAnchor_ = mapBrowserEvent.coordinate;
    }
    let delta;
    if (mapBrowserEvent.type == EventType_default.WHEEL) {
      delta = wheelEvent.deltaY;
      if (FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
        delta /= DEVICE_PIXEL_RATIO;
      }
      if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
        delta *= 40;
      }
    }
    if (delta === 0) {
      return false;
    }
    this.lastDelta_ = delta;
    const now = Date.now();
    if (this.startTime_ === void 0) {
      this.startTime_ = now;
    }
    if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
      this.mode_ = Math.abs(delta) < 4 ? "trackpad" : "wheel";
    }
    const view = map.getView();
    if (this.mode_ === "trackpad" && !(view.getConstrainResolution() || this.constrainResolution_)) {
      if (this.trackpadTimeoutId_) {
        clearTimeout(this.trackpadTimeoutId_);
      } else {
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        view.beginInteraction();
      }
      this.trackpadTimeoutId_ = setTimeout(
        this.endInteraction_.bind(this),
        this.timeout_
      );
      view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
      this.startTime_ = now;
      return false;
    }
    this.totalDelta_ += delta;
    const timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
    clearTimeout(this.timeoutId_);
    this.timeoutId_ = setTimeout(
      this.handleWheelZoom_.bind(this, map),
      timeLeft
    );
    return false;
  }
  /**
   * @private
   * @param {import("../Map.js").default} map Map.
   */
  handleWheelZoom_(map) {
    const view = map.getView();
    if (view.getAnimating()) {
      view.cancelAnimations();
    }
    let delta = -clamp(
      this.totalDelta_,
      -this.maxDelta_ * this.deltaPerZoom_,
      this.maxDelta_ * this.deltaPerZoom_
    ) / this.deltaPerZoom_;
    if (view.getConstrainResolution() || this.constrainResolution_) {
      delta = delta ? delta > 0 ? 1 : -1 : 0;
    }
    zoomByDelta(view, delta, this.lastAnchor_, this.duration_);
    this.mode_ = void 0;
    this.totalDelta_ = 0;
    this.lastAnchor_ = null;
    this.startTime_ = void 0;
    this.timeoutId_ = void 0;
  }
  /**
   * Enable or disable using the mouse's location as an anchor when zooming
   * @param {boolean} useAnchor true to zoom to the mouse's location, false
   * to zoom to the center of the map
   * @api
   */
  setMouseAnchor(useAnchor) {
    this.useAnchor_ = useAnchor;
    if (!useAnchor) {
      this.lastAnchor_ = null;
    }
  }
};
var MouseWheelZoom_default = MouseWheelZoom;

// node_modules/ol/interaction/PinchRotate.js
init_functions();
init_rotationconstraint();
var PinchRotate = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    const pointerOptions = (
      /** @type {import("./Pointer.js").Options} */
      options
    );
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = FALSE;
    }
    super(pointerOptions);
    this.anchor_ = null;
    this.lastAngle_ = void 0;
    this.rotating_ = false;
    this.rotationDelta_ = 0;
    this.threshold_ = options.threshold !== void 0 ? options.threshold : 0.3;
    this.duration_ = options.duration !== void 0 ? options.duration : 250;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(mapBrowserEvent) {
    let rotationDelta = 0;
    const touch0 = this.targetPointers[0];
    const touch1 = this.targetPointers[1];
    const angle = Math.atan2(
      touch1.clientY - touch0.clientY,
      touch1.clientX - touch0.clientX
    );
    if (this.lastAngle_ !== void 0) {
      const delta = angle - this.lastAngle_;
      this.rotationDelta_ += delta;
      if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
        this.rotating_ = true;
      }
      rotationDelta = delta;
    }
    this.lastAngle_ = angle;
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (view.getConstraints().rotation === disable) {
      return;
    }
    this.anchor_ = map.getCoordinateFromPixelInternal(
      map.getEventPixel(centroid(this.targetPointers))
    );
    if (this.rotating_) {
      map.render();
      view.adjustRotationInternal(rotationDelta, this.anchor_);
    }
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      view.endInteraction(this.duration_);
      return false;
    }
    return true;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      const map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastAngle_ = void 0;
      this.rotating_ = false;
      this.rotationDelta_ = 0;
      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }
      return true;
    }
    return false;
  }
};
var PinchRotate_default = PinchRotate;

// node_modules/ol/interaction/PinchZoom.js
init_functions();
var PinchZoom = class extends Pointer_default {
  /**
   * @param {Options} [options] Options.
   */
  constructor(options) {
    options = options ? options : {};
    const pointerOptions = (
      /** @type {import("./Pointer.js").Options} */
      options
    );
    if (!pointerOptions.stopDown) {
      pointerOptions.stopDown = FALSE;
    }
    super(pointerOptions);
    this.anchor_ = null;
    this.duration_ = options.duration !== void 0 ? options.duration : 400;
    this.lastDistance_ = void 0;
    this.lastScaleDelta_ = 1;
  }
  /**
   * Handle pointer drag events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   */
  handleDragEvent(mapBrowserEvent) {
    let scaleDelta = 1;
    const touch0 = this.targetPointers[0];
    const touch1 = this.targetPointers[1];
    const dx = touch0.clientX - touch1.clientX;
    const dy = touch0.clientY - touch1.clientY;
    const distance2 = Math.sqrt(dx * dx + dy * dy);
    if (this.lastDistance_ !== void 0) {
      scaleDelta = this.lastDistance_ / distance2;
    }
    this.lastDistance_ = distance2;
    const map = mapBrowserEvent.map;
    const view = map.getView();
    if (scaleDelta != 1) {
      this.lastScaleDelta_ = scaleDelta;
    }
    this.anchor_ = map.getCoordinateFromPixelInternal(
      map.getEventPixel(centroid(this.targetPointers))
    );
    map.render();
    view.adjustResolutionInternal(scaleDelta, this.anchor_);
  }
  /**
   * Handle pointer up events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleUpEvent(mapBrowserEvent) {
    if (this.targetPointers.length < 2) {
      const map = mapBrowserEvent.map;
      const view = map.getView();
      const direction = this.lastScaleDelta_ > 1 ? 1 : -1;
      view.endInteraction(this.duration_, direction);
      return false;
    }
    return true;
  }
  /**
   * Handle pointer down events.
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} If the event was consumed.
   */
  handleDownEvent(mapBrowserEvent) {
    if (this.targetPointers.length >= 2) {
      const map = mapBrowserEvent.map;
      this.anchor_ = null;
      this.lastDistance_ = void 0;
      this.lastScaleDelta_ = 1;
      if (!this.handlingDownUpSequence) {
        map.getView().beginInteraction();
      }
      return true;
    }
    return false;
  }
};
var PinchZoom_default = PinchZoom;

// node_modules/ol/interaction/defaults.js
init_Collection();
function defaults2(options) {
  options = options ? options : {};
  const interactions = new Collection_default();
  const kinetic = new Kinetic_default(-5e-3, 0.05, 100);
  const altShiftDragRotate = options.altShiftDragRotate !== void 0 ? options.altShiftDragRotate : true;
  if (altShiftDragRotate) {
    interactions.push(new DragRotate_default());
  }
  const doubleClickZoom = options.doubleClickZoom !== void 0 ? options.doubleClickZoom : true;
  if (doubleClickZoom) {
    interactions.push(
      new DoubleClickZoom_default({
        delta: options.zoomDelta,
        duration: options.zoomDuration
      })
    );
  }
  const dragPan = options.dragPan !== void 0 ? options.dragPan : true;
  if (dragPan) {
    interactions.push(
      new DragPan_default({
        onFocusOnly: options.onFocusOnly,
        kinetic
      })
    );
  }
  const pinchRotate = options.pinchRotate !== void 0 ? options.pinchRotate : true;
  if (pinchRotate) {
    interactions.push(new PinchRotate_default());
  }
  const pinchZoom = options.pinchZoom !== void 0 ? options.pinchZoom : true;
  if (pinchZoom) {
    interactions.push(
      new PinchZoom_default({
        duration: options.zoomDuration
      })
    );
  }
  const keyboard = options.keyboard !== void 0 ? options.keyboard : true;
  if (keyboard) {
    interactions.push(new KeyboardPan_default());
    interactions.push(
      new KeyboardZoom_default({
        delta: options.zoomDelta,
        duration: options.zoomDuration
      })
    );
  }
  const mouseWheelZoom = options.mouseWheelZoom !== void 0 ? options.mouseWheelZoom : true;
  if (mouseWheelZoom) {
    interactions.push(
      new MouseWheelZoom_default({
        onFocusOnly: options.onFocusOnly,
        duration: options.zoomDuration
      })
    );
  }
  const shiftDragZoom = options.shiftDragZoom !== void 0 ? options.shiftDragZoom : true;
  if (shiftDragZoom) {
    interactions.push(
      new DragZoom_default({
        duration: options.zoomDuration
      })
    );
  }
  return interactions;
}

// node_modules/ol/Map.js
init_Object();
init_Collection();
init_CollectionEventType();
init_EventType();
init_Layer();
init_MapEventType();
init_ObjectEventType();
init_EventType2();
init_View();
init_ViewHint();
init_has();
init_functions();
init_transform();
init_asserts();
init_extent();
init_array();
init_proj();
init_util();
init_size();
init_events();
init_dom();
init_console();
function removeLayerMapProperty(layer) {
  if (layer instanceof Layer_default) {
    layer.setMapInternal(null);
    return;
  }
  if (layer instanceof Group_default) {
    layer.getLayers().forEach(removeLayerMapProperty);
  }
}
function setLayerMapProperty(layer, map) {
  if (layer instanceof Layer_default) {
    layer.setMapInternal(map);
    return;
  }
  if (layer instanceof Group_default) {
    const layers = layer.getLayers().getArray();
    for (let i = 0, ii = layers.length; i < ii; ++i) {
      setLayerMapProperty(layers[i], map);
    }
  }
}
var Map = class extends Object_default {
  /**
   * @param {MapOptions} [options] Map options.
   */
  constructor(options) {
    super();
    options = options || {};
    this.on;
    this.once;
    this.un;
    const optionsInternal = createOptionsInternal(options);
    this.renderComplete_;
    this.loaded_ = true;
    this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this);
    this.maxTilesLoading_ = options.maxTilesLoading !== void 0 ? options.maxTilesLoading : 16;
    this.pixelRatio_ = options.pixelRatio !== void 0 ? options.pixelRatio : DEVICE_PIXEL_RATIO;
    this.postRenderTimeoutHandle_;
    this.animationDelayKey_;
    this.animationDelay_ = this.animationDelay_.bind(this);
    this.coordinateToPixelTransform_ = create();
    this.pixelToCoordinateTransform_ = create();
    this.frameIndex_ = 0;
    this.frameState_ = null;
    this.previousExtent_ = null;
    this.viewPropertyListenerKey_ = null;
    this.viewChangeListenerKey_ = null;
    this.layerGroupPropertyListenerKeys_ = null;
    this.viewport_ = document.createElement("div");
    this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : "");
    this.viewport_.style.position = "relative";
    this.viewport_.style.overflow = "hidden";
    this.viewport_.style.width = "100%";
    this.viewport_.style.height = "100%";
    this.overlayContainer_ = document.createElement("div");
    this.overlayContainer_.style.position = "absolute";
    this.overlayContainer_.style.zIndex = "0";
    this.overlayContainer_.style.width = "100%";
    this.overlayContainer_.style.height = "100%";
    this.overlayContainer_.style.pointerEvents = "none";
    this.overlayContainer_.className = "ol-overlaycontainer";
    this.viewport_.appendChild(this.overlayContainer_);
    this.overlayContainerStopEvent_ = document.createElement("div");
    this.overlayContainerStopEvent_.style.position = "absolute";
    this.overlayContainerStopEvent_.style.zIndex = "0";
    this.overlayContainerStopEvent_.style.width = "100%";
    this.overlayContainerStopEvent_.style.height = "100%";
    this.overlayContainerStopEvent_.style.pointerEvents = "none";
    this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent";
    this.viewport_.appendChild(this.overlayContainerStopEvent_);
    this.mapBrowserEventHandler_ = null;
    this.moveTolerance_ = options.moveTolerance;
    this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
    this.targetChangeHandlerKeys_ = null;
    this.targetElement_ = null;
    this.resizeObserver_ = new ResizeObserver(() => this.updateSize());
    this.controls = optionsInternal.controls || defaults();
    this.interactions = optionsInternal.interactions || defaults2({
      onFocusOnly: true
    });
    this.overlays_ = optionsInternal.overlays;
    this.overlayIdIndex_ = {};
    this.renderer_ = null;
    this.postRenderFunctions_ = [];
    this.tileQueue_ = new TileQueue_default(
      this.getTilePriority.bind(this),
      this.handleTileChange_.bind(this)
    );
    this.addChangeListener(
      MapProperty_default.LAYERGROUP,
      this.handleLayerGroupChanged_
    );
    this.addChangeListener(MapProperty_default.VIEW, this.handleViewChanged_);
    this.addChangeListener(MapProperty_default.SIZE, this.handleSizeChanged_);
    this.addChangeListener(MapProperty_default.TARGET, this.handleTargetChanged_);
    this.setProperties(optionsInternal.values);
    const map = this;
    if (options.view && !(options.view instanceof View_default)) {
      options.view.then(function(viewOptions) {
        map.setView(new View_default(viewOptions));
      });
    }
    this.controls.addEventListener(
      CollectionEventType_default.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
       */
      (event) => {
        event.element.setMap(this);
      }
    );
    this.controls.addEventListener(
      CollectionEventType_default.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
       */
      (event) => {
        event.element.setMap(null);
      }
    );
    this.interactions.addEventListener(
      CollectionEventType_default.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (event) => {
        event.element.setMap(this);
      }
    );
    this.interactions.addEventListener(
      CollectionEventType_default.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
       */
      (event) => {
        event.element.setMap(null);
      }
    );
    this.overlays_.addEventListener(
      CollectionEventType_default.ADD,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (event) => {
        this.addOverlayInternal_(event.element);
      }
    );
    this.overlays_.addEventListener(
      CollectionEventType_default.REMOVE,
      /**
       * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
       */
      (event) => {
        const id = event.element.getId();
        if (id !== void 0) {
          delete this.overlayIdIndex_[id.toString()];
        }
        event.element.setMap(null);
      }
    );
    this.controls.forEach(
      /**
       * @param {import("./control/Control.js").default} control Control.
       */
      (control) => {
        control.setMap(this);
      }
    );
    this.interactions.forEach(
      /**
       * @param {import("./interaction/Interaction.js").default} interaction Interaction.
       */
      (interaction) => {
        interaction.setMap(this);
      }
    );
    this.overlays_.forEach(this.addOverlayInternal_.bind(this));
  }
  /**
   * Add the given control to the map.
   * @param {import("./control/Control.js").default} control Control.
   * @api
   */
  addControl(control) {
    this.getControls().push(control);
  }
  /**
   * Add the given interaction to the map. If you want to add an interaction
   * at another point of the collection use `getInteractions()` and the methods
   * available on {@link module:ol/Collection~Collection}. This can be used to
   * stop the event propagation from the handleEvent function. The interactions
   * get to handle the events in the reverse order of this collection.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
   * @api
   */
  addInteraction(interaction) {
    this.getInteractions().push(interaction);
  }
  /**
   * Adds the given layer to the top of this map. If you want to add a layer
   * elsewhere in the stack, use `getLayers()` and the methods available on
   * {@link module:ol/Collection~Collection}.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @api
   */
  addLayer(layer) {
    const layers = this.getLayerGroup().getLayers();
    layers.push(layer);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
   * @private
   */
  handleLayerAdd_(event) {
    setLayerMapProperty(event.layer, this);
  }
  /**
   * Add the given overlay to the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @api
   */
  addOverlay(overlay) {
    this.getOverlays().push(overlay);
  }
  /**
   * This deals with map's overlay collection changes.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @private
   */
  addOverlayInternal_(overlay) {
    const id = overlay.getId();
    if (id !== void 0) {
      this.overlayIdIndex_[id.toString()] = overlay;
    }
    overlay.setMap(this);
  }
  /**
   *
   * Clean up.
   */
  disposeInternal() {
    this.controls.clear();
    this.interactions.clear();
    this.overlays_.clear();
    this.resizeObserver_.disconnect();
    this.setTarget(null);
    super.disposeInternal();
  }
  /**
   * Detect features that intersect a pixel on the viewport, and execute a
   * callback with each intersecting feature. Layers included in the detection can
   * be configured through the `layerFilter` option in `options`.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
   *     called with two arguments. The first argument is one
   *     {@link module:ol/Feature~Feature feature} or
   *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
   *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
   *     unmanaged layers. To stop detection, callback functions can return a
   *     truthy value.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {T|undefined} Callback result, i.e. the return value of last
   * callback execution, or the first truthy callback return value.
   * @template T
   * @api
   */
  forEachFeatureAtPixel(pixel, callback, options) {
    if (!this.frameState_ || !this.renderer_) {
      return;
    }
    const coordinate = this.getCoordinateFromPixelInternal(pixel);
    options = options !== void 0 ? options : {};
    const hitTolerance = options.hitTolerance !== void 0 ? options.hitTolerance : 0;
    const layerFilter = options.layerFilter !== void 0 ? options.layerFilter : TRUE;
    const checkWrapped = options.checkWrapped !== false;
    return this.renderer_.forEachFeatureAtCoordinate(
      coordinate,
      this.frameState_,
      hitTolerance,
      checkWrapped,
      callback,
      null,
      layerFilter,
      null
    );
  }
  /**
   * Get all features that intersect a pixel on the viewport.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
   * an empty array if none were found.
   * @api
   */
  getFeaturesAtPixel(pixel, options) {
    const features = [];
    this.forEachFeatureAtPixel(
      pixel,
      function(feature) {
        features.push(feature);
      },
      options
    );
    return features;
  }
  /**
   * Get all layers from all layer groups.
   * @return {Array<import("./layer/Layer.js").default>} Layers.
   * @api
   */
  getAllLayers() {
    const layers = [];
    function addLayersFrom(layerGroup) {
      layerGroup.forEach(function(layer) {
        if (layer instanceof Group_default) {
          addLayersFrom(layer.getLayers());
        } else {
          layers.push(layer);
        }
      });
    }
    addLayersFrom(this.getLayers());
    return layers;
  }
  /**
   * Detect if features intersect a pixel on the viewport. Layers included in the
   * detection can be configured through the `layerFilter` option.
   * @param {import("./pixel.js").Pixel} pixel Pixel.
   * @param {AtPixelOptions} [options] Optional options.
   * @return {boolean} Is there a feature at the given pixel?
   * @api
   */
  hasFeatureAtPixel(pixel, options) {
    if (!this.frameState_ || !this.renderer_) {
      return false;
    }
    const coordinate = this.getCoordinateFromPixelInternal(pixel);
    options = options !== void 0 ? options : {};
    const layerFilter = options.layerFilter !== void 0 ? options.layerFilter : TRUE;
    const hitTolerance = options.hitTolerance !== void 0 ? options.hitTolerance : 0;
    const checkWrapped = options.checkWrapped !== false;
    return this.renderer_.hasFeatureAtCoordinate(
      coordinate,
      this.frameState_,
      hitTolerance,
      checkWrapped,
      layerFilter,
      null
    );
  }
  /**
   * Returns the coordinate in user projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  getEventCoordinate(event) {
    return this.getCoordinateFromPixel(this.getEventPixel(event));
  }
  /**
   * Returns the coordinate in view projection for a browser event.
   * @param {MouseEvent} event Event.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   */
  getEventCoordinateInternal(event) {
    return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
  }
  /**
   * Returns the map pixel position for a browser event relative to the viewport.
   * @param {UIEvent|{clientX: number, clientY: number}} event Event.
   * @return {import("./pixel.js").Pixel} Pixel.
   * @api
   */
  getEventPixel(event) {
    const viewport = this.viewport_;
    const viewportPosition = viewport.getBoundingClientRect();
    const viewportSize = this.getSize();
    const scaleX = viewportPosition.width / viewportSize[0];
    const scaleY = viewportPosition.height / viewportSize[1];
    const eventPosition = (
      //FIXME Are we really calling this with a TouchEvent anywhere?
      "changedTouches" in event ? (
        /** @type {TouchEvent} */
        event.changedTouches[0]
      ) : (
        /** @type {MouseEvent} */
        event
      )
    );
    return [
      (eventPosition.clientX - viewportPosition.left) / scaleX,
      (eventPosition.clientY - viewportPosition.top) / scaleY
    ];
  }
  /**
   * Get the target in which this map is rendered.
   * Note that this returns what is entered as an option or in setTarget:
   * if that was an element, it returns an element; if a string, it returns that.
   * @return {HTMLElement|string|undefined} The Element or id of the Element that the
   *     map is rendered in.
   * @observable
   * @api
   */
  getTarget() {
    return (
      /** @type {HTMLElement|string|undefined} */
      this.get(MapProperty_default.TARGET)
    );
  }
  /**
   * Get the DOM element into which this map is rendered. In contrast to
   * `getTarget` this method always return an `Element`, or `null` if the
   * map has no target.
   * @return {HTMLElement} The element that the map is rendered in.
   * @api
   */
  getTargetElement() {
    return this.targetElement_;
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * user projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   * @api
   */
  getCoordinateFromPixel(pixel) {
    return toUserCoordinate(
      this.getCoordinateFromPixelInternal(pixel),
      this.getView().getProjection()
    );
  }
  /**
   * Get the coordinate for a given pixel.  This returns a coordinate in the
   * map view projection.
   * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
   * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
   */
  getCoordinateFromPixelInternal(pixel) {
    const frameState = this.frameState_;
    if (!frameState) {
      return null;
    }
    return apply(frameState.pixelToCoordinateTransform, pixel.slice());
  }
  /**
   * Get the map controls. Modifying this collection changes the controls
   * associated with the map.
   * @return {Collection<import("./control/Control.js").default>} Controls.
   * @api
   */
  getControls() {
    return this.controls;
  }
  /**
   * Get the map overlays. Modifying this collection changes the overlays
   * associated with the map.
   * @return {Collection<import("./Overlay.js").default>} Overlays.
   * @api
   */
  getOverlays() {
    return this.overlays_;
  }
  /**
   * Get an overlay by its identifier (the value returned by overlay.getId()).
   * Note that the index treats string and numeric identifiers as the same. So
   * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
   * @param {string|number} id Overlay identifier.
   * @return {import("./Overlay.js").default} Overlay.
   * @api
   */
  getOverlayById(id) {
    const overlay = this.overlayIdIndex_[id.toString()];
    return overlay !== void 0 ? overlay : null;
  }
  /**
   * Get the map interactions. Modifying this collection changes the interactions
   * associated with the map.
   *
   * Interactions are used for e.g. pan, zoom and rotate.
   * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
   * @api
   */
  getInteractions() {
    return this.interactions;
  }
  /**
   * Get the layergroup associated with this map.
   * @return {LayerGroup} A layer group containing the layers in this map.
   * @observable
   * @api
   */
  getLayerGroup() {
    return (
      /** @type {LayerGroup} */
      this.get(MapProperty_default.LAYERGROUP)
    );
  }
  /**
   * Clear any existing layers and add layers to the map.
   * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
   * @api
   */
  setLayers(layers) {
    const group = this.getLayerGroup();
    if (layers instanceof Collection_default) {
      group.setLayers(layers);
      return;
    }
    const collection = group.getLayers();
    collection.clear();
    collection.extend(layers);
  }
  /**
   * Get the collection of layers associated with this map.
   * @return {!Collection<import("./layer/Base.js").default>} Layers.
   * @api
   */
  getLayers() {
    const layers = this.getLayerGroup().getLayers();
    return layers;
  }
  /**
   * @return {boolean} Layers have sources that are still loading.
   */
  getLoadingOrNotReady() {
    const layerStatesArray = this.getLayerGroup().getLayerStatesArray();
    for (let i = 0, ii = layerStatesArray.length; i < ii; ++i) {
      const state = layerStatesArray[i];
      if (!state.visible) {
        continue;
      }
      const renderer = state.layer.getRenderer();
      if (renderer && !renderer.ready) {
        return true;
      }
      const source = state.layer.getSource();
      if (source && source.loading) {
        return true;
      }
    }
    return false;
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the user
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   * @api
   */
  getPixelFromCoordinate(coordinate) {
    const viewCoordinate = fromUserCoordinate(
      coordinate,
      this.getView().getProjection()
    );
    return this.getPixelFromCoordinateInternal(viewCoordinate);
  }
  /**
   * Get the pixel for a coordinate.  This takes a coordinate in the map view
   * projection and returns the corresponding pixel.
   * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
   * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
   */
  getPixelFromCoordinateInternal(coordinate) {
    const frameState = this.frameState_;
    if (!frameState) {
      return null;
    }
    return apply(
      frameState.coordinateToPixelTransform,
      coordinate.slice(0, 2)
    );
  }
  /**
   * Get the map renderer.
   * @return {import("./renderer/Map.js").default|null} Renderer
   */
  getRenderer() {
    return this.renderer_;
  }
  /**
   * Get the size of this map.
   * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  getSize() {
    return (
      /** @type {import("./size.js").Size|undefined} */
      this.get(MapProperty_default.SIZE)
    );
  }
  /**
   * Get the view associated with this map. A view manages properties such as
   * center and resolution.
   * @return {View} The view that controls this map.
   * @observable
   * @api
   */
  getView() {
    return (
      /** @type {View} */
      this.get(MapProperty_default.VIEW)
    );
  }
  /**
   * Get the element that serves as the map viewport.
   * @return {HTMLElement} Viewport.
   * @api
   */
  getViewport() {
    return this.viewport_;
  }
  /**
   * Get the element that serves as the container for overlays.  Elements added to
   * this container will let mousedown and touchstart events through to the map,
   * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
   * events.
   * @return {!HTMLElement} The map's overlay container.
   */
  getOverlayContainer() {
    return this.overlayContainer_;
  }
  /**
   * Get the element that serves as a container for overlays that don't allow
   * event propagation. Elements added to this container won't let mousedown and
   * touchstart events through to the map, so clicks and gestures on an overlay
   * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
   * @return {!HTMLElement} The map's overlay container that stops events.
   */
  getOverlayContainerStopEvent() {
    return this.overlayContainerStopEvent_;
  }
  /**
   * @return {!Document} The document where the map is displayed.
   */
  getOwnerDocument() {
    const targetElement = this.getTargetElement();
    return targetElement ? targetElement.ownerDocument : document;
  }
  /**
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  getTilePriority(tile2, tileSourceKey, tileCenter, tileResolution) {
    return getTilePriority(
      this.frameState_,
      tile2,
      tileSourceKey,
      tileCenter,
      tileResolution
    );
  }
  /**
   * @param {UIEvent} browserEvent Browser event.
   * @param {string} [type] Type.
   */
  handleBrowserEvent(browserEvent, type) {
    type = type || browserEvent.type;
    const mapBrowserEvent = new MapBrowserEvent_default(type, this, browserEvent);
    this.handleMapBrowserEvent(mapBrowserEvent);
  }
  /**
   * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
   */
  handleMapBrowserEvent(mapBrowserEvent) {
    if (!this.frameState_) {
      return;
    }
    const originalEvent = (
      /** @type {PointerEvent} */
      mapBrowserEvent.originalEvent
    );
    const eventType = originalEvent.type;
    if (eventType === EventType_default3.POINTERDOWN || eventType === EventType_default.WHEEL || eventType === EventType_default.KEYDOWN) {
      const doc = this.getOwnerDocument();
      const rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;
      const target = (
        /** @type {Node} */
        originalEvent.target
      );
      if (
        // Abort if the target is a child of the container for elements whose events are not meant
        // to be handled by map interactions.
        this.overlayContainerStopEvent_.contains(target) || // Abort if the event target is a child of the container that is no longer in the page.
        // It's possible for the target to no longer be in the page if it has been removed in an
        // event listener, this might happen in a Control that recreates it's content based on
        // user interaction either manually or via a render in something like https://reactjs.org/
        !(rootNode === doc ? doc.documentElement : rootNode).contains(target)
      ) {
        return;
      }
    }
    mapBrowserEvent.frameState = this.frameState_;
    if (this.dispatchEvent(mapBrowserEvent) !== false) {
      const interactionsArray = this.getInteractions().getArray().slice();
      for (let i = interactionsArray.length - 1; i >= 0; i--) {
        const interaction = interactionsArray[i];
        if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) {
          continue;
        }
        const cont = interaction.handleEvent(mapBrowserEvent);
        if (!cont || mapBrowserEvent.propagationStopped) {
          break;
        }
      }
    }
  }
  /**
   * @protected
   */
  handlePostRender() {
    const frameState = this.frameState_;
    const tileQueue = this.tileQueue_;
    if (!tileQueue.isEmpty()) {
      let maxTotalLoading = this.maxTilesLoading_;
      let maxNewLoads = maxTotalLoading;
      if (frameState) {
        const hints = frameState.viewHints;
        if (hints[ViewHint_default.ANIMATING] || hints[ViewHint_default.INTERACTING]) {
          const lowOnFrameBudget = Date.now() - frameState.time > 8;
          maxTotalLoading = lowOnFrameBudget ? 0 : 8;
          maxNewLoads = lowOnFrameBudget ? 0 : 2;
        }
      }
      if (tileQueue.getTilesLoading() < maxTotalLoading) {
        tileQueue.reprioritize();
        tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
      }
    }
    if (frameState && this.renderer_ && !frameState.animate) {
      if (this.renderComplete_ === true) {
        if (this.hasListener(EventType_default2.RENDERCOMPLETE)) {
          this.renderer_.dispatchRenderEvent(
            EventType_default2.RENDERCOMPLETE,
            frameState
          );
        }
        if (this.loaded_ === false) {
          this.loaded_ = true;
          this.dispatchEvent(
            new MapEvent_default(MapEventType_default.LOADEND, this, frameState)
          );
        }
      } else if (this.loaded_ === true) {
        this.loaded_ = false;
        this.dispatchEvent(
          new MapEvent_default(MapEventType_default.LOADSTART, this, frameState)
        );
      }
    }
    const postRenderFunctions = this.postRenderFunctions_;
    for (let i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
      postRenderFunctions[i](this, frameState);
    }
    postRenderFunctions.length = 0;
  }
  /**
   * @private
   */
  handleSizeChanged_() {
    if (this.getView() && !this.getView().getAnimating()) {
      this.getView().resolveConstraints(0);
    }
    this.render();
  }
  /**
   * @private
   */
  handleTargetChanged_() {
    if (this.mapBrowserEventHandler_) {
      for (let i = 0, ii = this.targetChangeHandlerKeys_.length; i < ii; ++i) {
        unlistenByKey(this.targetChangeHandlerKeys_[i]);
      }
      this.targetChangeHandlerKeys_ = null;
      this.viewport_.removeEventListener(
        EventType_default.CONTEXTMENU,
        this.boundHandleBrowserEvent_
      );
      this.viewport_.removeEventListener(
        EventType_default.WHEEL,
        this.boundHandleBrowserEvent_
      );
      this.mapBrowserEventHandler_.dispose();
      this.mapBrowserEventHandler_ = null;
      removeNode(this.viewport_);
    }
    if (this.targetElement_) {
      this.resizeObserver_.unobserve(this.targetElement_);
      const rootNode = this.targetElement_.getRootNode();
      if (rootNode instanceof ShadowRoot) {
        this.resizeObserver_.unobserve(rootNode.host);
      }
      this.setSize(void 0);
    }
    const target = this.getTarget();
    const targetElement = typeof target === "string" ? document.getElementById(target) : target;
    this.targetElement_ = targetElement;
    if (!targetElement) {
      if (this.renderer_) {
        clearTimeout(this.postRenderTimeoutHandle_);
        this.postRenderTimeoutHandle_ = void 0;
        this.postRenderFunctions_.length = 0;
        this.renderer_.dispose();
        this.renderer_ = null;
      }
      if (this.animationDelayKey_) {
        cancelAnimationFrame(this.animationDelayKey_);
        this.animationDelayKey_ = void 0;
      }
    } else {
      targetElement.appendChild(this.viewport_);
      if (!this.renderer_) {
        this.renderer_ = new Composite_default(this);
      }
      this.mapBrowserEventHandler_ = new MapBrowserEventHandler_default(
        this,
        this.moveTolerance_
      );
      for (const key in MapBrowserEventType_default) {
        this.mapBrowserEventHandler_.addEventListener(
          MapBrowserEventType_default[key],
          this.handleMapBrowserEvent.bind(this)
        );
      }
      this.viewport_.addEventListener(
        EventType_default.CONTEXTMENU,
        this.boundHandleBrowserEvent_,
        false
      );
      this.viewport_.addEventListener(
        EventType_default.WHEEL,
        this.boundHandleBrowserEvent_,
        PASSIVE_EVENT_LISTENERS ? { passive: false } : false
      );
      const keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;
      this.targetChangeHandlerKeys_ = [
        listen(
          keyboardEventTarget,
          EventType_default.KEYDOWN,
          this.handleBrowserEvent,
          this
        ),
        listen(
          keyboardEventTarget,
          EventType_default.KEYPRESS,
          this.handleBrowserEvent,
          this
        )
      ];
      const rootNode = targetElement.getRootNode();
      if (rootNode instanceof ShadowRoot) {
        this.resizeObserver_.observe(rootNode.host);
      }
      this.resizeObserver_.observe(targetElement);
    }
    this.updateSize();
  }
  /**
   * @private
   */
  handleTileChange_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewPropertyChanged_() {
    this.render();
  }
  /**
   * @private
   */
  handleViewChanged_() {
    if (this.viewPropertyListenerKey_) {
      unlistenByKey(this.viewPropertyListenerKey_);
      this.viewPropertyListenerKey_ = null;
    }
    if (this.viewChangeListenerKey_) {
      unlistenByKey(this.viewChangeListenerKey_);
      this.viewChangeListenerKey_ = null;
    }
    const view = this.getView();
    if (view) {
      this.updateViewportSize_(this.getSize());
      this.viewPropertyListenerKey_ = listen(
        view,
        ObjectEventType_default.PROPERTYCHANGE,
        this.handleViewPropertyChanged_,
        this
      );
      this.viewChangeListenerKey_ = listen(
        view,
        EventType_default.CHANGE,
        this.handleViewPropertyChanged_,
        this
      );
      view.resolveConstraints(0);
    }
    this.render();
  }
  /**
   * @private
   */
  handleLayerGroupChanged_() {
    if (this.layerGroupPropertyListenerKeys_) {
      this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);
      this.layerGroupPropertyListenerKeys_ = null;
    }
    const layerGroup = this.getLayerGroup();
    if (layerGroup) {
      this.handleLayerAdd_(new GroupEvent("addlayer", layerGroup));
      this.layerGroupPropertyListenerKeys_ = [
        listen(layerGroup, ObjectEventType_default.PROPERTYCHANGE, this.render, this),
        listen(layerGroup, EventType_default.CHANGE, this.render, this),
        listen(layerGroup, "addlayer", this.handleLayerAdd_, this),
        listen(layerGroup, "removelayer", this.handleLayerRemove_, this)
      ];
    }
    this.render();
  }
  /**
   * @return {boolean} Is rendered.
   */
  isRendered() {
    return !!this.frameState_;
  }
  /**
   * @private
   */
  animationDelay_() {
    this.animationDelayKey_ = void 0;
    this.renderFrame_(Date.now());
  }
  /**
   * Requests an immediate render in a synchronous manner.
   * @api
   */
  renderSync() {
    if (this.animationDelayKey_) {
      cancelAnimationFrame(this.animationDelayKey_);
    }
    this.animationDelay_();
  }
  /**
   * Redraws all text after new fonts have loaded
   */
  redrawText() {
    const layerStates = this.getLayerGroup().getLayerStatesArray();
    for (let i = 0, ii = layerStates.length; i < ii; ++i) {
      const layer = layerStates[i].layer;
      if (layer.hasRenderer()) {
        layer.getRenderer().handleFontsChanged();
      }
    }
  }
  /**
   * Request a map rendering (at the next animation frame).
   * @api
   */
  render() {
    if (this.renderer_ && this.animationDelayKey_ === void 0) {
      this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
    }
  }
  /**
   * This method is meant to be called in a layer's `prerender` listener. It causes all collected
   * declutter items to be decluttered and rendered on the map immediately. This is useful for
   * layers that need to appear entirely above the decluttered items of layers lower in the layer
   * stack.
   * @api
   */
  flushDeclutterItems() {
    const frameState = this.frameState_;
    if (!frameState) {
      return;
    }
    this.renderer_.flushDeclutterItems(frameState);
  }
  /**
   * Remove the given control from the map.
   * @param {import("./control/Control.js").default} control Control.
   * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
   *     if the control was not found).
   * @api
   */
  removeControl(control) {
    return this.getControls().remove(control);
  }
  /**
   * Remove the given interaction from the map.
   * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
   * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
   *     undefined if the interaction was not found).
   * @api
   */
  removeInteraction(interaction) {
    return this.getInteractions().remove(interaction);
  }
  /**
   * Removes the given layer from the map.
   * @param {import("./layer/Base.js").default} layer Layer.
   * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
   *     layer was not found).
   * @api
   */
  removeLayer(layer) {
    const layers = this.getLayerGroup().getLayers();
    return layers.remove(layer);
  }
  /**
   * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
   * @private
   */
  handleLayerRemove_(event) {
    removeLayerMapProperty(event.layer);
  }
  /**
   * Remove the given overlay from the map.
   * @param {import("./Overlay.js").default} overlay Overlay.
   * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
   *     if the overlay was not found).
   * @api
   */
  removeOverlay(overlay) {
    return this.getOverlays().remove(overlay);
  }
  /**
   * @param {number} time Time.
   * @private
   */
  renderFrame_(time) {
    const size = this.getSize();
    const view = this.getView();
    const previousFrameState = this.frameState_;
    let frameState = null;
    if (size !== void 0 && hasArea(size) && view && view.isDef()) {
      const viewHints = view.getHints(
        this.frameState_ ? this.frameState_.viewHints : void 0
      );
      const viewState = view.getState();
      frameState = {
        animate: false,
        coordinateToPixelTransform: this.coordinateToPixelTransform_,
        declutterTree: null,
        extent: getForViewAndSize(
          viewState.center,
          viewState.resolution,
          viewState.rotation,
          size
        ),
        index: this.frameIndex_++,
        layerIndex: 0,
        layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
        pixelRatio: this.pixelRatio_,
        pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
        postRenderFunctions: [],
        size,
        tileQueue: this.tileQueue_,
        time,
        usedTiles: {},
        viewState,
        viewHints,
        wantedTiles: {},
        mapId: getUid(this),
        renderTargets: {}
      };
      if (viewState.nextCenter && viewState.nextResolution) {
        const rotation = isNaN(viewState.nextRotation) ? viewState.rotation : viewState.nextRotation;
        frameState.nextExtent = getForViewAndSize(
          viewState.nextCenter,
          viewState.nextResolution,
          rotation,
          size
        );
      }
    }
    this.frameState_ = frameState;
    this.renderer_.renderFrame(frameState);
    if (frameState) {
      if (frameState.animate) {
        this.render();
      }
      Array.prototype.push.apply(
        this.postRenderFunctions_,
        frameState.postRenderFunctions
      );
      if (previousFrameState) {
        const moveStart = !this.previousExtent_ || !isEmpty2(this.previousExtent_) && !equals2(frameState.extent, this.previousExtent_);
        if (moveStart) {
          this.dispatchEvent(
            new MapEvent_default(MapEventType_default.MOVESTART, this, previousFrameState)
          );
          this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);
        }
      }
      const idle = this.previousExtent_ && !frameState.viewHints[ViewHint_default.ANIMATING] && !frameState.viewHints[ViewHint_default.INTERACTING] && !equals2(frameState.extent, this.previousExtent_);
      if (idle) {
        this.dispatchEvent(
          new MapEvent_default(MapEventType_default.MOVEEND, this, frameState)
        );
        clone(frameState.extent, this.previousExtent_);
      }
    }
    this.dispatchEvent(new MapEvent_default(MapEventType_default.POSTRENDER, this, frameState));
    this.renderComplete_ = this.hasListener(MapEventType_default.LOADSTART) || this.hasListener(MapEventType_default.LOADEND) || this.hasListener(EventType_default2.RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : void 0;
    if (!this.postRenderTimeoutHandle_) {
      this.postRenderTimeoutHandle_ = setTimeout(() => {
        this.postRenderTimeoutHandle_ = void 0;
        this.handlePostRender();
      }, 0);
    }
  }
  /**
   * Sets the layergroup of this map.
   * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
   * @observable
   * @api
   */
  setLayerGroup(layerGroup) {
    const oldLayerGroup = this.getLayerGroup();
    if (oldLayerGroup) {
      this.handleLayerRemove_(new GroupEvent("removelayer", oldLayerGroup));
    }
    this.set(MapProperty_default.LAYERGROUP, layerGroup);
  }
  /**
   * Set the size of this map.
   * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
   * @observable
   * @api
   */
  setSize(size) {
    this.set(MapProperty_default.SIZE, size);
  }
  /**
   * Set the target element to render this map into.
   * @param {HTMLElement|string} [target] The Element or id of the Element
   *     that the map is rendered in.
   * @observable
   * @api
   */
  setTarget(target) {
    this.set(MapProperty_default.TARGET, target);
  }
  /**
   * Set the view for this map.
   * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
   * It is also possible to pass a promise that resolves to options for constructing a view.  This
   * alternative allows view properties to be resolved by sources or other components that load
   * view-related metadata.
   * @observable
   * @api
   */
  setView(view) {
    if (!view || view instanceof View_default) {
      this.set(MapProperty_default.VIEW, view);
      return;
    }
    this.set(MapProperty_default.VIEW, new View_default());
    const map = this;
    view.then(function(viewOptions) {
      map.setView(new View_default(viewOptions));
    });
  }
  /**
   * Force a recalculation of the map viewport size.  This should be called when
   * third-party code changes the size of the map viewport.
   * @api
   */
  updateSize() {
    const targetElement = this.getTargetElement();
    let size = void 0;
    if (targetElement) {
      const computedStyle = getComputedStyle(targetElement);
      const width = targetElement.offsetWidth - parseFloat(computedStyle["borderLeftWidth"]) - parseFloat(computedStyle["paddingLeft"]) - parseFloat(computedStyle["paddingRight"]) - parseFloat(computedStyle["borderRightWidth"]);
      const height = targetElement.offsetHeight - parseFloat(computedStyle["borderTopWidth"]) - parseFloat(computedStyle["paddingTop"]) - parseFloat(computedStyle["paddingBottom"]) - parseFloat(computedStyle["borderBottomWidth"]);
      if (!isNaN(width) && !isNaN(height)) {
        size = [width, height];
        if (!hasArea(size) && !!(targetElement.offsetWidth || targetElement.offsetHeight || targetElement.getClientRects().length)) {
          warn(
            "No map visible because the map container's width or height are 0."
          );
        }
      }
    }
    const oldSize = this.getSize();
    if (size && (!oldSize || !equals(size, oldSize))) {
      this.setSize(size);
      this.updateViewportSize_(size);
    }
  }
  /**
   * Recomputes the viewport size and save it on the view object (if any)
   * @param {import("./size.js").Size|undefined} size The size.
   * @private
   */
  updateViewportSize_(size) {
    const view = this.getView();
    if (view) {
      view.setViewportSize(size);
    }
  }
};
function createOptionsInternal(options) {
  let keyboardEventTarget = null;
  if (options.keyboardEventTarget !== void 0) {
    keyboardEventTarget = typeof options.keyboardEventTarget === "string" ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
  }
  const values = {};
  const layerGroup = options.layers && typeof /** @type {?} */
  options.layers.getLayers === "function" ? (
    /** @type {LayerGroup} */
    options.layers
  ) : new Group_default({
    layers: (
      /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */
      options.layers
    )
  });
  values[MapProperty_default.LAYERGROUP] = layerGroup;
  values[MapProperty_default.TARGET] = options.target;
  values[MapProperty_default.VIEW] = options.view instanceof View_default ? options.view : new View_default();
  let controls;
  if (options.controls !== void 0) {
    if (Array.isArray(options.controls)) {
      controls = new Collection_default(options.controls.slice());
    } else {
      assert(
        typeof /** @type {?} */
        options.controls.getArray === "function",
        "Expected `controls` to be an array or an `ol/Collection.js`"
      );
      controls = options.controls;
    }
  }
  let interactions;
  if (options.interactions !== void 0) {
    if (Array.isArray(options.interactions)) {
      interactions = new Collection_default(options.interactions.slice());
    } else {
      assert(
        typeof /** @type {?} */
        options.interactions.getArray === "function",
        "Expected `interactions` to be an array or an `ol/Collection.js`"
      );
      interactions = options.interactions;
    }
  }
  let overlays;
  if (options.overlays !== void 0) {
    if (Array.isArray(options.overlays)) {
      overlays = new Collection_default(options.overlays.slice());
    } else {
      assert(
        typeof /** @type {?} */
        options.overlays.getArray === "function",
        "Expected `overlays` to be an array or an `ol/Collection.js`"
      );
      overlays = options.overlays;
    }
  } else {
    overlays = new Collection_default();
  }
  return {
    controls,
    interactions,
    keyboardEventTarget,
    overlays,
    values
  };
}
var Map_default2 = Map;

// node_modules/ol/control/MousePosition.js
init_Control();
init_proj();
init_events();
init_coordinate();
var PROJECTION = "projection";
var COORDINATE_FORMAT = "coordinateFormat";
var MousePosition = class extends Control_default {
  /**
   * @param {Options} [options] Mouse position options.
   */
  constructor(options) {
    options = options ? options : {};
    const element = document.createElement("div");
    element.className = options.className !== void 0 ? options.className : "ol-mouse-position";
    super({
      element,
      render: options.render,
      target: options.target
    });
    this.on;
    this.once;
    this.un;
    this.addChangeListener(PROJECTION, this.handleProjectionChanged_);
    if (options.coordinateFormat) {
      this.setCoordinateFormat(options.coordinateFormat);
    }
    if (options.projection) {
      this.setProjection(options.projection);
    }
    this.renderOnMouseOut_ = options.placeholder !== void 0;
    this.placeholder_ = this.renderOnMouseOut_ ? options.placeholder : "&#160;";
    this.renderedHTML_ = element.innerHTML;
    this.mapProjection_ = null;
    this.transform_ = null;
    this.wrapX_ = options.wrapX === false ? false : true;
  }
  /**
   * @private
   */
  handleProjectionChanged_() {
    this.transform_ = null;
  }
  /**
   * Return the coordinate format type used to render the current position or
   * undefined.
   * @return {import("../coordinate.js").CoordinateFormat|undefined} The format to render the current
   *     position in.
   * @observable
   * @api
   */
  getCoordinateFormat() {
    return (
      /** @type {import("../coordinate.js").CoordinateFormat|undefined} */
      this.get(COORDINATE_FORMAT)
    );
  }
  /**
   * Return the projection that is used to report the mouse position.
   * @return {import("../proj/Projection.js").default|undefined} The projection to report mouse
   *     position in.
   * @observable
   * @api
   */
  getProjection() {
    return (
      /** @type {import("../proj/Projection.js").default|undefined} */
      this.get(PROJECTION)
    );
  }
  /**
   * @param {MouseEvent} event Browser event.
   * @protected
   */
  handleMouseMove(event) {
    const map = this.getMap();
    this.updateHTML_(map.getEventPixel(event));
  }
  /**
   * @param {Event} event Browser event.
   * @protected
   */
  handleMouseOut(event) {
    this.updateHTML_(null);
  }
  /**
   * Remove the control from its current map and attach it to the new map.
   * Pass `null` to just remove the control from the current map.
   * Subclasses may set up event handlers to get notified about changes to
   * the map here.
   * @param {import("../Map.js").default|null} map Map.
   * @api
   */
  setMap(map) {
    super.setMap(map);
    if (map) {
      const viewport = map.getViewport();
      this.listenerKeys.push(
        listen(viewport, EventType_default3.POINTERMOVE, this.handleMouseMove, this)
      );
      if (this.renderOnMouseOut_) {
        this.listenerKeys.push(
          listen(viewport, EventType_default3.POINTEROUT, this.handleMouseOut, this)
        );
      }
      this.updateHTML_(null);
    }
  }
  /**
   * Set the coordinate format type used to render the current position.
   * @param {import("../coordinate.js").CoordinateFormat} format The format to render the current
   *     position in.
   * @observable
   * @api
   */
  setCoordinateFormat(format2) {
    this.set(COORDINATE_FORMAT, format2);
  }
  /**
   * Set the projection that is used to report the mouse position.
   * @param {import("../proj.js").ProjectionLike} projection The projection to report mouse
   *     position in.
   * @observable
   * @api
   */
  setProjection(projection) {
    this.set(PROJECTION, get3(projection));
  }
  /**
   * @param {?import("../pixel.js").Pixel} pixel Pixel.
   * @private
   */
  updateHTML_(pixel) {
    let html = this.placeholder_;
    if (pixel && this.mapProjection_) {
      if (!this.transform_) {
        const projection = this.getProjection();
        if (projection) {
          this.transform_ = getTransformFromProjections(
            this.mapProjection_,
            projection
          );
        } else {
          this.transform_ = identityTransform;
        }
      }
      const map = this.getMap();
      const coordinate = map.getCoordinateFromPixelInternal(pixel);
      if (coordinate) {
        const userProjection2 = getUserProjection();
        if (userProjection2) {
          this.transform_ = getTransformFromProjections(
            this.mapProjection_,
            userProjection2
          );
        }
        this.transform_(coordinate, coordinate);
        if (this.wrapX_) {
          const projection = userProjection2 || this.getProjection() || this.mapProjection_;
          wrapX2(coordinate, projection);
        }
        const coordinateFormat = this.getCoordinateFormat();
        if (coordinateFormat) {
          html = coordinateFormat(coordinate);
        } else {
          html = coordinate.toString();
        }
      }
    }
    if (!this.renderedHTML_ || html !== this.renderedHTML_) {
      this.element.innerHTML = html;
      this.renderedHTML_ = html;
    }
  }
  /**
   * Update the projection. Rendering of the coordinates is done in
   * `handleMouseMove` and `handleMouseUp`.
   * @param {import("../MapEvent.js").default} mapEvent Map event.
   * @override
   */
  render(mapEvent) {
    const frameState = mapEvent.frameState;
    if (!frameState) {
      this.mapProjection_ = null;
    } else {
      if (this.mapProjection_ != frameState.viewState.projection) {
        this.mapProjection_ = frameState.viewState.projection;
        this.transform_ = null;
      }
    }
  }
};
var MousePosition_default = MousePosition;

// node_modules/ol/Tile.js
init_Target();
init_EventType();
init_util();
init_easing();
var Tile = class extends Target_default {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {Options} [options] Tile options.
   */
  constructor(tileCoord, state, options) {
    super();
    options = options ? options : {};
    this.tileCoord = tileCoord;
    this.state = state;
    this.interimTile = null;
    this.key = "";
    this.transition_ = options.transition === void 0 ? 250 : options.transition;
    this.transitionStarts_ = {};
    this.interpolate = !!options.interpolate;
  }
  /**
   * @protected
   */
  changed() {
    this.dispatchEvent(EventType_default.CHANGE);
  }
  /**
   * Called by the tile cache when the tile is removed from the cache due to expiry
   */
  release() {
    if (this.state === TileState_default.ERROR) {
      this.setState(TileState_default.EMPTY);
    }
  }
  /**
   * @return {string} Key.
   */
  getKey() {
    return this.key + "/" + this.tileCoord;
  }
  /**
   * Get the interim tile most suitable for rendering using the chain of interim
   * tiles. This corresponds to the  most recent tile that has been loaded, if no
   * such tile exists, the original tile is returned.
   * @return {!Tile} Best tile for rendering.
   */
  getInterimTile() {
    let tile2 = this.interimTile;
    if (!tile2) {
      return this;
    }
    do {
      if (tile2.getState() == TileState_default.LOADED) {
        this.transition_ = 0;
        return tile2;
      }
      tile2 = tile2.interimTile;
    } while (tile2);
    return this;
  }
  /**
   * Goes through the chain of interim tiles and discards sections of the chain
   * that are no longer relevant.
   */
  refreshInterimChain() {
    let tile2 = this.interimTile;
    if (!tile2) {
      return;
    }
    let prev = this;
    do {
      if (tile2.getState() == TileState_default.LOADED) {
        tile2.interimTile = null;
        break;
      }
      if (tile2.getState() == TileState_default.LOADING) {
        prev = tile2;
      } else if (tile2.getState() == TileState_default.IDLE) {
        prev.interimTile = tile2.interimTile;
      } else {
        prev = tile2;
      }
      tile2 = prev.interimTile;
    } while (tile2);
  }
  /**
   * Get the tile coordinate for this tile.
   * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
   * @api
   */
  getTileCoord() {
    return this.tileCoord;
  }
  /**
   * @return {import("./TileState.js").default} State.
   */
  getState() {
    return this.state;
  }
  /**
   * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
   * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
   * when the tile cannot be loaded. Otherwise the tile cannot be removed from
   * the tile queue and will block other requests.
   * @param {import("./TileState.js").default} state State.
   * @api
   */
  setState(state) {
    if (this.state !== TileState_default.ERROR && this.state > state) {
      throw new Error("Tile load sequence violation");
    }
    this.state = state;
    this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   * @abstract
   * @api
   */
  load() {
    abstract();
  }
  /**
   * Get the alpha value for rendering.
   * @param {string} id An id for the renderer.
   * @param {number} time The render frame time.
   * @return {number} A number between 0 and 1.
   */
  getAlpha(id, time) {
    if (!this.transition_) {
      return 1;
    }
    let start = this.transitionStarts_[id];
    if (!start) {
      start = time;
      this.transitionStarts_[id] = start;
    } else if (start === -1) {
      return 1;
    }
    const delta = time - start + 1e3 / 60;
    if (delta >= this.transition_) {
      return 1;
    }
    return easeIn(delta / this.transition_);
  }
  /**
   * Determine if a tile is in an alpha transition.  A tile is considered in
   * transition if tile.getAlpha() has not yet been called or has been called
   * and returned 1.
   * @param {string} id An id for the renderer.
   * @return {boolean} The tile is in transition.
   */
  inTransition(id) {
    if (!this.transition_) {
      return false;
    }
    return this.transitionStarts_[id] !== -1;
  }
  /**
   * Mark a transition as complete.
   * @param {string} id An id for the renderer.
   */
  endTransition(id) {
    if (this.transition_) {
      this.transitionStarts_[id] = -1;
    }
  }
};
var Tile_default = Tile;

// node_modules/ol/ImageTile.js
init_dom();
init_Image();
var ImageTile = class extends Tile_default {
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./TileState.js").default} state State.
   * @param {string} src Image source URI.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @param {import("./Tile.js").Options} [options] Tile options.
   */
  constructor(tileCoord, state, src, crossOrigin, tileLoadFunction, options) {
    super(tileCoord, state, options);
    this.crossOrigin_ = crossOrigin;
    this.src_ = src;
    this.key = src;
    this.image_ = new Image();
    if (crossOrigin !== null) {
      this.image_.crossOrigin = crossOrigin;
    }
    this.unlisten_ = null;
    this.tileLoadFunction_ = tileLoadFunction;
  }
  /**
   * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @api
   */
  getImage() {
    return this.image_;
  }
  /**
   * Sets an HTML image element for this tile (may be a Canvas or preloaded Image).
   * @param {HTMLCanvasElement|HTMLImageElement} element Element.
   */
  setImage(element) {
    this.image_ = element;
    this.state = TileState_default.LOADED;
    this.unlistenImage_();
    this.changed();
  }
  /**
   * Tracks loading or read errors.
   *
   * @private
   */
  handleImageError_() {
    this.state = TileState_default.ERROR;
    this.unlistenImage_();
    this.image_ = getBlankImage();
    this.changed();
  }
  /**
   * Tracks successful image load.
   *
   * @private
   */
  handleImageLoad_() {
    const image = (
      /** @type {HTMLImageElement} */
      this.image_
    );
    if (image.naturalWidth && image.naturalHeight) {
      this.state = TileState_default.LOADED;
    } else {
      this.state = TileState_default.EMPTY;
    }
    this.unlistenImage_();
    this.changed();
  }
  /**
   * Load the image or retry if loading previously failed.
   * Loading is taken care of by the tile queue, and calling this method is
   * only needed for preloading or for reloading in case of an error.
   *
   * To retry loading tiles on failed requests, use a custom `tileLoadFunction`
   * that checks for error status codes and reloads only when the status code is
   * 408, 429, 500, 502, 503 and 504, and only when not too many retries have been
   * made already:
   *
   * ```js
   * const retryCodes = [408, 429, 500, 502, 503, 504];
   * const retries = {};
   * source.setTileLoadFunction((tile, src) => {
   *   const image = tile.getImage();
   *   fetch(src)
   *     .then((response) => {
   *       if (retryCodes.includes(response.status)) {
   *         retries[src] = (retries[src] || 0) + 1;
   *         if (retries[src] <= 3) {
   *           setTimeout(() => tile.load(), retries[src] * 1000);
   *         }
   *         return Promise.reject();
   *       }
   *       return response.blob();
   *     })
   *     .then((blob) => {
   *       const imageUrl = URL.createObjectURL(blob);
   *       image.src = imageUrl;
   *       setTimeout(() => URL.revokeObjectURL(imageUrl), 5000);
   *     })
   *     .catch(() => tile.setState(3)); // error
   * });
   * ```
   *
   * @api
   */
  load() {
    if (this.state == TileState_default.ERROR) {
      this.state = TileState_default.IDLE;
      this.image_ = new Image();
      if (this.crossOrigin_ !== null) {
        this.image_.crossOrigin = this.crossOrigin_;
      }
    }
    if (this.state == TileState_default.IDLE) {
      this.state = TileState_default.LOADING;
      this.changed();
      this.tileLoadFunction_(this, this.src_);
      this.unlisten_ = listenImage(
        this.image_,
        this.handleImageLoad_.bind(this),
        this.handleImageError_.bind(this)
      );
    }
  }
  /**
   * Discards event handlers which listen for load completion or errors.
   *
   * @private
   */
  unlistenImage_() {
    if (this.unlisten_) {
      this.unlisten_();
      this.unlisten_ = null;
    }
  }
};
function getBlankImage() {
  const ctx = createCanvasContext2D(1, 1);
  ctx.fillStyle = "rgba(0,0,0,0)";
  ctx.fillRect(0, 0, 1, 1);
  return ctx.canvas;
}
var ImageTile_default = ImageTile;

// node_modules/ol/reproj/common.js
var ERROR_THRESHOLD = 0.5;

// node_modules/ol/reproj/Triangulation.js
init_extent();
init_proj();
init_math();
var MAX_SUBDIVISION = 10;
var MAX_TRIANGLE_WIDTH = 0.25;
var Triangulation = class {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
   * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
   * @param {number} errorThreshold Acceptable error (in source units).
   * @param {?number} destinationResolution The (optional) resolution of the destination.
   */
  constructor(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, destinationResolution) {
    this.sourceProj_ = sourceProj;
    this.targetProj_ = targetProj;
    let transformInvCache = {};
    const transformInv = getTransform(this.targetProj_, this.sourceProj_);
    this.transformInv_ = function(c) {
      const key = c[0] + "/" + c[1];
      if (!transformInvCache[key]) {
        transformInvCache[key] = transformInv(c);
      }
      return transformInvCache[key];
    };
    this.maxSourceExtent_ = maxSourceExtent;
    this.errorThresholdSquared_ = errorThreshold * errorThreshold;
    this.triangles_ = [];
    this.wrapsXInSource_ = false;
    this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!maxSourceExtent && !!this.sourceProj_.getExtent() && getWidth(maxSourceExtent) >= getWidth(this.sourceProj_.getExtent());
    this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null;
    this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;
    const destinationTopLeft = getTopLeft(targetExtent);
    const destinationTopRight = getTopRight(targetExtent);
    const destinationBottomRight = getBottomRight(targetExtent);
    const destinationBottomLeft = getBottomLeft(targetExtent);
    const sourceTopLeft = this.transformInv_(destinationTopLeft);
    const sourceTopRight = this.transformInv_(destinationTopRight);
    const sourceBottomRight = this.transformInv_(destinationBottomRight);
    const sourceBottomLeft = this.transformInv_(destinationBottomLeft);
    const maxSubdivision = MAX_SUBDIVISION + (destinationResolution ? Math.max(
      0,
      Math.ceil(
        Math.log2(
          getArea(targetExtent) / (destinationResolution * destinationResolution * 256 * 256)
        )
      )
    ) : 0);
    this.addQuad_(
      destinationTopLeft,
      destinationTopRight,
      destinationBottomRight,
      destinationBottomLeft,
      sourceTopLeft,
      sourceTopRight,
      sourceBottomRight,
      sourceBottomLeft,
      maxSubdivision
    );
    if (this.wrapsXInSource_) {
      let leftBound = Infinity;
      this.triangles_.forEach(function(triangle, i, arr) {
        leftBound = Math.min(
          leftBound,
          triangle.source[0][0],
          triangle.source[1][0],
          triangle.source[2][0]
        );
      });
      this.triangles_.forEach((triangle) => {
        if (Math.max(
          triangle.source[0][0],
          triangle.source[1][0],
          triangle.source[2][0]
        ) - leftBound > this.sourceWorldWidth_ / 2) {
          const newTriangle = [
            [triangle.source[0][0], triangle.source[0][1]],
            [triangle.source[1][0], triangle.source[1][1]],
            [triangle.source[2][0], triangle.source[2][1]]
          ];
          if (newTriangle[0][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[0][0] -= this.sourceWorldWidth_;
          }
          if (newTriangle[1][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[1][0] -= this.sourceWorldWidth_;
          }
          if (newTriangle[2][0] - leftBound > this.sourceWorldWidth_ / 2) {
            newTriangle[2][0] -= this.sourceWorldWidth_;
          }
          const minX = Math.min(
            newTriangle[0][0],
            newTriangle[1][0],
            newTriangle[2][0]
          );
          const maxX = Math.max(
            newTriangle[0][0],
            newTriangle[1][0],
            newTriangle[2][0]
          );
          if (maxX - minX < this.sourceWorldWidth_ / 2) {
            triangle.source = newTriangle;
          }
        }
      });
    }
    transformInvCache = {};
  }
  /**
   * Adds triangle to the triangulation.
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @private
   */
  addTriangle_(a, b, c, aSrc, bSrc, cSrc) {
    this.triangles_.push({
      source: [aSrc, bSrc, cSrc],
      target: [a, b, c]
    });
  }
  /**
   * Adds quad (points in clock-wise order) to the triangulation
   * (and reprojects the vertices) if valid.
   * Performs quad subdivision if needed to increase precision.
   *
   * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
   * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
   * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
   * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
   * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
   * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
   * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
   * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
   * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
   * @private
   */
  addQuad_(a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
    const sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);
    const sourceCoverageX = this.sourceWorldWidth_ ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;
    const sourceWorldWidth = (
      /** @type {number} */
      this.sourceWorldWidth_
    );
    const wrapsX = this.sourceProj_.canWrapX() && sourceCoverageX > 0.5 && sourceCoverageX < 1;
    let needsSubdivision = false;
    if (maxSubdivision > 0) {
      if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
        const targetQuadExtent = boundingExtent([a, b, c, d]);
        const targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;
        needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
      if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
        needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
      }
    }
    if (!needsSubdivision && this.maxSourceExtent_) {
      if (isFinite(sourceQuadExtent[0]) && isFinite(sourceQuadExtent[1]) && isFinite(sourceQuadExtent[2]) && isFinite(sourceQuadExtent[3])) {
        if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {
          return;
        }
      }
    }
    let isNotFinite = 0;
    if (!needsSubdivision) {
      if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) || !isFinite(bSrc[0]) || !isFinite(bSrc[1]) || !isFinite(cSrc[0]) || !isFinite(cSrc[1]) || !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {
        if (maxSubdivision > 0) {
          needsSubdivision = true;
        } else {
          isNotFinite = (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) + (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) + (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) + (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);
          if (isNotFinite != 1 && isNotFinite != 2 && isNotFinite != 4 && isNotFinite != 8) {
            return;
          }
        }
      }
    }
    if (maxSubdivision > 0) {
      if (!needsSubdivision) {
        const center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
        const centerSrc = this.transformInv_(center);
        let dx;
        if (wrapsX) {
          const centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) + modulo(cSrc[0], sourceWorldWidth)) / 2;
          dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);
        } else {
          dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
        }
        const dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
        const centerSrcErrorSquared = dx * dx + dy * dy;
        needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
      }
      if (needsSubdivision) {
        if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
          const bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
          const bcSrc = this.transformInv_(bc);
          const da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
          const daSrc = this.transformInv_(da);
          this.addQuad_(
            a,
            b,
            bc,
            da,
            aSrc,
            bSrc,
            bcSrc,
            daSrc,
            maxSubdivision - 1
          );
          this.addQuad_(
            da,
            bc,
            c,
            d,
            daSrc,
            bcSrc,
            cSrc,
            dSrc,
            maxSubdivision - 1
          );
        } else {
          const ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
          const abSrc = this.transformInv_(ab);
          const cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
          const cdSrc = this.transformInv_(cd);
          this.addQuad_(
            a,
            ab,
            cd,
            d,
            aSrc,
            abSrc,
            cdSrc,
            dSrc,
            maxSubdivision - 1
          );
          this.addQuad_(
            ab,
            b,
            c,
            cd,
            abSrc,
            bSrc,
            cSrc,
            cdSrc,
            maxSubdivision - 1
          );
        }
        return;
      }
    }
    if (wrapsX) {
      if (!this.canWrapXInSource_) {
        return;
      }
      this.wrapsXInSource_ = true;
    }
    if ((isNotFinite & 11) == 0) {
      this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
    }
    if ((isNotFinite & 14) == 0) {
      this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
    }
    if (isNotFinite) {
      if ((isNotFinite & 13) == 0) {
        this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
      }
      if ((isNotFinite & 7) == 0) {
        this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);
      }
    }
  }
  /**
   * Calculates extent of the `source` coordinates from all the triangles.
   *
   * @return {import("../extent.js").Extent} Calculated extent.
   */
  calculateSourceExtent() {
    const extent = createEmpty();
    this.triangles_.forEach(function(triangle, i, arr) {
      const src = triangle.source;
      extendCoordinate(extent, src[0]);
      extendCoordinate(extent, src[1]);
      extendCoordinate(extent, src[2]);
    });
    return extent;
  }
  /**
   * @return {Array<Triangle>} Array of the calculated triangles.
   */
  getTriangles() {
    return this.triangles_;
  }
};
var Triangulation_default = Triangulation;

// node_modules/ol/reproj.js
init_extent();
init_dom();
init_proj();
init_math();
var brokenDiagonalRendering_;
var canvasPool = [];
function drawTestTriangle(ctx, u1, v1, u2, v2) {
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.lineTo(u1, v1);
  ctx.lineTo(u2, v2);
  ctx.closePath();
  ctx.save();
  ctx.clip();
  ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
  ctx.restore();
}
function verifyBrokenDiagonalRendering(data, offset2) {
  return Math.abs(data[offset2 * 4] - 210) > 2 || Math.abs(data[offset2 * 4 + 3] - 0.75 * 255) > 2;
}
function isBrokenDiagonalRendering() {
  if (brokenDiagonalRendering_ === void 0) {
    const ctx = createCanvasContext2D(6, 6, canvasPool);
    ctx.globalCompositeOperation = "lighter";
    ctx.fillStyle = "rgba(210, 0, 0, 0.75)";
    drawTestTriangle(ctx, 4, 5, 4, 0);
    drawTestTriangle(ctx, 4, 5, 0, 5);
    const data = ctx.getImageData(0, 0, 3, 3).data;
    brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(data, 0) || verifyBrokenDiagonalRendering(data, 4) || verifyBrokenDiagonalRendering(data, 8);
    releaseCanvas(ctx);
    canvasPool.push(ctx.canvas);
  }
  return brokenDiagonalRendering_;
}
function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
  const sourceCenter = transform(targetCenter, targetProj, sourceProj);
  let sourceResolution = getPointResolution(
    targetProj,
    targetResolution,
    targetCenter
  );
  const targetMetersPerUnit = targetProj.getMetersPerUnit();
  if (targetMetersPerUnit !== void 0) {
    sourceResolution *= targetMetersPerUnit;
  }
  const sourceMetersPerUnit = sourceProj.getMetersPerUnit();
  if (sourceMetersPerUnit !== void 0) {
    sourceResolution /= sourceMetersPerUnit;
  }
  const sourceExtent = sourceProj.getExtent();
  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {
    const compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) / sourceResolution;
    if (isFinite(compensationFactor) && compensationFactor > 0) {
      sourceResolution /= compensationFactor;
    }
  }
  return sourceResolution;
}
function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
  const targetCenter = getCenter(targetExtent);
  let sourceResolution = calculateSourceResolution(
    sourceProj,
    targetProj,
    targetCenter,
    targetResolution
  );
  if (!isFinite(sourceResolution) || sourceResolution <= 0) {
    forEachCorner(targetExtent, function(corner) {
      sourceResolution = calculateSourceResolution(
        sourceProj,
        targetProj,
        corner,
        targetResolution
      );
      return isFinite(sourceResolution) && sourceResolution > 0;
    });
  }
  return sourceResolution;
}
function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, renderEdges, interpolate, drawSingle) {
  const context = createCanvasContext2D(
    Math.round(pixelRatio * width),
    Math.round(pixelRatio * height),
    canvasPool
  );
  if (!interpolate) {
    context.imageSmoothingEnabled = false;
  }
  if (sources.length === 0) {
    return context.canvas;
  }
  context.scale(pixelRatio, pixelRatio);
  function pixelRound(value) {
    return Math.round(value * pixelRatio) / pixelRatio;
  }
  context.globalCompositeOperation = "lighter";
  const sourceDataExtent = createEmpty();
  sources.forEach(function(src, i, arr) {
    extend2(sourceDataExtent, src.extent);
  });
  let stitchContext;
  if (!drawSingle || sources.length !== 1 || gutter !== 0) {
    const canvasWidthInUnits = getWidth(sourceDataExtent);
    const canvasHeightInUnits = getHeight(sourceDataExtent);
    stitchContext = createCanvasContext2D(
      Math.round(pixelRatio * canvasWidthInUnits / sourceResolution),
      Math.round(pixelRatio * canvasHeightInUnits / sourceResolution),
      canvasPool
    );
    if (!interpolate) {
      stitchContext.imageSmoothingEnabled = false;
    }
    const stitchScale = pixelRatio / sourceResolution;
    sources.forEach(function(src, i, arr) {
      const xPos = src.extent[0] - sourceDataExtent[0];
      const yPos = -(src.extent[3] - sourceDataExtent[3]);
      const srcWidth = getWidth(src.extent);
      const srcHeight = getHeight(src.extent);
      if (src.image.width > 0 && src.image.height > 0) {
        stitchContext.drawImage(
          src.image,
          gutter,
          gutter,
          src.image.width - 2 * gutter,
          src.image.height - 2 * gutter,
          xPos * stitchScale,
          yPos * stitchScale,
          srcWidth * stitchScale,
          srcHeight * stitchScale
        );
      }
    });
  }
  const targetTopLeft = getTopLeft(targetExtent);
  triangulation.getTriangles().forEach(function(triangle, i, arr) {
    const source = triangle.source;
    const target = triangle.target;
    let x0 = source[0][0], y0 = source[0][1];
    let x1 = source[1][0], y1 = source[1][1];
    let x2 = source[2][0], y2 = source[2][1];
    const u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
    const v0 = pixelRound(
      -(target[0][1] - targetTopLeft[1]) / targetResolution
    );
    const u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
    const v1 = pixelRound(
      -(target[1][1] - targetTopLeft[1]) / targetResolution
    );
    const u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
    const v2 = pixelRound(
      -(target[2][1] - targetTopLeft[1]) / targetResolution
    );
    const sourceNumericalShiftX = x0;
    const sourceNumericalShiftY = y0;
    x0 = 0;
    y0 = 0;
    x1 -= sourceNumericalShiftX;
    y1 -= sourceNumericalShiftY;
    x2 -= sourceNumericalShiftX;
    y2 -= sourceNumericalShiftY;
    const augmentedMatrix = [
      [x1, y1, 0, 0, u1 - u0],
      [x2, y2, 0, 0, u2 - u0],
      [0, 0, x1, y1, v1 - v0],
      [0, 0, x2, y2, v2 - v0]
    ];
    const affineCoefs = solveLinearSystem(augmentedMatrix);
    if (!affineCoefs) {
      return;
    }
    context.save();
    context.beginPath();
    if (isBrokenDiagonalRendering() || !interpolate) {
      context.moveTo(u1, v1);
      const steps = 4;
      const ud = u0 - u1;
      const vd = v0 - v1;
      for (let step = 0; step < steps; step++) {
        context.lineTo(
          u1 + pixelRound((step + 1) * ud / steps),
          v1 + pixelRound(step * vd / (steps - 1))
        );
        if (step != steps - 1) {
          context.lineTo(
            u1 + pixelRound((step + 1) * ud / steps),
            v1 + pixelRound((step + 1) * vd / (steps - 1))
          );
        }
      }
      context.lineTo(u2, v2);
    } else {
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
    }
    context.clip();
    context.transform(
      affineCoefs[0],
      affineCoefs[2],
      affineCoefs[1],
      affineCoefs[3],
      u0,
      v0
    );
    context.translate(
      sourceDataExtent[0] - sourceNumericalShiftX,
      sourceDataExtent[3] - sourceNumericalShiftY
    );
    let image;
    if (stitchContext) {
      image = stitchContext.canvas;
      context.scale(
        sourceResolution / pixelRatio,
        -sourceResolution / pixelRatio
      );
    } else {
      const source2 = sources[0];
      const extent = source2.extent;
      image = source2.image;
      context.scale(
        getWidth(extent) / image.width,
        -getHeight(extent) / image.height
      );
    }
    context.drawImage(image, 0, 0);
    context.restore();
  });
  if (stitchContext) {
    releaseCanvas(stitchContext);
    canvasPool.push(stitchContext.canvas);
  }
  if (renderEdges) {
    context.save();
    context.globalCompositeOperation = "source-over";
    context.strokeStyle = "black";
    context.lineWidth = 1;
    triangulation.getTriangles().forEach(function(triangle, i, arr) {
      const target = triangle.target;
      const u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
      const v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
      const u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
      const v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
      const u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
      const v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
      context.beginPath();
      context.moveTo(u1, v1);
      context.lineTo(u0, v0);
      context.lineTo(u2, v2);
      context.closePath();
      context.stroke();
    });
    context.restore();
  }
  return context.canvas;
}

// node_modules/ol/reproj/Tile.js
init_EventType();
init_math();
init_extent();
init_events();
init_dom();
var ReprojTile = class extends Tile_default {
  /**
   * @param {import("../proj/Projection.js").default} sourceProj Source projection.
   * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
   * @param {import("../proj/Projection.js").default} targetProj Target projection.
   * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
   * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} gutter Gutter of the source tiles.
   * @param {FunctionType} getTileFunction
   *     Function returning source tiles (z, x, y, pixelRatio).
   * @param {number} [errorThreshold] Acceptable reprojection error (in px).
   * @param {boolean} [renderEdges] Render reprojection edges.
   * @param {import("../Tile.js").Options} [options] Tile options.
   */
  constructor(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, errorThreshold, renderEdges, options) {
    super(tileCoord, TileState_default.IDLE, options);
    this.renderEdges_ = renderEdges !== void 0 ? renderEdges : false;
    this.pixelRatio_ = pixelRatio;
    this.gutter_ = gutter;
    this.canvas_ = null;
    this.sourceTileGrid_ = sourceTileGrid;
    this.targetTileGrid_ = targetTileGrid;
    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
    this.sourceTiles_ = [];
    this.sourcesListenerKeys_ = null;
    this.sourceZ_ = 0;
    const targetExtent = targetTileGrid.getTileCoordExtent(
      this.wrappedTileCoord_
    );
    const maxTargetExtent = this.targetTileGrid_.getExtent();
    let maxSourceExtent = this.sourceTileGrid_.getExtent();
    const limitedTargetExtent = maxTargetExtent ? getIntersection(targetExtent, maxTargetExtent) : targetExtent;
    if (getArea(limitedTargetExtent) === 0) {
      this.state = TileState_default.EMPTY;
      return;
    }
    const sourceProjExtent = sourceProj.getExtent();
    if (sourceProjExtent) {
      if (!maxSourceExtent) {
        maxSourceExtent = sourceProjExtent;
      } else {
        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);
      }
    }
    const targetResolution = targetTileGrid.getResolution(
      this.wrappedTileCoord_[0]
    );
    const sourceResolution = calculateSourceExtentResolution(
      sourceProj,
      targetProj,
      limitedTargetExtent,
      targetResolution
    );
    if (!isFinite(sourceResolution) || sourceResolution <= 0) {
      this.state = TileState_default.EMPTY;
      return;
    }
    const errorThresholdInPixels = errorThreshold !== void 0 ? errorThreshold : ERROR_THRESHOLD;
    this.triangulation_ = new Triangulation_default(
      sourceProj,
      targetProj,
      limitedTargetExtent,
      maxSourceExtent,
      sourceResolution * errorThresholdInPixels,
      targetResolution
    );
    if (this.triangulation_.getTriangles().length === 0) {
      this.state = TileState_default.EMPTY;
      return;
    }
    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
    let sourceExtent = this.triangulation_.calculateSourceExtent();
    if (maxSourceExtent) {
      if (sourceProj.canWrapX()) {
        sourceExtent[1] = clamp(
          sourceExtent[1],
          maxSourceExtent[1],
          maxSourceExtent[3]
        );
        sourceExtent[3] = clamp(
          sourceExtent[3],
          maxSourceExtent[1],
          maxSourceExtent[3]
        );
      } else {
        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);
      }
    }
    if (!getArea(sourceExtent)) {
      this.state = TileState_default.EMPTY;
    } else {
      const sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(
        sourceExtent,
        this.sourceZ_
      );
      for (let srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
        for (let srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
          const tile2 = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);
          if (tile2) {
            this.sourceTiles_.push(tile2);
          }
        }
      }
      if (this.sourceTiles_.length === 0) {
        this.state = TileState_default.EMPTY;
      }
    }
  }
  /**
   * Get the HTML Canvas element for this tile.
   * @return {HTMLCanvasElement} Canvas.
   */
  getImage() {
    return this.canvas_;
  }
  /**
   * @private
   */
  reproject_() {
    const sources = [];
    this.sourceTiles_.forEach((tile2) => {
      if (tile2 && tile2.getState() == TileState_default.LOADED) {
        sources.push({
          extent: this.sourceTileGrid_.getTileCoordExtent(tile2.tileCoord),
          image: tile2.getImage()
        });
      }
    });
    this.sourceTiles_.length = 0;
    if (sources.length === 0) {
      this.state = TileState_default.ERROR;
    } else {
      const z = this.wrappedTileCoord_[0];
      const size = this.targetTileGrid_.getTileSize(z);
      const width = typeof size === "number" ? size : size[0];
      const height = typeof size === "number" ? size : size[1];
      const targetResolution = this.targetTileGrid_.getResolution(z);
      const sourceResolution = this.sourceTileGrid_.getResolution(
        this.sourceZ_
      );
      const targetExtent = this.targetTileGrid_.getTileCoordExtent(
        this.wrappedTileCoord_
      );
      this.canvas_ = render(
        width,
        height,
        this.pixelRatio_,
        sourceResolution,
        this.sourceTileGrid_.getExtent(),
        targetResolution,
        targetExtent,
        this.triangulation_,
        sources,
        this.gutter_,
        this.renderEdges_,
        this.interpolate
      );
      this.state = TileState_default.LOADED;
    }
    this.changed();
  }
  /**
   * Load not yet loaded URI.
   */
  load() {
    if (this.state == TileState_default.IDLE) {
      this.state = TileState_default.LOADING;
      this.changed();
      let leftToLoad = 0;
      this.sourcesListenerKeys_ = [];
      this.sourceTiles_.forEach((tile2) => {
        const state = tile2.getState();
        if (state == TileState_default.IDLE || state == TileState_default.LOADING) {
          leftToLoad++;
          const sourceListenKey = listen(
            tile2,
            EventType_default.CHANGE,
            function(e) {
              const state2 = tile2.getState();
              if (state2 == TileState_default.LOADED || state2 == TileState_default.ERROR || state2 == TileState_default.EMPTY) {
                unlistenByKey(sourceListenKey);
                leftToLoad--;
                if (leftToLoad === 0) {
                  this.unlistenSources_();
                  this.reproject_();
                }
              }
            },
            this
          );
          this.sourcesListenerKeys_.push(sourceListenKey);
        }
      });
      if (leftToLoad === 0) {
        setTimeout(this.reproject_.bind(this), 0);
      } else {
        this.sourceTiles_.forEach(function(tile2, i, arr) {
          const state = tile2.getState();
          if (state == TileState_default.IDLE) {
            tile2.load();
          }
        });
      }
    }
  }
  /**
   * @private
   */
  unlistenSources_() {
    this.sourcesListenerKeys_.forEach(unlistenByKey);
    this.sourcesListenerKeys_ = null;
  }
  /**
   * Remove from the cache due to expiry
   */
  release() {
    if (this.canvas_) {
      releaseCanvas(this.canvas_.getContext("2d"));
      canvasPool.push(this.canvas_);
      this.canvas_ = null;
    }
    super.release();
  }
};
var Tile_default2 = ReprojTile;

// node_modules/ol/structs/LRUCache.js
init_asserts();
var LRUCache = class {
  /**
   * @param {number} [highWaterMark] High water mark.
   */
  constructor(highWaterMark) {
    this.highWaterMark = highWaterMark !== void 0 ? highWaterMark : 2048;
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
  }
  /**
   * Expire the cache.
   * @param {!Object<string, boolean>} [keep] Keys to keep. To be implemented by subclasses.
   */
  expireCache(keep) {
    while (this.canExpireCache()) {
      this.pop();
    }
  }
  /**
   * FIXME empty description for jsdoc
   */
  clear() {
    this.count_ = 0;
    this.entries_ = {};
    this.oldest_ = null;
    this.newest_ = null;
  }
  /**
   * @param {string} key Key.
   * @return {boolean} Contains key.
   */
  containsKey(key) {
    return this.entries_.hasOwnProperty(key);
  }
  /**
   * @param {function(T, string, LRUCache<T>): ?} f The function
   *     to call for every entry from the oldest to the newer. This function takes
   *     3 arguments (the entry value, the entry key and the LRUCache object).
   *     The return value is ignored.
   */
  forEach(f) {
    let entry = this.oldest_;
    while (entry) {
      f(entry.value_, entry.key_, this);
      entry = entry.newer;
    }
  }
  /**
   * @param {string} key Key.
   * @param {*} [options] Options (reserved for subclasses).
   * @return {T} Value.
   */
  get(key, options) {
    const entry = this.entries_[key];
    assert(
      entry !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    );
    if (entry === this.newest_) {
      return entry.value_;
    }
    if (entry === this.oldest_) {
      this.oldest_ = /** @type {Entry} */
      this.oldest_.newer;
      this.oldest_.older = null;
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    entry.newer = null;
    entry.older = this.newest_;
    this.newest_.newer = entry;
    this.newest_ = entry;
    return entry.value_;
  }
  /**
   * Remove an entry from the cache.
   * @param {string} key The entry key.
   * @return {T} The removed entry.
   */
  remove(key) {
    const entry = this.entries_[key];
    assert(
      entry !== void 0,
      "Tried to get a value for a key that does not exist in the cache"
    );
    if (entry === this.newest_) {
      this.newest_ = /** @type {Entry} */
      entry.older;
      if (this.newest_) {
        this.newest_.newer = null;
      }
    } else if (entry === this.oldest_) {
      this.oldest_ = /** @type {Entry} */
      entry.newer;
      if (this.oldest_) {
        this.oldest_.older = null;
      }
    } else {
      entry.newer.older = entry.older;
      entry.older.newer = entry.newer;
    }
    delete this.entries_[key];
    --this.count_;
    return entry.value_;
  }
  /**
   * @return {number} Count.
   */
  getCount() {
    return this.count_;
  }
  /**
   * @return {Array<string>} Keys.
   */
  getKeys() {
    const keys = new Array(this.count_);
    let i = 0;
    let entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      keys[i++] = entry.key_;
    }
    return keys;
  }
  /**
   * @return {Array<T>} Values.
   */
  getValues() {
    const values = new Array(this.count_);
    let i = 0;
    let entry;
    for (entry = this.newest_; entry; entry = entry.older) {
      values[i++] = entry.value_;
    }
    return values;
  }
  /**
   * @return {T} Last value.
   */
  peekLast() {
    return this.oldest_.value_;
  }
  /**
   * @return {string} Last key.
   */
  peekLastKey() {
    return this.oldest_.key_;
  }
  /**
   * Get the key of the newest item in the cache.  Throws if the cache is empty.
   * @return {string} The newest key.
   */
  peekFirstKey() {
    return this.newest_.key_;
  }
  /**
   * Return an entry without updating least recently used time.
   * @param {string} key Key.
   * @return {T|undefined} Value.
   */
  peek(key) {
    return this.entries_[key]?.value_;
  }
  /**
   * @return {T} value Value.
   */
  pop() {
    const entry = this.oldest_;
    delete this.entries_[entry.key_];
    if (entry.newer) {
      entry.newer.older = null;
    }
    this.oldest_ = /** @type {Entry} */
    entry.newer;
    if (!this.oldest_) {
      this.newest_ = null;
    }
    --this.count_;
    return entry.value_;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  replace(key, value) {
    this.get(key);
    this.entries_[key].value_ = value;
  }
  /**
   * @param {string} key Key.
   * @param {T} value Value.
   */
  set(key, value) {
    assert(
      !(key in this.entries_),
      "Tried to set a value for a key that is used already"
    );
    const entry = {
      key_: key,
      newer: null,
      older: this.newest_,
      value_: value
    };
    if (!this.newest_) {
      this.oldest_ = entry;
    } else {
      this.newest_.newer = entry;
    }
    this.newest_ = entry;
    this.entries_[key] = entry;
    ++this.count_;
  }
  /**
   * Set a maximum number of entries for the cache.
   * @param {number} size Cache size.
   * @api
   */
  setSize(size) {
    this.highWaterMark = size;
  }
};
var LRUCache_default = LRUCache;

// node_modules/ol/tilecoord.js
function createOrUpdate2(z, x, y, tileCoord) {
  if (tileCoord !== void 0) {
    tileCoord[0] = z;
    tileCoord[1] = x;
    tileCoord[2] = y;
    return tileCoord;
  }
  return [z, x, y];
}
function getKeyZXY(z, x, y) {
  return z + "/" + x + "/" + y;
}
function getKey2(tileCoord) {
  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
}
function getCacheKeyForTileKey(tileKey) {
  const [z, x, y] = tileKey.substring(tileKey.lastIndexOf("/") + 1, tileKey.length).split(",").map(Number);
  return getKeyZXY(z, x, y);
}
function fromKey(key) {
  return key.split("/").map(Number);
}
function hash(tileCoord) {
  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
}
function withinExtentAndZ(tileCoord, tileGrid) {
  const z = tileCoord[0];
  const x = tileCoord[1];
  const y = tileCoord[2];
  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
    return false;
  }
  const tileRange = tileGrid.getFullTileRange(z);
  if (!tileRange) {
    return true;
  }
  return tileRange.containsXY(x, y);
}

// node_modules/ol/TileCache.js
var TileCache = class extends LRUCache_default {
  clear() {
    while (this.getCount() > 0) {
      this.pop().release();
    }
    super.clear();
  }
  /**
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(usedTiles) {
    while (this.canExpireCache()) {
      const tile2 = this.peekLast();
      if (tile2.getKey() in usedTiles) {
        break;
      } else {
        this.pop().release();
      }
    }
  }
  /**
   * Prune all tiles from the cache that don't have the same z as the newest tile.
   */
  pruneExceptNewestZ() {
    if (this.getCount() === 0) {
      return;
    }
    const key = this.peekFirstKey();
    const tileCoord = fromKey(key);
    const z = tileCoord[0];
    this.forEach((tile2) => {
      if (tile2.tileCoord[0] !== z) {
        this.remove(getKey2(tile2.tileCoord));
        tile2.release();
      }
    });
  }
};
var TileCache_default = TileCache;

// node_modules/ol/source/TileEventType.js
var TileEventType_default = {
  /**
   * Triggered when a tile starts loading.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
   * @api
   */
  TILELOADSTART: "tileloadstart",
  /**
   * Triggered when a tile finishes loading, either when its data is loaded,
   * or when loading was aborted because the tile is no longer needed.
   * @event module:ol/source/Tile.TileSourceEvent#tileloadend
   * @api
   */
  TILELOADEND: "tileloadend",
  /**
   * Triggered if tile loading results in an error. Note that this is not the
   * right place to re-fetch tiles. See {@link module:ol/ImageTile~ImageTile#load}
   * for details.
   * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
   * @api
   */
  TILELOADERROR: "tileloaderror"
};

// node_modules/ol/TileRange.js
var TileRange = class {
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   */
  constructor(minX, maxX, minY, maxY) {
    this.minX = minX;
    this.maxX = maxX;
    this.minY = minY;
    this.maxY = maxY;
  }
  /**
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {boolean} Contains tile coordinate.
   */
  contains(tileCoord) {
    return this.containsXY(tileCoord[1], tileCoord[2]);
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Contains.
   */
  containsTileRange(tileRange) {
    return this.minX <= tileRange.minX && tileRange.maxX <= this.maxX && this.minY <= tileRange.minY && tileRange.maxY <= this.maxY;
  }
  /**
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @return {boolean} Contains coordinate.
   */
  containsXY(x, y) {
    return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Equals.
   */
  equals(tileRange) {
    return this.minX == tileRange.minX && this.minY == tileRange.minY && this.maxX == tileRange.maxX && this.maxY == tileRange.maxY;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   */
  extend(tileRange) {
    if (tileRange.minX < this.minX) {
      this.minX = tileRange.minX;
    }
    if (tileRange.maxX > this.maxX) {
      this.maxX = tileRange.maxX;
    }
    if (tileRange.minY < this.minY) {
      this.minY = tileRange.minY;
    }
    if (tileRange.maxY > this.maxY) {
      this.maxY = tileRange.maxY;
    }
  }
  /**
   * @return {number} Height.
   */
  getHeight() {
    return this.maxY - this.minY + 1;
  }
  /**
   * @return {import("./size.js").Size} Size.
   */
  getSize() {
    return [this.getWidth(), this.getHeight()];
  }
  /**
   * @return {number} Width.
   */
  getWidth() {
    return this.maxX - this.minX + 1;
  }
  /**
   * @param {TileRange} tileRange Tile range.
   * @return {boolean} Intersects.
   */
  intersects(tileRange) {
    return this.minX <= tileRange.maxX && this.maxX >= tileRange.minX && this.minY <= tileRange.maxY && this.maxY >= tileRange.minY;
  }
};
function createOrUpdate3(minX, maxX, minY, maxY, tileRange) {
  if (tileRange !== void 0) {
    tileRange.minX = minX;
    tileRange.maxX = maxX;
    tileRange.minY = minY;
    tileRange.maxY = maxY;
    return tileRange;
  }
  return new TileRange(minX, maxX, minY, maxY);
}
var TileRange_default = TileRange;

// node_modules/ol/tilegrid/TileGrid.js
init_common();
init_asserts();
init_math();
init_extent();
init_intersectsextent();
init_array();
init_size();
var tmpTileCoord = [0, 0, 0];
var DECIMALS = 5;
var TileGrid = class {
  /**
   * @param {Options} options Tile grid options.
   */
  constructor(options) {
    this.minZoom = options.minZoom !== void 0 ? options.minZoom : 0;
    this.resolutions_ = options.resolutions;
    assert(
      isSorted(
        this.resolutions_,
        /**
         * @param {number} a First resolution
         * @param {number} b Second resolution
         * @return {number} Comparison result
         */
        (a, b) => b - a,
        true
      ),
      "`resolutions` must be sorted in descending order"
    );
    let zoomFactor;
    if (!options.origins) {
      for (let i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
        if (!zoomFactor) {
          zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
        } else {
          if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
            zoomFactor = void 0;
            break;
          }
        }
      }
    }
    this.zoomFactor_ = zoomFactor;
    this.maxZoom = this.resolutions_.length - 1;
    this.origin_ = options.origin !== void 0 ? options.origin : null;
    this.origins_ = null;
    if (options.origins !== void 0) {
      this.origins_ = options.origins;
      assert(
        this.origins_.length == this.resolutions_.length,
        "Number of `origins` and `resolutions` must be equal"
      );
    }
    const extent = options.extent;
    if (extent !== void 0 && !this.origin_ && !this.origins_) {
      this.origin_ = getTopLeft(extent);
    }
    assert(
      !this.origin_ && this.origins_ || this.origin_ && !this.origins_,
      "Either `origin` or `origins` must be configured, never both"
    );
    this.tileSizes_ = null;
    if (options.tileSizes !== void 0) {
      this.tileSizes_ = options.tileSizes;
      assert(
        this.tileSizes_.length == this.resolutions_.length,
        "Number of `tileSizes` and `resolutions` must be equal"
      );
    }
    this.tileSize_ = options.tileSize !== void 0 ? options.tileSize : !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;
    assert(
      !this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_,
      "Either `tileSize` or `tileSizes` must be configured, never both"
    );
    this.extent_ = extent !== void 0 ? extent : null;
    this.fullTileRanges_ = null;
    this.tmpSize_ = [0, 0];
    this.tmpExtent_ = [0, 0, 0, 0];
    if (options.sizes !== void 0) {
      this.fullTileRanges_ = options.sizes.map((size, z) => {
        const tileRange = new TileRange_default(
          Math.min(0, size[0]),
          Math.max(size[0] - 1, -1),
          Math.min(0, size[1]),
          Math.max(size[1] - 1, -1)
        );
        if (extent) {
          const restrictedTileRange = this.getTileRangeForExtentAndZ(extent, z);
          tileRange.minX = Math.max(restrictedTileRange.minX, tileRange.minX);
          tileRange.maxX = Math.min(restrictedTileRange.maxX, tileRange.maxX);
          tileRange.minY = Math.max(restrictedTileRange.minY, tileRange.minY);
          tileRange.maxY = Math.min(restrictedTileRange.maxY, tileRange.maxY);
        }
        return tileRange;
      });
    } else if (extent) {
      this.calculateTileRanges_(extent);
    }
  }
  /**
   * Call a function with each tile coordinate for a given extent and zoom level.
   *
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} zoom Integer zoom level.
   * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
   * @api
   */
  forEachTileCoord(extent, zoom, callback) {
    const tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
    for (let i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
      for (let j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
        callback([zoom, i, j]);
      }
    }
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {boolean} Callback succeeded.
   */
  forEachTileCoordParentTileRange(tileCoord, callback, tempTileRange, tempExtent) {
    let tileRange, x, y;
    let tileCoordExtent = null;
    let z = tileCoord[0] - 1;
    if (this.zoomFactor_ === 2) {
      x = tileCoord[1];
      y = tileCoord[2];
    } else {
      tileCoordExtent = this.getTileCoordExtent(tileCoord, tempExtent);
    }
    while (z >= this.minZoom) {
      if (x !== void 0 && y !== void 0) {
        x = Math.floor(x / 2);
        y = Math.floor(y / 2);
        tileRange = createOrUpdate3(x, x, y, y, tempTileRange);
      } else {
        tileRange = this.getTileRangeForExtentAndZ(
          tileCoordExtent,
          z,
          tempTileRange
        );
      }
      if (callback(z, tileRange)) {
        return true;
      }
      --z;
    }
    return false;
  }
  /**
   * Get the extent for this tile grid, if it was configured.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getExtent() {
    return this.extent_;
  }
  /**
   * Get the maximum zoom level for the grid.
   * @return {number} Max zoom.
   * @api
   */
  getMaxZoom() {
    return this.maxZoom;
  }
  /**
   * Get the minimum zoom level for the grid.
   * @return {number} Min zoom.
   * @api
   */
  getMinZoom() {
    return this.minZoom;
  }
  /**
   * Get the origin for the grid at the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {import("../coordinate.js").Coordinate} Origin.
   * @api
   */
  getOrigin(z) {
    if (this.origin_) {
      return this.origin_;
    }
    return this.origins_[z];
  }
  /**
   * Get the resolution for the given zoom level.
   * @param {number} z Integer zoom level.
   * @return {number} Resolution.
   * @api
   */
  getResolution(z) {
    return this.resolutions_[z];
  }
  /**
   * Get the list of resolutions for the tile grid.
   * @return {Array<number>} Resolutions.
   * @api
   */
  getResolutions() {
    return this.resolutions_;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary import("../extent.js").Extent object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileCoordChildTileRange(tileCoord, tempTileRange, tempExtent) {
    if (tileCoord[0] < this.maxZoom) {
      if (this.zoomFactor_ === 2) {
        const minX = tileCoord[1] * 2;
        const minY = tileCoord[2] * 2;
        return createOrUpdate3(
          minX,
          minX + 1,
          minY,
          minY + 1,
          tempTileRange
        );
      }
      const tileCoordExtent = this.getTileCoordExtent(
        tileCoord,
        tempExtent || this.tmpExtent_
      );
      return this.getTileRangeForExtentAndZ(
        tileCoordExtent,
        tileCoord[0] + 1,
        tempTileRange
      );
    }
    return null;
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary import("../TileRange.js").default object.
   * @return {import("../TileRange.js").default|null} Tile range.
   */
  getTileRangeForTileCoordAndZ(tileCoord, z, tempTileRange) {
    if (z > this.maxZoom || z < this.minZoom) {
      return null;
    }
    const tileCoordZ = tileCoord[0];
    const tileCoordX = tileCoord[1];
    const tileCoordY = tileCoord[2];
    if (z === tileCoordZ) {
      return createOrUpdate3(
        tileCoordX,
        tileCoordY,
        tileCoordX,
        tileCoordY,
        tempTileRange
      );
    }
    if (this.zoomFactor_) {
      const factor = Math.pow(this.zoomFactor_, z - tileCoordZ);
      const minX = Math.floor(tileCoordX * factor);
      const minY = Math.floor(tileCoordY * factor);
      if (z < tileCoordZ) {
        return createOrUpdate3(minX, minX, minY, minY, tempTileRange);
      }
      const maxX = Math.floor(factor * (tileCoordX + 1)) - 1;
      const maxY = Math.floor(factor * (tileCoordY + 1)) - 1;
      return createOrUpdate3(minX, maxX, minY, maxY, tempTileRange);
    }
    const tileCoordExtent = this.getTileCoordExtent(tileCoord, this.tmpExtent_);
    return this.getTileRangeForExtentAndZ(tileCoordExtent, z, tempTileRange);
  }
  /**
   * Get a tile range for the given extent and integer zoom level.
   * @param {import("../extent.js").Extent} extent Extent.
   * @param {number} z Integer zoom level.
   * @param {import("../TileRange.js").default} [tempTileRange] Temporary tile range object.
   * @return {import("../TileRange.js").default} Tile range.
   */
  getTileRangeForExtentAndZ(extent, z, tempTileRange) {
    this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tmpTileCoord);
    const minX = tmpTileCoord[1];
    const minY = tmpTileCoord[2];
    this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tmpTileCoord);
    const maxX = tmpTileCoord[1];
    const maxY = tmpTileCoord[2];
    return createOrUpdate3(minX, maxX, minY, maxY, tempTileRange);
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {import("../coordinate.js").Coordinate} Tile center.
   */
  getTileCoordCenter(tileCoord) {
    const origin = this.getOrigin(tileCoord[0]);
    const resolution = this.getResolution(tileCoord[0]);
    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
    return [
      origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
      origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution
    ];
  }
  /**
   * Get the extent of a tile coordinate.
   *
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../extent.js").Extent} [tempExtent] Temporary extent object.
   * @return {import("../extent.js").Extent} Extent.
   * @api
   */
  getTileCoordExtent(tileCoord, tempExtent) {
    const origin = this.getOrigin(tileCoord[0]);
    const resolution = this.getResolution(tileCoord[0]);
    const tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
    const minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
    const minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
    const maxX = minX + tileSize[0] * resolution;
    const maxY = minY + tileSize[1] * resolution;
    return createOrUpdate(minX, minY, maxX, maxY, tempExtent);
  }
  /**
   * Get the tile coordinate for the given map coordinate and resolution.  This
   * method considers that coordinates that intersect tile boundaries should be
   * assigned the higher tile coordinate.
   *
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} resolution Resolution.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndResolution(coordinate, resolution, opt_tileCoord) {
    return this.getTileCoordForXYAndResolution_(
      coordinate[0],
      coordinate[1],
      resolution,
      false,
      opt_tileCoord
    );
  }
  /**
   * Note that this method should not be called for resolutions that correspond
   * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} resolution Resolution (for a non-integer zoom level).
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndResolution_(x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
    const z = this.getZForResolution(resolution);
    const scale5 = resolution / this.getResolution(z);
    const origin = this.getOrigin(z);
    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);
    let tileCoordX = scale5 * (x - origin[0]) / resolution / tileSize[0];
    let tileCoordY = scale5 * (origin[1] - y) / resolution / tileSize[1];
    if (reverseIntersectionPolicy) {
      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
    } else {
      tileCoordX = floor(tileCoordX, DECIMALS);
      tileCoordY = floor(tileCoordY, DECIMALS);
    }
    return createOrUpdate2(z, tileCoordX, tileCoordY, opt_tileCoord);
  }
  /**
   * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
   * they should have separate implementations.  This method is for integer zoom
   * levels.  The other method should only be called for resolutions corresponding
   * to non-integer zoom levels.
   * @param {number} x Map x coordinate.
   * @param {number} y Map y coordinate.
   * @param {number} z Integer zoom level.
   * @param {boolean} reverseIntersectionPolicy Instead of letting edge
   *     intersections go to the higher tile coordinate, let edge intersections
   *     go to the lower tile coordinate.
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Temporary import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @private
   */
  getTileCoordForXYAndZ_(x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
    const origin = this.getOrigin(z);
    const resolution = this.getResolution(z);
    const tileSize = toSize(this.getTileSize(z), this.tmpSize_);
    let tileCoordX = (x - origin[0]) / resolution / tileSize[0];
    let tileCoordY = (origin[1] - y) / resolution / tileSize[1];
    if (reverseIntersectionPolicy) {
      tileCoordX = ceil(tileCoordX, DECIMALS) - 1;
      tileCoordY = ceil(tileCoordY, DECIMALS) - 1;
    } else {
      tileCoordX = floor(tileCoordX, DECIMALS);
      tileCoordY = floor(tileCoordY, DECIMALS);
    }
    return createOrUpdate2(z, tileCoordX, tileCoordY, opt_tileCoord);
  }
  /**
   * Get a tile coordinate given a map coordinate and zoom level.
   * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} z Integer zoom level, e.g. the result of a `getZForResolution()` method call
   * @param {import("../tilecoord.js").TileCoord} [opt_tileCoord] Destination import("../tilecoord.js").TileCoord object.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
   * @api
   */
  getTileCoordForCoordAndZ(coordinate, z, opt_tileCoord) {
    return this.getTileCoordForXYAndZ_(
      coordinate[0],
      coordinate[1],
      z,
      false,
      opt_tileCoord
    );
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @return {number} Tile resolution.
   */
  getTileCoordResolution(tileCoord) {
    return this.resolutions_[tileCoord[0]];
  }
  /**
   * Get the tile size for a zoom level. The type of the return value matches the
   * `tileSize` or `tileSizes` that the tile grid was configured with. To always
   * get an {@link import("../size.js").Size}, run the result through {@link module:ol/size.toSize}.
   * @param {number} z Z.
   * @return {number|import("../size.js").Size} Tile size.
   * @api
   */
  getTileSize(z) {
    if (this.tileSize_) {
      return this.tileSize_;
    }
    return this.tileSizes_[z];
  }
  /**
   * @param {number} z Zoom level.
   * @return {import("../TileRange.js").default|null} Extent tile range for the specified zoom level.
   */
  getFullTileRange(z) {
    if (!this.fullTileRanges_) {
      return this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, z) : null;
    }
    return this.fullTileRanges_[z];
  }
  /**
   * @param {number} resolution Resolution.
   * @param {number|import("../array.js").NearestDirectionFunction} [opt_direction]
   *     If 0, the nearest resolution will be used.
   *     If 1, the nearest higher resolution (lower Z) will be used. If -1, the
   *     nearest lower resolution (higher Z) will be used. Default is 0.
   *     Use a {@link module:ol/array~NearestDirectionFunction} for more precise control.
   *
   * For example to change tile Z at the midpoint of zoom levels
   * ```js
   * function(value, high, low) {
   *   return value - low * Math.sqrt(high / low);
   * }
   * ```
   * @return {number} Z.
   * @api
   */
  getZForResolution(resolution, opt_direction) {
    const z = linearFindNearest(
      this.resolutions_,
      resolution,
      opt_direction || 0
    );
    return clamp(z, this.minZoom, this.maxZoom);
  }
  /**
   * The tile with the provided tile coordinate intersects the given viewport.
   * @param {import('../tilecoord.js').TileCoord} tileCoord Tile coordinate.
   * @param {Array<number>} viewport Viewport as returned from {@link module:ol/extent.getRotatedViewport}.
   * @return {boolean} The tile with the provided tile coordinate intersects the given viewport.
   */
  tileCoordIntersectsViewport(tileCoord, viewport) {
    return intersectsLinearRing(
      viewport,
      0,
      viewport.length,
      2,
      this.getTileCoordExtent(tileCoord)
    );
  }
  /**
   * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
   * @private
   */
  calculateTileRanges_(extent) {
    const length = this.resolutions_.length;
    const fullTileRanges = new Array(length);
    for (let z = this.minZoom; z < length; ++z) {
      fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
    }
    this.fullTileRanges_ = fullTileRanges;
  }
};
var TileGrid_default = TileGrid;

// node_modules/ol/tilegrid.js
init_common();
init_proj();
init_extent();
init_size();
function getForProjection(projection) {
  let tileGrid = projection.getDefaultTileGrid();
  if (!tileGrid) {
    tileGrid = createForProjection(projection);
    projection.setDefaultTileGrid(tileGrid);
  }
  return tileGrid;
}
function wrapX3(tileGrid, tileCoord, projection) {
  const z = tileCoord[0];
  const center = tileGrid.getTileCoordCenter(tileCoord);
  const projectionExtent = extentFromProjection(projection);
  if (!containsCoordinate(projectionExtent, center)) {
    const worldWidth = getWidth(projectionExtent);
    const worldsAway = Math.ceil(
      (projectionExtent[0] - center[0]) / worldWidth
    );
    center[0] += worldWidth * worldsAway;
    return tileGrid.getTileCoordForCoordAndZ(center, z);
  }
  return tileCoord;
}
function createForExtent(extent, maxZoom, tileSize, corner) {
  corner = corner !== void 0 ? corner : "top-left";
  const resolutions = resolutionsFromExtent(extent, maxZoom, tileSize);
  return new TileGrid_default({
    extent,
    origin: getCorner(extent, corner),
    resolutions,
    tileSize
  });
}
function createXYZ(options) {
  const xyzOptions = options || {};
  const extent = xyzOptions.extent || get3("EPSG:3857").getExtent();
  const gridOptions = {
    extent,
    minZoom: xyzOptions.minZoom,
    tileSize: xyzOptions.tileSize,
    resolutions: resolutionsFromExtent(
      extent,
      xyzOptions.maxZoom,
      xyzOptions.tileSize,
      xyzOptions.maxResolution
    )
  };
  return new TileGrid_default(gridOptions);
}
function resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {
  maxZoom = maxZoom !== void 0 ? maxZoom : DEFAULT_MAX_ZOOM;
  tileSize = toSize(tileSize !== void 0 ? tileSize : DEFAULT_TILE_SIZE);
  const height = getHeight(extent);
  const width = getWidth(extent);
  maxResolution = maxResolution > 0 ? maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
  const length = maxZoom + 1;
  const resolutions = new Array(length);
  for (let z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }
  return resolutions;
}
function createForProjection(projection, maxZoom, tileSize, corner) {
  const extent = extentFromProjection(projection);
  return createForExtent(extent, maxZoom, tileSize, corner);
}
function extentFromProjection(projection) {
  projection = get3(projection);
  let extent = projection.getExtent();
  if (!extent) {
    const half = 180 * METERS_PER_UNIT.degrees / projection.getMetersPerUnit();
    extent = createOrUpdate(-half, -half, half, half);
  }
  return extent;
}

// node_modules/ol/source/Tile.js
init_Event();
init_Source();
init_util();
init_asserts();
init_proj();
init_size();
var TileSource = class extends Source_default {
  /**
   * @param {Options} options SourceTile source options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      attributionsCollapsible: options.attributionsCollapsible,
      projection: options.projection,
      state: options.state,
      wrapX: options.wrapX,
      interpolate: options.interpolate
    });
    this.on;
    this.once;
    this.un;
    this.opaque_ = options.opaque !== void 0 ? options.opaque : false;
    this.tilePixelRatio_ = options.tilePixelRatio !== void 0 ? options.tilePixelRatio : 1;
    this.tileGrid = options.tileGrid !== void 0 ? options.tileGrid : null;
    const tileSize = [256, 256];
    if (this.tileGrid) {
      toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), tileSize);
    }
    this.tileCache = new TileCache_default(options.cacheSize || 0);
    this.tmpSize = [0, 0];
    this.key_ = options.key || "";
    this.tileOptions = {
      transition: options.transition,
      interpolate: options.interpolate
    };
    this.zDirection = options.zDirection ? options.zDirection : 0;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    return this.tileCache.canExpireCache();
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(projection, usedTiles) {
    const tileCache = this.getTileCacheForProjection(projection);
    if (tileCache) {
      tileCache.expireCache(usedTiles);
    }
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {number} z Zoom level.
   * @param {import("../TileRange.js").default} tileRange Tile range.
   * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
   *     loaded tile.  If the callback returns `false`, the tile will not be
   *     considered loaded.
   * @return {boolean} The tile range is fully covered with loaded tiles.
   */
  forEachLoadedTile(projection, z, tileRange, callback) {
    const tileCache = this.getTileCacheForProjection(projection);
    if (!tileCache) {
      return false;
    }
    let covered = true;
    let tile2, tileCoordKey, loaded;
    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {
        tileCoordKey = getKeyZXY(z, x, y);
        loaded = false;
        if (tileCache.containsKey(tileCoordKey)) {
          tile2 = /** @type {!import("../Tile.js").default} */
          tileCache.get(tileCoordKey);
          loaded = tile2.getState() === TileState_default.LOADED;
          if (loaded) {
            loaded = callback(tile2) !== false;
          }
        }
        if (!loaded) {
          covered = false;
        }
      }
    }
    return covered;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(projection) {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    return this.key_;
  }
  /**
   * Set the value to be used as the key for all tiles in the source.
   * @param {string} key The key for tiles.
   * @protected
   */
  setKey(key) {
    if (this.key_ !== key) {
      this.key_ = key;
      this.changed();
    }
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(projection) {
    return this.opaque_;
  }
  /**
   * @param {import("../proj/Projection").default} [projection] Projection.
   * @return {Array<number>|null} Resolutions.
   */
  getResolutions(projection) {
    const tileGrid = projection ? this.getTileGridForProjection(projection) : this.tileGrid;
    if (!tileGrid) {
      return null;
    }
    return tileGrid.getResolutions();
  }
  /**
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../Tile.js").default} Tile.
   */
  getTile(z, x, y, pixelRatio, projection) {
    return abstract();
  }
  /**
   * Return the tile grid of the tile source.
   * @return {import("../tilegrid/TileGrid.js").default|null} Tile grid.
   * @api
   */
  getTileGrid() {
    return this.tileGrid;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(projection) {
    if (!this.tileGrid) {
      return getForProjection(projection);
    }
    return this.tileGrid;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   * @protected
   */
  getTileCacheForProjection(projection) {
    const sourceProjection = this.getProjection();
    assert(
      sourceProjection === null || equivalent(sourceProjection, projection),
      "A VectorTile source can only be rendered if it has a projection compatible with the view projection."
    );
    return this.tileCache;
  }
  /**
   * Get the tile pixel ratio for this source. Subclasses may override this
   * method, which is meant to return a supported pixel ratio that matches the
   * provided `pixelRatio` as close as possible.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Tile pixel ratio.
   */
  getTilePixelRatio(pixelRatio) {
    return this.tilePixelRatio_;
  }
  /**
   * @param {number} z Z.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../size.js").Size} Tile size.
   */
  getTilePixelSize(z, pixelRatio, projection) {
    const tileGrid = this.getTileGridForProjection(projection);
    const tilePixelRatio = this.getTilePixelRatio(pixelRatio);
    const tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);
    if (tilePixelRatio == 1) {
      return tileSize;
    }
    return scale4(tileSize, tilePixelRatio, this.tmpSize);
  }
  /**
   * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
   * is outside the resolution and extent range of the tile grid, `null` will be
   * returned.
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("../proj/Projection.js").default} [projection] Projection.
   * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
   *     null if no tile URL should be created for the passed `tileCoord`.
   */
  getTileCoordForTileUrlFunction(tileCoord, projection) {
    projection = projection !== void 0 ? projection : this.getProjection();
    const tileGrid = this.getTileGridForProjection(projection);
    if (this.getWrapX() && projection.isGlobal()) {
      tileCoord = wrapX3(tileGrid, tileCoord, projection);
    }
    return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
  }
  /**
   * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
   * @api
   */
  clear() {
    this.tileCache.clear();
  }
  refresh() {
    this.clear();
    super.refresh();
  }
  /**
   * Increases the cache size if needed
   * @param {number} tileCount Minimum number of tiles needed.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  updateCacheSize(tileCount, projection) {
    const tileCache = this.getTileCacheForProjection(projection);
    if (tileCount > tileCache.highWaterMark) {
      tileCache.highWaterMark = tileCount;
    }
  }
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @abstract
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../proj/Projection.js").default} projection Projection.
   */
  useTile(z, x, y, projection) {
  }
};
var TileSourceEvent = class extends Event_default {
  /**
   * @param {string} type Type.
   * @param {import("../Tile.js").default} tile The tile.
   */
  constructor(type, tile2) {
    super(type);
    this.tile = tile2;
  }
};
var Tile_default3 = TileSource;

// node_modules/ol/tileurlfunction.js
init_math();
function createFromTemplate(template, tileGrid) {
  const zRegEx = /\{z\}/g;
  const xRegEx = /\{x\}/g;
  const yRegEx = /\{y\}/g;
  const dashYRegEx = /\{-y\}/g;
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return void 0;
      }
      return template.replace(zRegEx, tileCoord[0].toString()).replace(xRegEx, tileCoord[1].toString()).replace(yRegEx, tileCoord[2].toString()).replace(dashYRegEx, function() {
        const z = tileCoord[0];
        const range = tileGrid.getFullTileRange(z);
        if (!range) {
          throw new Error(
            "The {-y} placeholder requires a tile grid with extent"
          );
        }
        const y = range.getHeight() - tileCoord[2] - 1;
        return y.toString();
      });
    }
  );
}
function createFromTemplates(templates, tileGrid) {
  const len = templates.length;
  const tileUrlFunctions = new Array(len);
  for (let i = 0; i < len; ++i) {
    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
  }
  return createFromTileUrlFunctions(tileUrlFunctions);
}
function createFromTileUrlFunctions(tileUrlFunctions) {
  if (tileUrlFunctions.length === 1) {
    return tileUrlFunctions[0];
  }
  return (
    /**
     * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("./proj/Projection.js").default} projection Projection.
     * @return {string|undefined} Tile URL.
     */
    function(tileCoord, pixelRatio, projection) {
      if (!tileCoord) {
        return void 0;
      }
      const h = hash(tileCoord);
      const index = modulo(h, tileUrlFunctions.length);
      return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
    }
  );
}
function nullTileUrlFunction(tileCoord, pixelRatio, projection) {
  return void 0;
}
function expandUrl(url) {
  const urls = [];
  let match = /\{([a-z])-([a-z])\}/.exec(url);
  if (match) {
    const startCharCode = match[1].charCodeAt(0);
    const stopCharCode = match[2].charCodeAt(0);
    let charCode;
    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }
    return urls;
  }
  match = /\{(\d+)-(\d+)\}/.exec(url);
  if (match) {
    const stop = parseInt(match[2], 10);
    for (let i = parseInt(match[1], 10); i <= stop; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }
    return urls;
  }
  urls.push(url);
  return urls;
}

// node_modules/ol/source/UrlTile.js
init_util();
var UrlTile = class _UrlTile extends Tile_default3 {
  /**
   * @param {Options} options Image tile options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tilePixelRatio: options.tilePixelRatio,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });
    this.generateTileUrlFunction_ = this.tileUrlFunction === _UrlTile.prototype.tileUrlFunction;
    this.tileLoadFunction = options.tileLoadFunction;
    if (options.tileUrlFunction) {
      this.tileUrlFunction = options.tileUrlFunction;
    }
    this.urls = null;
    if (options.urls) {
      this.setUrls(options.urls);
    } else if (options.url) {
      this.setUrl(options.url);
    }
    this.tileLoadingKeys_ = {};
  }
  /**
   * Return the tile load function of the source.
   * @return {import("../Tile.js").LoadFunction} TileLoadFunction
   * @api
   */
  getTileLoadFunction() {
    return this.tileLoadFunction;
  }
  /**
   * Return the tile URL function of the source.
   * @return {import("../Tile.js").UrlFunction} TileUrlFunction
   * @api
   */
  getTileUrlFunction() {
    return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction;
  }
  /**
   * Return the URLs used for this source.
   * When a tileUrlFunction is used instead of url or urls,
   * null will be returned.
   * @return {!Array<string>|null} URLs.
   * @api
   */
  getUrls() {
    return this.urls;
  }
  /**
   * Handle tile change events.
   * @param {import("../events/Event.js").default} event Event.
   * @protected
   */
  handleTileChange(event) {
    const tile2 = (
      /** @type {import("../Tile.js").default} */
      event.target
    );
    const uid = getUid(tile2);
    const tileState = tile2.getState();
    let type;
    if (tileState == TileState_default.LOADING) {
      this.tileLoadingKeys_[uid] = true;
      type = TileEventType_default.TILELOADSTART;
    } else if (uid in this.tileLoadingKeys_) {
      delete this.tileLoadingKeys_[uid];
      type = tileState == TileState_default.ERROR ? TileEventType_default.TILELOADERROR : tileState == TileState_default.LOADED ? TileEventType_default.TILELOADEND : void 0;
    }
    if (type != void 0) {
      this.dispatchEvent(new TileSourceEvent(type, tile2));
    }
  }
  /**
   * Set the tile load function of the source.
   * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
   * @api
   */
  setTileLoadFunction(tileLoadFunction) {
    this.tileCache.clear();
    this.tileLoadFunction = tileLoadFunction;
    this.changed();
  }
  /**
   * Set the tile URL function of the source.
   * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
   * @param {string} [key] Optional new tile key for the source.
   * @api
   */
  setTileUrlFunction(tileUrlFunction, key) {
    this.tileUrlFunction = tileUrlFunction;
    this.tileCache.pruneExceptNewestZ();
    if (typeof key !== "undefined") {
      this.setKey(key);
    } else {
      this.changed();
    }
  }
  /**
   * Set the URL to use for requests.
   * @param {string} url URL.
   * @api
   */
  setUrl(url) {
    const urls = expandUrl(url);
    this.urls = urls;
    this.setUrls(urls);
  }
  /**
   * Set the URLs to use for requests.
   * @param {Array<string>} urls URLs.
   * @api
   */
  setUrls(urls) {
    this.urls = urls;
    const key = urls.join("\n");
    if (this.generateTileUrlFunction_) {
      this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);
    } else {
      this.setKey(key);
    }
  }
  /**
   * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {string|undefined} Tile URL.
   */
  tileUrlFunction(tileCoord, pixelRatio, projection) {
    return void 0;
  }
  /**
   * Marks a tile coord as being used, without triggering a load.
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   */
  useTile(z, x, y) {
    const tileCoordKey = getKeyZXY(z, x, y);
    if (this.tileCache.containsKey(tileCoordKey)) {
      this.tileCache.get(tileCoordKey);
    }
  }
};
var UrlTile_default = UrlTile;

// node_modules/ol/source/TileImage.js
init_EventType();
init_proj();
init_util();
var TileImage = class extends UrlTile_default {
  /**
   * @param {!Options} options Image tile options.
   */
  constructor(options) {
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      opaque: options.opaque,
      projection: options.projection,
      state: options.state,
      tileGrid: options.tileGrid,
      tileLoadFunction: options.tileLoadFunction ? options.tileLoadFunction : defaultTileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX,
      transition: options.transition,
      interpolate: options.interpolate !== void 0 ? options.interpolate : true,
      key: options.key,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });
    this.crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : null;
    this.tileClass = options.tileClass !== void 0 ? options.tileClass : ImageTile_default;
    this.tileCacheForProjection = {};
    this.tileGridForProjection = {};
    this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
    this.renderReprojectionEdges_ = false;
  }
  /**
   * @return {boolean} Can expire cache.
   */
  canExpireCache() {
    if (this.tileCache.canExpireCache()) {
      return true;
    }
    for (const key in this.tileCacheForProjection) {
      if (this.tileCacheForProjection[key].canExpireCache()) {
        return true;
      }
    }
    return false;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {!Object<string, boolean>} usedTiles Used tiles.
   */
  expireCache(projection, usedTiles) {
    const usedTileCache = this.getTileCacheForProjection(projection);
    this.tileCache.expireCache(
      this.tileCache == usedTileCache ? usedTiles : {}
    );
    for (const id in this.tileCacheForProjection) {
      const tileCache = this.tileCacheForProjection[id];
      tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
    }
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {number} Gutter.
   */
  getGutterForProjection(projection) {
    if (this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
      return 0;
    }
    return this.getGutter();
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return 0;
  }
  /**
   * Return the key to be used for all tiles in the source.
   * @return {string} The key for all tiles.
   */
  getKey() {
    let key = super.getKey();
    if (!this.getInterpolate()) {
      key += ":disable-interpolation";
    }
    return key;
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {boolean} Opaque.
   */
  getOpaque(projection) {
    if (this.getProjection() && projection && !equivalent(this.getProjection(), projection)) {
      return false;
    }
    return super.getOpaque(projection);
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
   */
  getTileGridForProjection(projection) {
    const thisProj = this.getProjection();
    if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {
      return this.tileGrid;
    }
    const projKey = getUid(projection);
    if (!(projKey in this.tileGridForProjection)) {
      this.tileGridForProjection[projKey] = getForProjection(projection);
    }
    return this.tileGridForProjection[projKey];
  }
  /**
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {import("../TileCache.js").default} Tile cache.
   */
  getTileCacheForProjection(projection) {
    const thisProj = this.getProjection();
    if (!thisProj || equivalent(thisProj, projection)) {
      return this.tileCache;
    }
    const projKey = getUid(projection);
    if (!(projKey in this.tileCacheForProjection)) {
      this.tileCacheForProjection[projKey] = new TileCache_default(
        this.tileCache.highWaterMark
      );
    }
    return this.tileCacheForProjection[projKey];
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @param {string} key The key set on the tile.
   * @return {!ImageTile} Tile.
   * @private
   */
  createTile_(z, x, y, pixelRatio, projection, key) {
    const tileCoord = [z, x, y];
    const urlTileCoord = this.getTileCoordForTileUrlFunction(
      tileCoord,
      projection
    );
    const tileUrl = urlTileCoord ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection) : void 0;
    const tile2 = new this.tileClass(
      tileCoord,
      tileUrl !== void 0 ? TileState_default.IDLE : TileState_default.EMPTY,
      tileUrl !== void 0 ? tileUrl : "",
      this.crossOrigin,
      this.tileLoadFunction,
      this.tileOptions
    );
    tile2.key = key;
    tile2.addEventListener(EventType_default.CHANGE, this.handleTileChange.bind(this));
    return tile2;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../proj/Projection.js").default} projection Projection.
   * @return {!(ImageTile|ReprojTile)} Tile.
   */
  getTile(z, x, y, pixelRatio, projection) {
    const sourceProjection = this.getProjection();
    if (!sourceProjection || !projection || equivalent(sourceProjection, projection)) {
      return this.getTileInternal(
        z,
        x,
        y,
        pixelRatio,
        sourceProjection || projection
      );
    }
    const cache3 = this.getTileCacheForProjection(projection);
    const tileCoord = [z, x, y];
    let tile2;
    const tileCoordKey = getKey2(tileCoord);
    if (cache3.containsKey(tileCoordKey)) {
      tile2 = cache3.get(tileCoordKey);
    }
    const key = this.getKey();
    if (tile2 && tile2.key == key) {
      return tile2;
    }
    const sourceTileGrid = this.getTileGridForProjection(sourceProjection);
    const targetTileGrid = this.getTileGridForProjection(projection);
    const wrappedTileCoord = this.getTileCoordForTileUrlFunction(
      tileCoord,
      projection
    );
    const newTile = new Tile_default2(
      sourceProjection,
      sourceTileGrid,
      projection,
      targetTileGrid,
      tileCoord,
      wrappedTileCoord,
      this.getTilePixelRatio(pixelRatio),
      this.getGutter(),
      (z2, x2, y2, pixelRatio2) => this.getTileInternal(z2, x2, y2, pixelRatio2, sourceProjection),
      this.reprojectionErrorThreshold_,
      this.renderReprojectionEdges_,
      this.tileOptions
    );
    newTile.key = key;
    if (tile2) {
      newTile.interimTile = tile2;
      newTile.refreshInterimChain();
      cache3.replace(tileCoordKey, newTile);
    } else {
      cache3.set(tileCoordKey, newTile);
    }
    return newTile;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {number} pixelRatio Pixel ratio.
   * @param {!import("../proj/Projection.js").default} projection Projection.
   * @return {!ImageTile} Tile.
   * @protected
   */
  getTileInternal(z, x, y, pixelRatio, projection) {
    let tile2 = null;
    const tileCoordKey = getKeyZXY(z, x, y);
    const key = this.getKey();
    if (!this.tileCache.containsKey(tileCoordKey)) {
      tile2 = this.createTile_(z, x, y, pixelRatio, projection, key);
      this.tileCache.set(tileCoordKey, tile2);
    } else {
      tile2 = this.tileCache.get(tileCoordKey);
      if (tile2.key != key) {
        const interimTile = tile2;
        tile2 = this.createTile_(z, x, y, pixelRatio, projection, key);
        if (interimTile.getState() == TileState_default.IDLE) {
          tile2.interimTile = interimTile.interimTile;
        } else {
          tile2.interimTile = interimTile;
        }
        tile2.refreshInterimChain();
        this.tileCache.replace(tileCoordKey, tile2);
      }
    }
    return tile2;
  }
  /**
   * Sets whether to render reprojection edges or not (usually for debugging).
   * @param {boolean} render Render the edges.
   * @api
   */
  setRenderReprojectionEdges(render2) {
    if (this.renderReprojectionEdges_ == render2) {
      return;
    }
    this.renderReprojectionEdges_ = render2;
    for (const id in this.tileCacheForProjection) {
      this.tileCacheForProjection[id].clear();
    }
    this.changed();
  }
  /**
   * Sets the tile grid to use when reprojecting the tiles to the given
   * projection instead of the default tile grid for the projection.
   *
   * This can be useful when the default tile grid cannot be created
   * (e.g. projection has no extent defined) or
   * for optimization reasons (custom tile size, resolutions, ...).
   *
   * @param {import("../proj.js").ProjectionLike} projection Projection.
   * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
   * @api
   */
  setTileGridForProjection(projection, tilegrid) {
    const proj = get3(projection);
    if (proj) {
      const projKey = getUid(proj);
      if (!(projKey in this.tileGridForProjection)) {
        this.tileGridForProjection[projKey] = tilegrid;
      }
    }
  }
  clear() {
    super.clear();
    for (const id in this.tileCacheForProjection) {
      this.tileCacheForProjection[id].clear();
    }
  }
};
function defaultTileLoadFunction(imageTile, src) {
  imageTile.getImage().src = src;
}
var TileImage_default = TileImage;

// node_modules/ol/source/XYZ.js
var XYZ = class extends TileImage_default {
  /**
   * @param {Options} [options] XYZ options.
   */
  constructor(options) {
    options = options || {};
    const projection = options.projection !== void 0 ? options.projection : "EPSG:3857";
    const tileGrid = options.tileGrid !== void 0 ? options.tileGrid : createXYZ({
      extent: extentFromProjection(projection),
      maxResolution: options.maxResolution,
      maxZoom: options.maxZoom,
      minZoom: options.minZoom,
      tileSize: options.tileSize
    });
    super({
      attributions: options.attributions,
      cacheSize: options.cacheSize,
      crossOrigin: options.crossOrigin,
      interpolate: options.interpolate,
      opaque: options.opaque,
      projection,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileGrid,
      tileLoadFunction: options.tileLoadFunction,
      tilePixelRatio: options.tilePixelRatio,
      tileUrlFunction: options.tileUrlFunction,
      url: options.url,
      urls: options.urls,
      wrapX: options.wrapX !== void 0 ? options.wrapX : true,
      transition: options.transition,
      attributionsCollapsible: options.attributionsCollapsible,
      zDirection: options.zDirection
    });
    this.gutter_ = options.gutter !== void 0 ? options.gutter : 0;
  }
  /**
   * @return {number} Gutter.
   */
  getGutter() {
    return this.gutter_;
  }
};
var XYZ_default = XYZ;

// node_modules/ol/source/OSM.js
var ATTRIBUTION = '&#169; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
var OSM = class extends XYZ_default {
  /**
   * @param {Options} [options] Open Street Map options.
   */
  constructor(options) {
    options = options || {};
    let attributions;
    if (options.attributions !== void 0) {
      attributions = options.attributions;
    } else {
      attributions = [ATTRIBUTION];
    }
    const crossOrigin = options.crossOrigin !== void 0 ? options.crossOrigin : "anonymous";
    const url = options.url !== void 0 ? options.url : "https://tile.openstreetmap.org/{z}/{x}/{y}.png";
    super({
      attributions,
      attributionsCollapsible: false,
      cacheSize: options.cacheSize,
      crossOrigin,
      interpolate: options.interpolate,
      maxZoom: options.maxZoom !== void 0 ? options.maxZoom : 19,
      opaque: options.opaque !== void 0 ? options.opaque : true,
      reprojectionErrorThreshold: options.reprojectionErrorThreshold,
      tileLoadFunction: options.tileLoadFunction,
      transition: options.transition,
      url,
      wrapX: options.wrapX,
      zDirection: options.zDirection
    });
  }
};
var OSM_default = OSM;

// node_modules/ol/layer/TileProperty.js
var TileProperty_default = {
  PRELOAD: "preload",
  USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};

// node_modules/ol/layer/BaseTile.js
init_Layer();
var BaseTileLayer = class extends Layer_default {
  /**
   * @param {Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(options) {
    options = options ? options : {};
    const baseOptions = Object.assign({}, options);
    delete baseOptions.preload;
    delete baseOptions.useInterimTilesOnError;
    super(baseOptions);
    this.on;
    this.once;
    this.un;
    this.setPreload(options.preload !== void 0 ? options.preload : 0);
    this.setUseInterimTilesOnError(
      options.useInterimTilesOnError !== void 0 ? options.useInterimTilesOnError : true
    );
  }
  /**
   * Return the level as number to which we will preload tiles up to.
   * @return {number} The level to preload tiles up to.
   * @observable
   * @api
   */
  getPreload() {
    return (
      /** @type {number} */
      this.get(TileProperty_default.PRELOAD)
    );
  }
  /**
   * Set the level as number to which we will preload tiles up to.
   * @param {number} preload The level to preload tiles up to.
   * @observable
   * @api
   */
  setPreload(preload) {
    this.set(TileProperty_default.PRELOAD, preload);
  }
  /**
   * Whether we use interim tiles on error.
   * @return {boolean} Use interim tiles on error.
   * @observable
   * @api
   */
  getUseInterimTilesOnError() {
    return (
      /** @type {boolean} */
      this.get(TileProperty_default.USE_INTERIM_TILES_ON_ERROR)
    );
  }
  /**
   * Set whether we use interim tiles on error.
   * @param {boolean} useInterimTilesOnError Use interim tiles on error.
   * @observable
   * @api
   */
  setUseInterimTilesOnError(useInterimTilesOnError) {
    this.set(TileProperty_default.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
  }
  /**
   * Get data for a pixel location.  The return type depends on the source data.  For image tiles,
   * a four element RGBA array will be returned.  For data tiles, the array length will match the
   * number of bands in the dataset.  For requests outside the layer extent, `null` will be returned.
   * Data for a image tiles can only be retrieved if the source's `crossOrigin` property is set.
   *
   * ```js
   * // display layer data on every pointer move
   * map.on('pointermove', (event) => {
   *   console.log(layer.getData(event.pixel));
   * });
   * ```
   * @param {import("../pixel").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
   * @api
   */
  getData(pixel) {
    return super.getData(pixel);
  }
};
var BaseTile_default = BaseTileLayer;

// node_modules/ol/renderer/canvas/TileLayer.js
init_Layer3();
init_transform();
init_array();
init_extent();
init_proj();
init_util();
init_size();
var CanvasTileLayerRenderer = class extends Layer_default3 {
  /**
   * @param {LayerType} tileLayer Tile layer.
   */
  constructor(tileLayer) {
    super(tileLayer);
    this.extentChanged = true;
    this.renderedExtent_ = null;
    this.renderedPixelRatio;
    this.renderedProjection = null;
    this.renderedRevision;
    this.renderedTiles = [];
    this.newTiles_ = false;
    this.tmpExtent = createEmpty();
    this.tmpTileRange_ = new TileRange_default(0, 0, 0, 0);
  }
  /**
   * @protected
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean} Tile is drawable.
   */
  isDrawableTile(tile2) {
    const tileLayer = this.getLayer();
    const tileState = tile2.getState();
    const useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
    return tileState == TileState_default.LOADED || tileState == TileState_default.EMPTY || tileState == TileState_default.ERROR && !useInterimTilesOnError;
  }
  /**
   * @param {number} z Tile coordinate z.
   * @param {number} x Tile coordinate x.
   * @param {number} y Tile coordinate y.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {!import("../../Tile.js").default} Tile.
   */
  getTile(z, x, y, frameState) {
    const pixelRatio = frameState.pixelRatio;
    const projection = frameState.viewState.projection;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getSource();
    let tile2 = tileSource.getTile(z, x, y, pixelRatio, projection);
    if (tile2.getState() == TileState_default.ERROR) {
      if (tileLayer.getUseInterimTilesOnError() && tileLayer.getPreload() > 0) {
        this.newTiles_ = true;
      }
    }
    if (!this.isDrawableTile(tile2)) {
      tile2 = tile2.getInterimTile();
    }
    return tile2;
  }
  /**
   * @param {import("../../pixel.js").Pixel} pixel Pixel.
   * @return {Uint8ClampedArray} Data at the pixel location.
   */
  getData(pixel) {
    const frameState = this.frameState;
    if (!frameState) {
      return null;
    }
    const layer = this.getLayer();
    const coordinate = apply(
      frameState.pixelToCoordinateTransform,
      pixel.slice()
    );
    const layerExtent = layer.getExtent();
    if (layerExtent) {
      if (!containsCoordinate(layerExtent, coordinate)) {
        return null;
      }
    }
    const pixelRatio = frameState.pixelRatio;
    const projection = frameState.viewState.projection;
    const viewState = frameState.viewState;
    const source = layer.getRenderSource();
    const tileGrid = source.getTileGridForProjection(viewState.projection);
    const tilePixelRatio = source.getTilePixelRatio(frameState.pixelRatio);
    for (let z = tileGrid.getZForResolution(viewState.resolution); z >= tileGrid.getMinZoom(); --z) {
      const tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
      const tile2 = source.getTile(
        z,
        tileCoord[1],
        tileCoord[2],
        pixelRatio,
        projection
      );
      if (!(tile2 instanceof ImageTile_default || tile2 instanceof Tile_default2) || tile2 instanceof Tile_default2 && tile2.getState() === TileState_default.EMPTY) {
        return null;
      }
      if (tile2.getState() !== TileState_default.LOADED) {
        continue;
      }
      const tileOrigin = tileGrid.getOrigin(z);
      const tileSize = toSize(tileGrid.getTileSize(z));
      const tileResolution = tileGrid.getResolution(z);
      const col = Math.floor(
        tilePixelRatio * ((coordinate[0] - tileOrigin[0]) / tileResolution - tileCoord[1] * tileSize[0])
      );
      const row = Math.floor(
        tilePixelRatio * ((tileOrigin[1] - coordinate[1]) / tileResolution - tileCoord[2] * tileSize[1])
      );
      const gutter = Math.round(
        tilePixelRatio * source.getGutterForProjection(viewState.projection)
      );
      return this.getImageData(tile2.getImage(), col + gutter, row + gutter);
    }
    return null;
  }
  /**
   * @param {Object<number, Object<string, import("../../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
   * @param {number} zoom Zoom level.
   * @param {import("../../Tile.js").default} tile Tile.
   * @return {boolean|void} If `false`, the tile will not be considered loaded.
   */
  loadedTileCallback(tiles, zoom, tile2) {
    if (this.isDrawableTile(tile2)) {
      return super.loadedTileCallback(tiles, zoom, tile2);
    }
    return false;
  }
  /**
   * Determine whether render should be called.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @return {boolean} Layer is ready to be rendered.
   */
  prepareFrame(frameState) {
    return !!this.getLayer().getSource();
  }
  /**
   * Render the layer.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {HTMLElement} target Target that may be used to render content to.
   * @return {HTMLElement} The rendered element.
   */
  renderFrame(frameState, target) {
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const viewState = frameState.viewState;
    const projection = viewState.projection;
    const viewResolution = viewState.resolution;
    const viewCenter = viewState.center;
    const rotation = viewState.rotation;
    const pixelRatio = frameState.pixelRatio;
    const tileLayer = this.getLayer();
    const tileSource = tileLayer.getSource();
    const sourceRevision = tileSource.getRevision();
    const tileGrid = tileSource.getTileGridForProjection(projection);
    const z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
    const tileResolution = tileGrid.getResolution(z);
    let extent = frameState.extent;
    const resolution = frameState.viewState.resolution;
    const tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
    const width = Math.round(getWidth(extent) / resolution * pixelRatio);
    const height = Math.round(getHeight(extent) / resolution * pixelRatio);
    const layerExtent = layerState.extent && fromUserExtent(layerState.extent, projection);
    if (layerExtent) {
      extent = getIntersection(
        extent,
        fromUserExtent(layerState.extent, projection)
      );
    }
    const dx = tileResolution * width / 2 / tilePixelRatio;
    const dy = tileResolution * height / 2 / tilePixelRatio;
    const canvasExtent = [
      viewCenter[0] - dx,
      viewCenter[1] - dy,
      viewCenter[0] + dx,
      viewCenter[1] + dy
    ];
    const tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
    const tilesToDrawByZ = {};
    tilesToDrawByZ[z] = {};
    const findLoadedTiles = this.createLoadedTileFinder(
      tileSource,
      projection,
      tilesToDrawByZ
    );
    const tmpExtent2 = this.tmpExtent;
    const tmpTileRange = this.tmpTileRange_;
    this.newTiles_ = false;
    const viewport = rotation ? getRotatedViewport(
      viewState.center,
      resolution,
      rotation,
      frameState.size
    ) : void 0;
    for (let x = tileRange.minX; x <= tileRange.maxX; ++x) {
      for (let y = tileRange.minY; y <= tileRange.maxY; ++y) {
        if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {
          continue;
        }
        const tile2 = this.getTile(z, x, y, frameState);
        if (this.isDrawableTile(tile2)) {
          const uid = getUid(this);
          if (tile2.getState() == TileState_default.LOADED) {
            tilesToDrawByZ[z][tile2.tileCoord.toString()] = tile2;
            let inTransition = tile2.inTransition(uid);
            if (inTransition && layerState.opacity !== 1) {
              tile2.endTransition(uid);
              inTransition = false;
            }
            if (!this.newTiles_ && (inTransition || !this.renderedTiles.includes(tile2))) {
              this.newTiles_ = true;
            }
          }
          if (tile2.getAlpha(uid, frameState.time) === 1) {
            continue;
          }
        }
        const childTileRange = tileGrid.getTileCoordChildTileRange(
          tile2.tileCoord,
          tmpTileRange,
          tmpExtent2
        );
        let covered = false;
        if (childTileRange) {
          covered = findLoadedTiles(z + 1, childTileRange);
        }
        if (!covered) {
          tileGrid.forEachTileCoordParentTileRange(
            tile2.tileCoord,
            findLoadedTiles,
            tmpTileRange,
            tmpExtent2
          );
        }
      }
    }
    const canvasScale = tileResolution / viewResolution * pixelRatio / tilePixelRatio;
    compose(
      this.pixelTransform,
      frameState.size[0] / 2,
      frameState.size[1] / 2,
      1 / pixelRatio,
      1 / pixelRatio,
      rotation,
      -width / 2,
      -height / 2
    );
    const canvasTransform = toString(this.pixelTransform);
    this.useContainer(target, canvasTransform, this.getBackground(frameState));
    const context = this.context;
    const canvas = context.canvas;
    makeInverse(this.inversePixelTransform, this.pixelTransform);
    compose(
      this.tempTransform,
      width / 2,
      height / 2,
      canvasScale,
      canvasScale,
      0,
      -width / 2,
      -height / 2
    );
    if (canvas.width != width || canvas.height != height) {
      canvas.width = width;
      canvas.height = height;
    } else if (!this.containerReused) {
      context.clearRect(0, 0, width, height);
    }
    if (layerExtent) {
      this.clipUnrotated(context, frameState, layerExtent);
    }
    if (!tileSource.getInterpolate()) {
      context.imageSmoothingEnabled = false;
    }
    this.preRender(context, frameState);
    this.renderedTiles.length = 0;
    let zs = Object.keys(tilesToDrawByZ).map(Number);
    zs.sort(ascending);
    let clips, clipZs, currentClip;
    if (layerState.opacity === 1 && (!this.containerReused || tileSource.getOpaque(frameState.viewState.projection))) {
      zs = zs.reverse();
    } else {
      clips = [];
      clipZs = [];
    }
    for (let i = zs.length - 1; i >= 0; --i) {
      const currentZ = zs[i];
      const currentTilePixelSize = tileSource.getTilePixelSize(
        currentZ,
        pixelRatio,
        projection
      );
      const currentResolution = tileGrid.getResolution(currentZ);
      const currentScale = currentResolution / tileResolution;
      const dx2 = currentTilePixelSize[0] * currentScale * canvasScale;
      const dy2 = currentTilePixelSize[1] * currentScale * canvasScale;
      const originTileCoord = tileGrid.getTileCoordForCoordAndZ(
        getTopLeft(canvasExtent),
        currentZ
      );
      const originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
      const origin = apply(this.tempTransform, [
        tilePixelRatio * (originTileExtent[0] - canvasExtent[0]) / tileResolution,
        tilePixelRatio * (canvasExtent[3] - originTileExtent[3]) / tileResolution
      ]);
      const tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
      const tilesToDraw = tilesToDrawByZ[currentZ];
      for (const tileCoordKey in tilesToDraw) {
        const tile2 = (
          /** @type {import("../../ImageTile.js").default} */
          tilesToDraw[tileCoordKey]
        );
        const tileCoord = tile2.tileCoord;
        const xIndex = originTileCoord[1] - tileCoord[1];
        const nextX = Math.round(origin[0] - (xIndex - 1) * dx2);
        const yIndex = originTileCoord[2] - tileCoord[2];
        const nextY = Math.round(origin[1] - (yIndex - 1) * dy2);
        const x = Math.round(origin[0] - xIndex * dx2);
        const y = Math.round(origin[1] - yIndex * dy2);
        const w = nextX - x;
        const h = nextY - y;
        const transition = z === currentZ;
        const inTransition = transition && tile2.getAlpha(getUid(this), frameState.time) !== 1;
        let contextSaved = false;
        if (!inTransition) {
          if (clips) {
            currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];
            for (let i2 = 0, ii = clips.length; i2 < ii; ++i2) {
              if (z !== currentZ && currentZ < clipZs[i2]) {
                const clip = clips[i2];
                if (intersects(
                  [x, y, x + w, y + h],
                  [clip[0], clip[3], clip[4], clip[7]]
                )) {
                  if (!contextSaved) {
                    context.save();
                    contextSaved = true;
                  }
                  context.beginPath();
                  context.moveTo(currentClip[0], currentClip[1]);
                  context.lineTo(currentClip[2], currentClip[3]);
                  context.lineTo(currentClip[4], currentClip[5]);
                  context.lineTo(currentClip[6], currentClip[7]);
                  context.moveTo(clip[6], clip[7]);
                  context.lineTo(clip[4], clip[5]);
                  context.lineTo(clip[2], clip[3]);
                  context.lineTo(clip[0], clip[1]);
                  context.clip();
                }
              }
            }
            clips.push(currentClip);
            clipZs.push(currentZ);
          } else {
            context.clearRect(x, y, w, h);
          }
        }
        this.drawTileImage(
          tile2,
          frameState,
          x,
          y,
          w,
          h,
          tileGutter,
          transition
        );
        if (clips && !inTransition) {
          if (contextSaved) {
            context.restore();
          }
          this.renderedTiles.unshift(tile2);
        } else {
          this.renderedTiles.push(tile2);
        }
        this.updateUsedTiles(frameState.usedTiles, tileSource, tile2);
      }
    }
    this.renderedRevision = sourceRevision;
    this.renderedResolution = tileResolution;
    this.extentChanged = !this.renderedExtent_ || !equals2(this.renderedExtent_, canvasExtent);
    this.renderedExtent_ = canvasExtent;
    this.renderedPixelRatio = pixelRatio;
    this.renderedProjection = projection;
    this.manageTilePyramid(
      frameState,
      tileSource,
      tileGrid,
      pixelRatio,
      projection,
      extent,
      z,
      tileLayer.getPreload()
    );
    this.scheduleExpireCache(frameState, tileSource);
    this.postRender(context, frameState);
    if (layerState.extent) {
      context.restore();
    }
    context.imageSmoothingEnabled = true;
    if (canvasTransform !== canvas.style.transform) {
      canvas.style.transform = canvasTransform;
    }
    return this.container;
  }
  /**
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {number} x Left of the tile.
   * @param {number} y Top of the tile.
   * @param {number} w Width of the tile.
   * @param {number} h Height of the tile.
   * @param {number} gutter Tile gutter.
   * @param {boolean} transition Apply an alpha transition.
   */
  drawTileImage(tile2, frameState, x, y, w, h, gutter, transition) {
    const image = this.getTileImage(tile2);
    if (!image) {
      return;
    }
    const uid = getUid(this);
    const layerState = frameState.layerStatesArray[frameState.layerIndex];
    const alpha = layerState.opacity * (transition ? tile2.getAlpha(uid, frameState.time) : 1);
    const alphaChanged = alpha !== this.context.globalAlpha;
    if (alphaChanged) {
      this.context.save();
      this.context.globalAlpha = alpha;
    }
    this.context.drawImage(
      image,
      gutter,
      gutter,
      image.width - 2 * gutter,
      image.height - 2 * gutter,
      x,
      y,
      w,
      h
    );
    if (alphaChanged) {
      this.context.restore();
    }
    if (alpha !== layerState.opacity) {
      frameState.animate = true;
    } else if (transition) {
      tile2.endTransition(uid);
    }
  }
  /**
   * @return {HTMLCanvasElement} Image
   */
  getImage() {
    const context = this.context;
    return context ? context.canvas : null;
  }
  /**
   * Get the image from a tile.
   * @param {import("../../ImageTile.js").default} tile Tile.
   * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
   * @protected
   */
  getTileImage(tile2) {
    return tile2.getImage();
  }
  /**
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @protected
   */
  scheduleExpireCache(frameState, tileSource) {
    if (tileSource.canExpireCache()) {
      const postRenderFunction = function(tileSource2, map, frameState2) {
        const tileSourceKey = getUid(tileSource2);
        if (tileSourceKey in frameState2.usedTiles) {
          tileSource2.expireCache(
            frameState2.viewState.projection,
            frameState2.usedTiles[tileSourceKey]
          );
        }
      }.bind(null, tileSource);
      frameState.postRenderFunctions.push(
        /** @type {import("../../Map.js").PostRenderFunction} */
        postRenderFunction
      );
    }
  }
  /**
   * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import('../../Tile.js').default} tile Tile.
   * @protected
   */
  updateUsedTiles(usedTiles, tileSource, tile2) {
    const tileSourceKey = getUid(tileSource);
    if (!(tileSourceKey in usedTiles)) {
      usedTiles[tileSourceKey] = {};
    }
    usedTiles[tileSourceKey][tile2.getKey()] = true;
  }
  /**
   * Manage tile pyramid.
   * This function performs a number of functions related to the tiles at the
   * current zoom and lower zoom levels:
   * - registers idle tiles in frameState.wantedTiles so that they are not
   *   discarded by the tile queue
   * - enqueues missing tiles
   * @param {import("../../Map.js").FrameState} frameState Frame state.
   * @param {import("../../source/Tile.js").default} tileSource Tile source.
   * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @param {number} pixelRatio Pixel ratio.
   * @param {import("../../proj/Projection.js").default} projection Projection.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {number} currentZ Current Z.
   * @param {number} preload Load low resolution tiles up to `preload` levels.
   * @param {function(import("../../Tile.js").default):void} [tileCallback] Tile callback.
   * @protected
   */
  manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, tileCallback) {
    const tileSourceKey = getUid(tileSource);
    if (!(tileSourceKey in frameState.wantedTiles)) {
      frameState.wantedTiles[tileSourceKey] = {};
    }
    const wantedTiles = frameState.wantedTiles[tileSourceKey];
    const tileQueue = frameState.tileQueue;
    const minZoom = tileGrid.getMinZoom();
    const rotation = frameState.viewState.rotation;
    const viewport = rotation ? getRotatedViewport(
      frameState.viewState.center,
      frameState.viewState.resolution,
      rotation,
      frameState.size
    ) : void 0;
    let tileCount = 0;
    let tile2, tileRange, tileResolution, x, y, z;
    for (z = minZoom; z <= currentZ; ++z) {
      tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
      tileResolution = tileGrid.getResolution(z);
      for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
        for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
          if (rotation && !tileGrid.tileCoordIntersectsViewport([z, x, y], viewport)) {
            continue;
          }
          if (currentZ - z <= preload) {
            ++tileCount;
            tile2 = tileSource.getTile(z, x, y, pixelRatio, projection);
            if (tile2.getState() == TileState_default.IDLE) {
              wantedTiles[tile2.getKey()] = true;
              if (!tileQueue.isKeyQueued(tile2.getKey())) {
                tileQueue.enqueue([
                  tile2,
                  tileSourceKey,
                  tileGrid.getTileCoordCenter(tile2.tileCoord),
                  tileResolution
                ]);
              }
            }
            if (tileCallback !== void 0) {
              tileCallback(tile2);
            }
          } else {
            tileSource.useTile(z, x, y, projection);
          }
        }
      }
    }
    tileSource.updateCacheSize(tileCount, projection);
  }
};
var TileLayer_default = CanvasTileLayerRenderer;

// node_modules/ol/layer/Tile.js
var TileLayer = class extends BaseTile_default {
  /**
   * @param {import("./BaseTile.js").Options<TileSourceType>} [options] Tile layer options.
   */
  constructor(options) {
    super(options);
  }
  createRenderer() {
    return new TileLayer_default(this);
  }
};
var Tile_default4 = TileLayer;

// node_modules/ol/control.js
init_Control();

// node_modules/ol/index.js
init_Collection();
init_Disposable();
init_Feature();
init_Image();
init_Image();
init_Object();
init_Observable();
init_View();
init_util();

// resources/js/index.ts
init_View();
init_coordinate();
init_proj();
init_Vector2();
init_Vector();
init_geom();
var import_ol_geocoder = __toESM(require_ol_geocoder(), 1);
init_style2();
window["traineratwot"] = {};
var mPoint = class {
  constructor(view, projection) {
    this.view = view;
    this.projection = projection;
  }
  onChange(callback) {
    try {
      this.view.on("change", () => {
        const [lat, lon] = this.getCoordinates();
        callback(lat, lon);
      });
    } catch (e) {
      console.error(e);
    }
  }
  getCoordinates() {
    return this.view.getCenter();
  }
  setCoordinates(lat, lon) {
    this.view.setCenter(fromLonLat([lat, lon], this.projection));
  }
};
function GetPointMap(id, lat = 0, lon = 0, zoom = 10, lang = "en-US") {
  const projection = "EPSG:4326";
  const mousePositionControl = new MousePosition_default({
    coordinateFormat: createStringXY(4),
    projection,
    className: `mouse-position-${id}`,
    target: document.getElementById(`OSMap-${id}`)
  });
  let point = new Feature_default({
    projection,
    geometry: new Point_default(fromLonLat([lat, lon], projection))
  });
  const vectorSource = new Vector_default2({
    features: [point]
  });
  const vectorLayer = new Vector_default({
    source: vectorSource
  });
  const MapLayer = new Tile_default4({
    source: new OSM_default()
  });
  const target = document.getElementById(`OSMap-${id}`);
  const view = new View_default({
    projection,
    center: fromLonLat([lat, lon], projection),
    zoom
  });
  const map = new Map_default2({
    controls: defaults().extend([mousePositionControl]),
    layers: [
      MapLayer,
      vectorLayer
    ],
    target,
    view
  });
  const geocoder = new import_ol_geocoder.default("nominatim", {
    provider: "osm",
    lang,
    //en-US, fr-FR
    placeholder: "\u041F\u043E\u0438\u0441\u043A...",
    limit: 5,
    keepOpen: true
  });
  map.addControl(geocoder);
  try {
    geocoder.on("addresschosen", function(evt) {
      console.log(evt);
      const feature = evt.feature;
      const coordinate = evt.coordinate;
      feature.setStyle(new Style_default({
        image: new Icon_default({
          color: "rgba(0, 0, 0, 0)",
          crossOrigin: "anonymous",
          src: "https://openlayers.org/en/latest/examples/data/dot.png",
          scale: 0.01
        })
      }));
      view.setCenter(fromLonLat([coordinate[0], coordinate[1]], projection));
    });
  } catch (e) {
    console.error(e);
  }
  function updateCenter() {
    const [lat2, lon2] = map.getView().getCenter();
    point.getGeometry().setCoordinates([lat2, lon2]);
  }
  try {
    map.on("movestart", updateCenter);
    map.on("moveend", updateCenter);
  } catch (e) {
    console.warn(e);
  }
  target.classList.add("map-done");
  return new mPoint(view, projection);
}
window["traineratwot"].GetPointMap = GetPointMap;
/*! Bundled license information:

ol-geocoder/dist/ol-geocoder.js:
  (*!
   * ol-geocoder - v4.3.1
   * A geocoder extension compatible with OpenLayers v6.x, v7.x & v8.x
   * https://github.com/Dominique92/ol-geocoder
   * Built: 15/09/2023 16:57:41
   *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy9FdmVudC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvT2JqZWN0RXZlbnRUeXBlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9EaXNwb3NhYmxlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9hcnJheS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZnVuY3Rpb25zLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9vYmouanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy9UYXJnZXQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy9FdmVudFR5cGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvT2JzZXJ2YWJsZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvdXRpbC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvT2JqZWN0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9Db2xsZWN0aW9uRXZlbnRUeXBlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9Db2xsZWN0aW9uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9oYXMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2Fzc2VydHMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3RyYW5zZm9ybS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZXh0ZW50L1JlbGF0aW9uc2hpcC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZXh0ZW50LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9jb2xvci1zcGFjZS9yZ2IuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2NvbG9yLXNwYWNlL3h5ei5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvY29sb3Itc3BhY2UvbHV2LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9jb2xvci1zcGFjZS9sY2h1di5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvY29sb3ItcGFyc2Uvbm9kZV9tb2R1bGVzL2NvbG9yLW5hbWUvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2NvbG9yLXBhcnNlL2luZGV4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9jb2xvci1zcGFjZS9oc2wuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL2NvbG9yLXJnYmEvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL21hdGguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2NvbG9yLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9JY29uSW1hZ2VDYWNoZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvUHJvcGVydHkuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2xheWVyL0Jhc2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9FdmVudFR5cGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL1ZpZXdIaW50LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9WaWV3UHJvcGVydHkuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3RpbGVncmlkL2NvbW1vbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcHJvai9Vbml0cy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcHJvai9Qcm9qZWN0aW9uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9wcm9qL2Vwc2czODU3LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9wcm9qL2Vwc2c0MzI2LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9wcm9qL3Byb2plY3Rpb25zLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9wcm9qL3RyYW5zZm9ybXMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3N0cmluZy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvY29vcmRpbmF0ZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc3BoZXJlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9jb25zb2xlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9wcm9qLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9jZW50ZXJjb25zdHJhaW50LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZXNvbHV0aW9uY29uc3RyYWludC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcm90YXRpb25jb25zdHJhaW50LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9lYXNpbmcuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC90cmFuc2Zvcm0uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vR2VvbWV0cnkuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vU2ltcGxlR2VvbWV0cnkuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9jbG9zZXN0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvZGVmbGF0ZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L3NpbXBsaWZ5LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvaW5mbGF0ZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2FyZWEuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vTGluZWFyUmluZy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9Qb2ludC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2NvbnRhaW5zLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvaW50ZXJpb3Jwb2ludC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L3NlZ21lbnRzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvaW50ZXJzZWN0c2V4dGVudC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L3JldmVyc2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9vcmllbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vUG9seWdvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvVmlldy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvTGF5ZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9FdmVudC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvY3NzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9kb20uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL01hcEV2ZW50VHlwZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvY29udHJvbC9Db250cm9sLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zaXplLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9JbWFnZVN0YXRlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9JbWFnZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc291cmNlL1NvdXJjZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyZXIvTGF5ZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL2NhbnZhcy9MYXllci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvRmVhdHVyZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvRmlsbC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2ludGVycG9sYXRlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL2ZsYXQvbGVuZ3RoLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL0xpbmVTdHJpbmcuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL1N0cm9rZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvSW1hZ2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2NvbG9ybGlrZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvUmVndWxhclNoYXBlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9DaXJjbGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL1N0eWxlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS9UZXh0LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9xdWlja3NlbGVjdC9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvcmJ1c2gvaW5kZXguanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3N0eWxlL0ljb25JbWFnZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvc3R5bGUvSWNvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZXhwci9leHByZXNzaW9uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9leHByL2NwdS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL2NhbnZhcy9zdHlsZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvbGF5ZXIvQmFzZVZlY3Rvci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL2NhbnZhcy9JbnN0cnVjdGlvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL1ZlY3RvckNvbnRleHQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvQnVpbGRlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL2NhbnZhcy9JbWFnZUJ1aWxkZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvTGluZVN0cmluZ0J1aWxkZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvUG9seWdvbkJ1aWxkZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9saW5lY2h1bmsuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vZmxhdC9zdHJhaWdodGNodW5rLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL1RleHRCdWlsZGVyLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL0J1aWxkZXJHcm91cC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L3RleHRwYXRoLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL0V4ZWN1dG9yLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXIvY2FudmFzL0V4ZWN1dG9yR3JvdXAuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9jYW52YXMvSW1tZWRpYXRlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zdHlsZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL2NhbnZhcy9oaXRkZXRlY3QuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL3ZlY3Rvci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyZXIvY2FudmFzL1ZlY3RvckxheWVyLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9sYXllci9WZWN0b3IuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3N0cnVjdHMvUkJ1c2guanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vQ2lyY2xlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9nZW9tL0dlb21ldHJ5Q29sbGVjdGlvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9NdWx0aUxpbmVTdHJpbmcuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20vTXVsdGlQb2ludC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9mbGF0L2NlbnRlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZ2VvbS9NdWx0aVBvbHlnb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2dlb20uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlci9GZWF0dXJlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvVmVjdG9yRXZlbnRUeXBlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9sb2FkaW5nc3RyYXRlZ3kuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2ZlYXR1cmVsb2FkZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9WZWN0b3IuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sLWdlb2NvZGVyL2tvbnN0YW50cy9pbmRleC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wtZ2VvY29kZXIvc3JjL2hlbHBlcnMvbWl4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC1nZW9jb2Rlci9zcmMvaGVscGVycy9kb20uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sLWdlb2NvZGVyL3NyYy9odG1sLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC1nZW9jb2Rlci9zcmMvaGVscGVycy9hamF4LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC1nZW9jb2Rlci9zcmMvcHJvdmlkZXJzL3Bob3Rvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wtZ2VvY29kZXIvc3JjL3Byb3ZpZGVycy9vc20uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sLWdlb2NvZGVyL3NyYy9wcm92aWRlcnMvbWFwcXVlc3QuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sLWdlb2NvZGVyL3NyYy9wcm92aWRlcnMvYmluZy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wtZ2VvY29kZXIvc3JjL3Byb3ZpZGVycy9vcGVuY2FnZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wtZ2VvY29kZXIvc3JjL25vbWluYXRpbS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wtZ2VvY29kZXIvc3JjL2Jhc2UuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlbmRlcmVyL01hcC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyZXIvQ29tcG9zaXRlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9sYXllci9Hcm91cC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvTWFwRXZlbnQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL01hcEJyb3dzZXJFdmVudC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvTWFwQnJvd3NlckV2ZW50VHlwZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcG9pbnRlci9FdmVudFR5cGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL01hcEJyb3dzZXJFdmVudEhhbmRsZXIuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL01hcFByb3BlcnR5LmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zdHJ1Y3RzL1ByaW9yaXR5UXVldWUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL1RpbGVTdGF0ZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvVGlsZVF1ZXVlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL0F0dHJpYnV0aW9uLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL1JvdGF0ZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvY29udHJvbC9ab29tLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL2RlZmF1bHRzLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9Qcm9wZXJ0eS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vSW50ZXJhY3Rpb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0RvdWJsZUNsaWNrWm9vbS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vUG9pbnRlci5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvZXZlbnRzL2NvbmRpdGlvbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vRHJhZ1Bhbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vRHJhZ1JvdGF0ZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVuZGVyL0JveC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vRHJhZ0JveC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vRHJhZ1pvb20uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2V2ZW50cy9LZXkuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL0tleWJvYXJkUGFuLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9LZXlib2FyZFpvb20uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL0tpbmV0aWMuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2ludGVyYWN0aW9uL01vdXNlV2hlZWxab29tLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9QaW5jaFJvdGF0ZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvaW50ZXJhY3Rpb24vUGluY2hab29tLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9pbnRlcmFjdGlvbi9kZWZhdWx0cy5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvTWFwLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sL01vdXNlUG9zaXRpb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL1RpbGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL0ltYWdlVGlsZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVwcm9qL2NvbW1vbi5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVwcm9qL1RyaWFuZ3VsYXRpb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3JlcHJvai5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvcmVwcm9qL1RpbGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3N0cnVjdHMvTFJVQ2FjaGUuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3RpbGVjb29yZC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvVGlsZUNhY2hlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvVGlsZUV2ZW50VHlwZS5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvVGlsZVJhbmdlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC90aWxlZ3JpZC9UaWxlR3JpZC5qcyIsICIuLi8uLi9ub2RlX21vZHVsZXMvb2wvdGlsZWdyaWQuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9UaWxlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC90aWxldXJsZnVuY3Rpb24uanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL3NvdXJjZS9VcmxUaWxlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvVGlsZUltYWdlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvWFlaLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9zb3VyY2UvT1NNLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9sYXllci9UaWxlUHJvcGVydHkuanMiLCAiLi4vLi4vbm9kZV9tb2R1bGVzL29sL2xheWVyL0Jhc2VUaWxlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9yZW5kZXJlci9jYW52YXMvVGlsZUxheWVyLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9sYXllci9UaWxlLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9jb250cm9sLmpzIiwgIi4uLy4uL25vZGVfbW9kdWxlcy9vbC9pbmRleC5qcyIsICIuLi9qcy9pbmRleC50cyJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUVPLFNBQVMsZ0JBQWdCLEtBQUs7QUFDbkMsTUFBSSxnQkFBZ0I7QUFDdEI7QUFLTyxTQUFTLGVBQWUsS0FBSztBQUNsQyxNQUFJLGVBQWU7QUFDckI7QUExRUEsSUFjTSxXQThEQztBQTVFUDtBQUFBO0FBY0EsSUFBTSxZQUFOLE1BQWdCO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFJZCxZQUFZLE1BQU07QUFJaEIsYUFBSztBQUtMLGFBQUs7QUFPTCxhQUFLLE9BQU87QUFPWixhQUFLLFNBQVM7QUFBQSxNQUNoQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLGlCQUFpQjtBQUNmLGFBQUssbUJBQW1CO0FBQUEsTUFDMUI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsa0JBQWtCO0FBQ2hCLGFBQUsscUJBQXFCO0FBQUEsTUFDNUI7QUFBQSxJQUNGO0FBZ0JBLElBQU8sZ0JBQVE7QUFBQTtBQUFBOzs7QUM1RWYsSUFPTztBQVBQO0FBQUE7QUFPQSxJQUFPLDBCQUFRO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTWIsZ0JBQWdCO0FBQUEsSUFDbEI7QUFBQTtBQUFBOzs7QUNkQSxJQVFNLFlBMkJDO0FBbkNQO0FBQUE7QUFRQSxJQUFNLGFBQU4sTUFBaUI7QUFBQSxNQUNmLGNBQWM7QUFNWixhQUFLLFdBQVc7QUFBQSxNQUNsQjtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsVUFBVTtBQUNSLFlBQUksQ0FBQyxLQUFLLFVBQVU7QUFDbEIsZUFBSyxXQUFXO0FBQ2hCLGVBQUssZ0JBQWdCO0FBQUEsUUFDdkI7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLGtCQUFrQjtBQUFBLE1BQUM7QUFBQSxJQUNyQjtBQUVBLElBQU8scUJBQVE7QUFBQTtBQUFBOzs7QUN0QlIsU0FBUyxhQUFhLFVBQVUsUUFBUSxZQUFZO0FBQ3pELE1BQUksS0FBSztBQUNULGVBQWEsY0FBYztBQUMzQixNQUFJLE1BQU07QUFDVixNQUFJLE9BQU8sU0FBUztBQUNwQixNQUFJLFFBQVE7QUFFWixTQUFPLE1BQU0sTUFBTTtBQUdqQixVQUFNLE9BQVEsT0FBTyxPQUFRO0FBQzdCLFVBQU0sQ0FBQyxXQUFXLFNBQVMsR0FBRyxHQUFHLE1BQU07QUFFdkMsUUFBSSxNQUFNLEdBQUs7QUFFYixZQUFNLE1BQU07QUFBQSxJQUNkLE9BQU87QUFFTCxhQUFPO0FBQ1AsY0FBUSxDQUFDO0FBQUEsSUFDWDtBQUFBLEVBQ0Y7QUFHQSxTQUFPLFFBQVEsTUFBTSxDQUFDO0FBQ3hCO0FBU08sU0FBUyxVQUFVLEdBQUcsR0FBRztBQUM5QixTQUFPLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxLQUFLO0FBQ2xDO0FBU08sU0FBUyxXQUFXLEdBQUcsR0FBRztBQUMvQixTQUFPLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxLQUFLO0FBQ2xDO0FBeUJPLFNBQVMsa0JBQWtCLEtBQUssUUFBUSxXQUFXO0FBQ3hELE1BQUksSUFBSSxDQUFDLEtBQUssUUFBUTtBQUNwQixXQUFPO0FBQUEsRUFDVDtBQUVBLFFBQU0sSUFBSSxJQUFJO0FBQ2QsTUFBSSxVQUFVLElBQUksSUFBSSxDQUFDLEdBQUc7QUFDeEIsV0FBTyxJQUFJO0FBQUEsRUFDYjtBQUVBLE1BQUksT0FBTyxjQUFjLFlBQVk7QUFDbkMsYUFBUyxJQUFJLEdBQUcsSUFBSSxHQUFHLEVBQUUsR0FBRztBQUMxQixZQUFNLFlBQVksSUFBSSxDQUFDO0FBQ3ZCLFVBQUksY0FBYyxRQUFRO0FBQ3hCLGVBQU87QUFBQSxNQUNUO0FBQ0EsVUFBSSxZQUFZLFFBQVE7QUFDdEIsWUFBSSxVQUFVLFFBQVEsSUFBSSxJQUFJLENBQUMsR0FBRyxTQUFTLElBQUksR0FBRztBQUNoRCxpQkFBTyxJQUFJO0FBQUEsUUFDYjtBQUNBLGVBQU87QUFBQSxNQUNUO0FBQUEsSUFDRjtBQUNBLFdBQU8sSUFBSTtBQUFBLEVBQ2I7QUFFQSxNQUFJLFlBQVksR0FBRztBQUNqQixhQUFTLElBQUksR0FBRyxJQUFJLEdBQUcsRUFBRSxHQUFHO0FBQzFCLFVBQUksSUFBSSxDQUFDLElBQUksUUFBUTtBQUNuQixlQUFPLElBQUk7QUFBQSxNQUNiO0FBQUEsSUFDRjtBQUNBLFdBQU8sSUFBSTtBQUFBLEVBQ2I7QUFFQSxNQUFJLFlBQVksR0FBRztBQUNqQixhQUFTLElBQUksR0FBRyxJQUFJLEdBQUcsRUFBRSxHQUFHO0FBQzFCLFVBQUksSUFBSSxDQUFDLEtBQUssUUFBUTtBQUNwQixlQUFPO0FBQUEsTUFDVDtBQUFBLElBQ0Y7QUFDQSxXQUFPLElBQUk7QUFBQSxFQUNiO0FBRUEsV0FBUyxJQUFJLEdBQUcsSUFBSSxHQUFHLEVBQUUsR0FBRztBQUMxQixRQUFJLElBQUksQ0FBQyxLQUFLLFFBQVE7QUFDcEIsYUFBTztBQUFBLElBQ1Q7QUFDQSxRQUFJLElBQUksQ0FBQyxJQUFJLFFBQVE7QUFDbkIsVUFBSSxJQUFJLElBQUksQ0FBQyxJQUFJLFNBQVMsU0FBUyxJQUFJLENBQUMsR0FBRztBQUN6QyxlQUFPLElBQUk7QUFBQSxNQUNiO0FBQ0EsYUFBTztBQUFBLElBQ1Q7QUFBQSxFQUNGO0FBQ0EsU0FBTyxJQUFJO0FBQ2I7QUFPTyxTQUFTLGdCQUFnQixLQUFLLE9BQU8sS0FBSztBQUMvQyxTQUFPLFFBQVEsS0FBSztBQUNsQixVQUFNLE1BQU0sSUFBSSxLQUFLO0FBQ3JCLFFBQUksS0FBSyxJQUFJLElBQUksR0FBRztBQUNwQixRQUFJLEdBQUcsSUFBSTtBQUNYLE1BQUU7QUFDRixNQUFFO0FBQUEsRUFDSjtBQUNGO0FBT08sU0FBUyxPQUFPLEtBQUssTUFBTTtBQUNoQyxRQUFNLFlBQVksTUFBTSxRQUFRLElBQUksSUFBSSxPQUFPLENBQUMsSUFBSTtBQUNwRCxRQUFNLFNBQVMsVUFBVTtBQUN6QixXQUFTLElBQUksR0FBRyxJQUFJLFFBQVEsS0FBSztBQUMvQixRQUFJLElBQUksTUFBTSxJQUFJLFVBQVUsQ0FBQztBQUFBLEVBQy9CO0FBQ0Y7QUFRTyxTQUFTLE9BQU8sS0FBSyxLQUFLO0FBQy9CLFFBQU0sSUFBSSxJQUFJLFFBQVEsR0FBRztBQUN6QixRQUFNLFFBQVEsSUFBSTtBQUNsQixNQUFJLE9BQU87QUFDVCxRQUFJLE9BQU8sR0FBRyxDQUFDO0FBQUEsRUFDakI7QUFDQSxTQUFPO0FBQ1Q7QUFPTyxTQUFTLE9BQU8sTUFBTSxNQUFNO0FBQ2pDLFFBQU0sT0FBTyxLQUFLO0FBQ2xCLE1BQUksU0FBUyxLQUFLLFFBQVE7QUFDeEIsV0FBTztBQUFBLEVBQ1Q7QUFDQSxXQUFTLElBQUksR0FBRyxJQUFJLE1BQU0sS0FBSztBQUM3QixRQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxHQUFHO0FBQ3ZCLGFBQU87QUFBQSxJQUNUO0FBQUEsRUFDRjtBQUNBLFNBQU87QUFDVDtBQVNPLFNBQVMsV0FBVyxLQUFLLFlBQVk7QUFDMUMsUUFBTSxTQUFTLElBQUk7QUFDbkIsUUFBTSxNQUFNLE1BQU0sSUFBSSxNQUFNO0FBQzVCLE1BQUk7QUFDSixPQUFLLElBQUksR0FBRyxJQUFJLFFBQVEsS0FBSztBQUMzQixRQUFJLENBQUMsSUFBSSxFQUFDLE9BQU8sR0FBRyxPQUFPLElBQUksQ0FBQyxFQUFDO0FBQUEsRUFDbkM7QUFDQSxNQUFJLEtBQUssU0FBVSxHQUFHLEdBQUc7QUFDdkIsV0FBTyxXQUFXLEVBQUUsT0FBTyxFQUFFLEtBQUssS0FBSyxFQUFFLFFBQVEsRUFBRTtBQUFBLEVBQ3JELENBQUM7QUFDRCxPQUFLLElBQUksR0FBRyxJQUFJLElBQUksUUFBUSxLQUFLO0FBQy9CLFFBQUksQ0FBQyxJQUFJLElBQUksQ0FBQyxFQUFFO0FBQUEsRUFDbEI7QUFDRjtBQVFPLFNBQVMsU0FBUyxLQUFLLE1BQU0sUUFBUTtBQUMxQyxRQUFNLFVBQVUsUUFBUTtBQUN4QixTQUFPLElBQUksTUFBTSxTQUFVLFlBQVksT0FBTztBQUM1QyxRQUFJLFVBQVUsR0FBRztBQUNmLGFBQU87QUFBQSxJQUNUO0FBQ0EsVUFBTSxNQUFNLFFBQVEsSUFBSSxRQUFRLENBQUMsR0FBRyxVQUFVO0FBQzlDLFdBQU8sRUFBRSxNQUFNLEtBQU0sVUFBVSxRQUFRO0FBQUEsRUFDekMsQ0FBQztBQUNIO0FBalBBO0FBQUE7QUFBQTtBQUFBOzs7QUNVTyxTQUFTLE9BQU87QUFDckIsU0FBTztBQUNUO0FBTU8sU0FBUyxRQUFRO0FBQ3RCLFNBQU87QUFDVDtBQU9PLFNBQVMsT0FBTztBQUFDO0FBV2pCLFNBQVMsV0FBVyxJQUFJO0FBQzdCLE1BQUksU0FBUztBQUdiLE1BQUk7QUFHSixNQUFJO0FBRUosTUFBSTtBQUVKLFNBQU8sV0FBWTtBQUNqQixVQUFNLFdBQVcsTUFBTSxVQUFVLE1BQU0sS0FBSyxTQUFTO0FBQ3JELFFBQUksQ0FBQyxVQUFVLFNBQVMsWUFBWSxDQUFDLE9BQVksVUFBVSxRQUFRLEdBQUc7QUFDcEUsZUFBUztBQUNULGlCQUFXO0FBQ1gsaUJBQVc7QUFDWCxtQkFBYSxHQUFHLE1BQU0sTUFBTSxTQUFTO0FBQUEsSUFDdkM7QUFDQSxXQUFPO0FBQUEsRUFDVDtBQUNGO0FBT08sU0FBUyxVQUFVLFFBQVE7QUFDaEMsV0FBUyxnQkFBZ0I7QUFDdkIsUUFBSTtBQUNKLFFBQUk7QUFDRixjQUFRLE9BQU87QUFBQSxJQUNqQixTQUFTLEtBQUs7QUFDWixhQUFPLFFBQVEsT0FBTyxHQUFHO0FBQUEsSUFDM0I7QUFDQSxRQUFJLGlCQUFpQixTQUFTO0FBQzVCLGFBQU87QUFBQSxJQUNUO0FBQ0EsV0FBTyxRQUFRLFFBQVEsS0FBSztBQUFBLEVBQzlCO0FBQ0EsU0FBTyxjQUFjO0FBQ3ZCO0FBaEZBO0FBQUE7QUFJQTtBQUFBO0FBQUE7OztBQ0lPLFNBQVMsTUFBTSxRQUFRO0FBQzVCLGFBQVcsWUFBWSxRQUFRO0FBQzdCLFdBQU8sT0FBTyxRQUFRO0FBQUEsRUFDeEI7QUFDRjtBQU9PLFNBQVMsUUFBUSxRQUFRO0FBQzlCLE1BQUk7QUFDSixPQUFLLFlBQVksUUFBUTtBQUN2QixXQUFPO0FBQUEsRUFDVDtBQUNBLFNBQU8sQ0FBQztBQUNWO0FBekJBO0FBQUE7QUFBQTtBQUFBOzs7QUNBQSxJQTJCTSxRQW9LQztBQS9MUDtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFxQkEsSUFBTSxTQUFOLGNBQXFCLG1CQUFXO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFJOUIsWUFBWSxRQUFRO0FBQ2xCLGNBQU07QUFNTixhQUFLLGVBQWU7QUFNcEIsYUFBSyxtQkFBbUI7QUFNeEIsYUFBSyxlQUFlO0FBTXBCLGFBQUssYUFBYTtBQUFBLE1BQ3BCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLGlCQUFpQixNQUFNLFVBQVU7QUFDL0IsWUFBSSxDQUFDLFFBQVEsQ0FBQyxVQUFVO0FBQ3RCO0FBQUEsUUFDRjtBQUNBLGNBQU0sWUFBWSxLQUFLLGVBQWUsS0FBSyxhQUFhLENBQUM7QUFDekQsY0FBTSxtQkFBbUIsVUFBVSxJQUFJLE1BQU0sVUFBVSxJQUFJLElBQUksQ0FBQztBQUNoRSxZQUFJLENBQUMsaUJBQWlCLFNBQVMsUUFBUSxHQUFHO0FBQ3hDLDJCQUFpQixLQUFLLFFBQVE7QUFBQSxRQUNoQztBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BWUEsY0FBYyxPQUFPO0FBQ25CLGNBQU0sV0FBVyxPQUFPLFVBQVU7QUFDbEMsY0FBTSxPQUFPLFdBQVcsUUFBUSxNQUFNO0FBQ3RDLGNBQU0sWUFBWSxLQUFLLGNBQWMsS0FBSyxXQUFXLElBQUk7QUFDekQsWUFBSSxDQUFDLFdBQVc7QUFDZDtBQUFBLFFBQ0Y7QUFFQSxjQUFNLE1BQU0sV0FBVyxJQUFJLGNBQU0sS0FBSztBQUFBO0FBQUEsVUFBMEI7QUFBQTtBQUNoRSxZQUFJLENBQUMsSUFBSSxRQUFRO0FBQ2YsY0FBSSxTQUFTLEtBQUssZ0JBQWdCO0FBQUEsUUFDcEM7QUFDQSxjQUFNLGNBQWMsS0FBSyxpQkFBaUIsS0FBSyxlQUFlLENBQUM7QUFDL0QsY0FBTSxrQkFDSixLQUFLLHFCQUFxQixLQUFLLG1CQUFtQixDQUFDO0FBQ3JELFlBQUksRUFBRSxRQUFRLGNBQWM7QUFDMUIsc0JBQVksSUFBSSxJQUFJO0FBQ3BCLDBCQUFnQixJQUFJLElBQUk7QUFBQSxRQUMxQjtBQUNBLFVBQUUsWUFBWSxJQUFJO0FBQ2xCLFlBQUk7QUFDSixpQkFBUyxJQUFJLEdBQUcsS0FBSyxVQUFVLFFBQVEsSUFBSSxJQUFJLEVBQUUsR0FBRztBQUNsRCxjQUFJLGlCQUFpQixVQUFVLENBQUMsR0FBRztBQUNqQztBQUFBLFlBQ0UsVUFBVSxDQUFDLEVBQ1gsWUFBWSxHQUFHO0FBQUEsVUFDbkIsT0FBTztBQUNMO0FBQUEsWUFDRSxVQUFVLENBQUMsRUFDWCxLQUFLLE1BQU0sR0FBRztBQUFBLFVBQ2xCO0FBQ0EsY0FBSSxjQUFjLFNBQVMsSUFBSSxvQkFBb0I7QUFDakQsd0JBQVk7QUFDWjtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQ0EsWUFBSSxFQUFFLFlBQVksSUFBSSxNQUFNLEdBQUc7QUFDN0IsY0FBSSxLQUFLLGdCQUFnQixJQUFJO0FBQzdCLGlCQUFPLGdCQUFnQixJQUFJO0FBQzNCLGlCQUFPLE1BQU07QUFDWCxpQkFBSyxvQkFBb0IsTUFBTSxJQUFJO0FBQUEsVUFDckM7QUFDQSxpQkFBTyxZQUFZLElBQUk7QUFBQSxRQUN6QjtBQUNBLGVBQU87QUFBQSxNQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLQSxrQkFBa0I7QUFDaEIsYUFBSyxjQUFjLE1BQU0sS0FBSyxVQUFVO0FBQUEsTUFDMUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BU0EsYUFBYSxNQUFNO0FBQ2pCLGVBQVEsS0FBSyxjQUFjLEtBQUssV0FBVyxJQUFJLEtBQU07QUFBQSxNQUN2RDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFlBQVksTUFBTTtBQUNoQixZQUFJLENBQUMsS0FBSyxZQUFZO0FBQ3BCLGlCQUFPO0FBQUEsUUFDVDtBQUNBLGVBQU8sT0FDSCxRQUFRLEtBQUssYUFDYixPQUFPLEtBQUssS0FBSyxVQUFVLEVBQUUsU0FBUztBQUFBLE1BQzVDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLG9CQUFvQixNQUFNLFVBQVU7QUFDbEMsWUFBSSxDQUFDLEtBQUssWUFBWTtBQUNwQjtBQUFBLFFBQ0Y7QUFDQSxjQUFNLFlBQVksS0FBSyxXQUFXLElBQUk7QUFDdEMsWUFBSSxDQUFDLFdBQVc7QUFDZDtBQUFBLFFBQ0Y7QUFDQSxjQUFNLFFBQVEsVUFBVSxRQUFRLFFBQVE7QUFDeEMsWUFBSSxVQUFVLElBQUk7QUFDaEIsY0FBSSxLQUFLLG9CQUFvQixRQUFRLEtBQUssa0JBQWtCO0FBRTFELHNCQUFVLEtBQUssSUFBSTtBQUNuQixjQUFFLEtBQUssaUJBQWlCLElBQUk7QUFBQSxVQUM5QixPQUFPO0FBQ0wsc0JBQVUsT0FBTyxPQUFPLENBQUM7QUFDekIsZ0JBQUksVUFBVSxXQUFXLEdBQUc7QUFDMUIscUJBQU8sS0FBSyxXQUFXLElBQUk7QUFBQSxZQUM3QjtBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFFQSxJQUFPLGlCQUFRO0FBQUE7QUFBQTs7O0FDL0xmLElBUU87QUFSUDtBQUFBO0FBUUEsSUFBTyxvQkFBUTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1iLFFBQVE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFPUixPQUFPO0FBQUEsTUFFUCxNQUFNO0FBQUEsTUFDTixPQUFPO0FBQUEsTUFDUCxhQUFhO0FBQUEsTUFDYixPQUFPO0FBQUEsTUFDUCxVQUFVO0FBQUEsTUFDVixXQUFXO0FBQUEsTUFDWCxVQUFVO0FBQUEsTUFDVixNQUFNO0FBQUEsTUFDTixPQUFPO0FBQUEsTUFDUCxTQUFTO0FBQUEsTUFDVCxVQUFVO0FBQUEsTUFDVixNQUFNO0FBQUEsTUFDTixRQUFRO0FBQUEsTUFDUixXQUFXO0FBQUEsTUFDWCxPQUFPO0FBQUEsSUFDVDtBQUFBO0FBQUE7OztBQ1FPLFNBQVMsT0FBTyxRQUFRLE1BQU0sVUFBVSxTQUFTLE1BQU07QUFDNUQsTUFBSSxXQUFXLFlBQVksUUFBUTtBQUNqQyxlQUFXLFNBQVMsS0FBSyxPQUFPO0FBQUEsRUFDbEM7QUFDQSxNQUFJLE1BQU07QUFDUixVQUFNLG1CQUFtQjtBQUN6QixlQUFXLFdBQVk7QUFDckIsYUFBTyxvQkFBb0IsTUFBTSxRQUFRO0FBQ3pDLHVCQUFpQixNQUFNLE1BQU0sU0FBUztBQUFBLElBQ3hDO0FBQUEsRUFDRjtBQUNBLFFBQU0sWUFBWTtBQUFBLElBQ2hCO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxFQUNGO0FBQ0EsU0FBTyxpQkFBaUIsTUFBTSxRQUFRO0FBQ3RDLFNBQU87QUFDVDtBQXNCTyxTQUFTLFdBQVcsUUFBUSxNQUFNLFVBQVUsU0FBUztBQUMxRCxTQUFPLE9BQU8sUUFBUSxNQUFNLFVBQVUsU0FBUyxJQUFJO0FBQ3JEO0FBV08sU0FBUyxjQUFjLEtBQUs7QUFDakMsTUFBSSxPQUFPLElBQUksUUFBUTtBQUNyQixRQUFJLE9BQU8sb0JBQW9CLElBQUksTUFBTSxJQUFJLFFBQVE7QUFDckQsVUFBTSxHQUFHO0FBQUEsRUFDWDtBQUNGO0FBeEdBO0FBQUE7QUFHQTtBQUFBO0FBQUE7OztBQ2lMTyxTQUFTLFFBQVEsS0FBSztBQUMzQixNQUFJLE1BQU0sUUFBUSxHQUFHLEdBQUc7QUFDdEIsYUFBUyxJQUFJLEdBQUcsS0FBSyxJQUFJLFFBQVEsSUFBSSxJQUFJLEVBQUUsR0FBRztBQUM1QyxvQkFBYyxJQUFJLENBQUMsQ0FBQztBQUFBLElBQ3RCO0FBQUEsRUFDRixPQUFPO0FBQ0w7QUFBQTtBQUFBLE1BQThEO0FBQUEsSUFBSTtBQUFBLEVBQ3BFO0FBQ0Y7QUE1TEEsSUF3Q00sWUFzSkM7QUE5TFA7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQW1DQSxJQUFNLGFBQU4sY0FBeUIsZUFBWTtBQUFBLE1BQ25DLGNBQWM7QUFDWixjQUFNO0FBRU4sYUFBSztBQUFBLFFBRUQsS0FBSztBQUdULGFBQUs7QUFBQSxRQUVELEtBQUs7QUFHVCxhQUFLO0FBQUEsUUFBaUQsS0FBSztBQU0zRCxhQUFLLFlBQVk7QUFBQSxNQUNuQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxVQUFVO0FBQ1IsVUFBRSxLQUFLO0FBQ1AsYUFBSyxjQUFjLGtCQUFVLE1BQU07QUFBQSxNQUNyQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsY0FBYztBQUNaLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFdBQVcsTUFBTSxVQUFVO0FBQ3pCLFlBQUksTUFBTSxRQUFRLElBQUksR0FBRztBQUN2QixnQkFBTSxNQUFNLEtBQUs7QUFDakIsZ0JBQU0sT0FBTyxJQUFJLE1BQU0sR0FBRztBQUMxQixtQkFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLEVBQUUsR0FBRztBQUM1QixpQkFBSyxDQUFDLElBQUksT0FBTyxNQUFNLEtBQUssQ0FBQyxHQUFHLFFBQVE7QUFBQSxVQUMxQztBQUNBLGlCQUFPO0FBQUEsUUFDVDtBQUNBLGVBQU87QUFBQSxVQUFPO0FBQUE7QUFBQSxVQUE2QjtBQUFBLFVBQU87QUFBQSxRQUFRO0FBQUEsTUFDNUQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLGFBQWEsTUFBTSxVQUFVO0FBQzNCLFlBQUk7QUFDSixZQUFJLE1BQU0sUUFBUSxJQUFJLEdBQUc7QUFDdkIsZ0JBQU0sTUFBTSxLQUFLO0FBQ2pCLGdCQUFNLElBQUksTUFBTSxHQUFHO0FBQ25CLG1CQUFTLElBQUksR0FBRyxJQUFJLEtBQUssRUFBRSxHQUFHO0FBQzVCLGdCQUFJLENBQUMsSUFBSSxXQUFXLE1BQU0sS0FBSyxDQUFDLEdBQUcsUUFBUTtBQUFBLFVBQzdDO0FBQUEsUUFDRixPQUFPO0FBQ0wsZ0JBQU07QUFBQSxZQUFXO0FBQUE7QUFBQSxZQUE2QjtBQUFBLFlBQU87QUFBQSxVQUFRO0FBQUEsUUFDL0Q7QUFDc0IsUUFBQyxTQUFVLFNBQVM7QUFDMUMsZUFBTztBQUFBLE1BQ1Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFdBQVcsTUFBTSxVQUFVO0FBQ3pCLGNBQU07QUFBQTtBQUFBLFVBQTZCLFNBQVU7QUFBQTtBQUM3QyxZQUFJLEtBQUs7QUFDUCxrQkFBUSxHQUFHO0FBQUEsUUFDYixXQUFXLE1BQU0sUUFBUSxJQUFJLEdBQUc7QUFDOUIsbUJBQVMsSUFBSSxHQUFHLEtBQUssS0FBSyxRQUFRLElBQUksSUFBSSxFQUFFLEdBQUc7QUFDN0MsaUJBQUssb0JBQW9CLEtBQUssQ0FBQyxHQUFHLFFBQVE7QUFBQSxVQUM1QztBQUFBLFFBQ0YsT0FBTztBQUNMLGVBQUssb0JBQW9CLE1BQU0sUUFBUTtBQUFBLFFBQ3pDO0FBQUEsTUFDRjtBQUFBLElBQ0Y7QUFZQSxlQUFXLFVBQVU7QUFZckIsZUFBVyxVQUFVO0FBU3JCLGVBQVcsVUFBVTtBQWtCckIsSUFBTyxxQkFBUTtBQUFBO0FBQUE7OztBQ3ZMUixTQUFTLFdBQVc7QUFDekIsUUFBTSxJQUFJLE1BQU0sZ0NBQWdDO0FBQ2xEO0FBa0JPLFNBQVMsT0FBTyxLQUFLO0FBQzFCLFNBQU8sSUFBSSxXQUFXLElBQUksU0FBUyxPQUFPLEVBQUUsV0FBVztBQUN6RDtBQTdCQSxJQWdCSSxhQW1CUztBQW5DYjtBQUFBO0FBZ0JBLElBQUksY0FBYztBQW1CWCxJQUFNLFVBQVU7QUFBQTtBQUFBOzs7QUNuQ3ZCLElBYWEsYUE0RVAsWUF1TEM7QUFoUlA7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFNTyxJQUFNLGNBQU4sY0FBMEIsY0FBTTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1yQyxZQUFZLE1BQU0sS0FBSyxVQUFVO0FBQy9CLGNBQU0sSUFBSTtBQU9WLGFBQUssTUFBTTtBQVFYLGFBQUssV0FBVztBQUFBLE1BQ2xCO0FBQUEsSUFDRjtBQW9EQSxJQUFNLGFBQU4sY0FBeUIsbUJBQVc7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUlsQyxZQUFZLFFBQVE7QUFDbEIsY0FBTTtBQUtOLGFBQUs7QUFLTCxhQUFLO0FBS0wsYUFBSztBQU1MLGVBQU8sSUFBSTtBQU1YLGFBQUssVUFBVTtBQUVmLFlBQUksV0FBVyxRQUFXO0FBQ3hCLGVBQUssY0FBYyxNQUFNO0FBQUEsUUFDM0I7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxJQUFJLEtBQUs7QUFDUCxZQUFJO0FBQ0osWUFBSSxLQUFLLFdBQVcsS0FBSyxRQUFRLGVBQWUsR0FBRyxHQUFHO0FBQ3BELGtCQUFRLEtBQUssUUFBUSxHQUFHO0FBQUEsUUFDMUI7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU9BLFVBQVU7QUFDUixlQUFRLEtBQUssV0FBVyxPQUFPLEtBQUssS0FBSyxPQUFPLEtBQU0sQ0FBQztBQUFBLE1BQ3pEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsZ0JBQWdCO0FBQ2QsZUFBUSxLQUFLLFdBQVcsT0FBTyxPQUFPLENBQUMsR0FBRyxLQUFLLE9BQU8sS0FBTSxDQUFDO0FBQUEsTUFDL0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTUEsd0JBQXdCO0FBQ3RCLGVBQU8sS0FBSztBQUFBLE1BQ2Q7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtBLGdCQUFnQjtBQUNkLGVBQU8sQ0FBQyxDQUFDLEtBQUs7QUFBQSxNQUNoQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxPQUFPLEtBQUssVUFBVTtBQUNwQixZQUFJO0FBQ0osb0JBQVksVUFBVSxHQUFHO0FBQ3pCLFlBQUksS0FBSyxZQUFZLFNBQVMsR0FBRztBQUMvQixlQUFLLGNBQWMsSUFBSSxZQUFZLFdBQVcsS0FBSyxRQUFRLENBQUM7QUFBQSxRQUM5RDtBQUNBLG9CQUFZLHdCQUFnQjtBQUM1QixZQUFJLEtBQUssWUFBWSxTQUFTLEdBQUc7QUFDL0IsZUFBSyxjQUFjLElBQUksWUFBWSxXQUFXLEtBQUssUUFBUSxDQUFDO0FBQUEsUUFDOUQ7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLGtCQUFrQixLQUFLLFVBQVU7QUFDL0IsYUFBSyxpQkFBaUIsVUFBVSxHQUFHLElBQUksUUFBUTtBQUFBLE1BQ2pEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1BLHFCQUFxQixLQUFLLFVBQVU7QUFDbEMsYUFBSyxvQkFBb0IsVUFBVSxHQUFHLElBQUksUUFBUTtBQUFBLE1BQ3BEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLElBQUksS0FBSyxPQUFPLFFBQVE7QUFDdEIsY0FBTSxTQUFTLEtBQUssWUFBWSxLQUFLLFVBQVUsQ0FBQztBQUNoRCxZQUFJLFFBQVE7QUFDVixpQkFBTyxHQUFHLElBQUk7QUFBQSxRQUNoQixPQUFPO0FBQ0wsZ0JBQU0sV0FBVyxPQUFPLEdBQUc7QUFDM0IsaUJBQU8sR0FBRyxJQUFJO0FBQ2QsY0FBSSxhQUFhLE9BQU87QUFDdEIsaUJBQUssT0FBTyxLQUFLLFFBQVE7QUFBQSxVQUMzQjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLGNBQWMsUUFBUSxRQUFRO0FBQzVCLG1CQUFXLE9BQU8sUUFBUTtBQUN4QixlQUFLLElBQUksS0FBSyxPQUFPLEdBQUcsR0FBRyxNQUFNO0FBQUEsUUFDbkM7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsZ0JBQWdCLFFBQVE7QUFDdEIsWUFBSSxDQUFDLE9BQU8sU0FBUztBQUNuQjtBQUFBLFFBQ0Y7QUFDQSxlQUFPLE9BQU8sS0FBSyxZQUFZLEtBQUssVUFBVSxDQUFDLElBQUksT0FBTyxPQUFPO0FBQUEsTUFDbkU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLE1BQU0sS0FBSyxRQUFRO0FBQ2pCLFlBQUksS0FBSyxXQUFXLE9BQU8sS0FBSyxTQUFTO0FBQ3ZDLGdCQUFNLFdBQVcsS0FBSyxRQUFRLEdBQUc7QUFDakMsaUJBQU8sS0FBSyxRQUFRLEdBQUc7QUFDdkIsY0FBSSxRQUFRLEtBQUssT0FBTyxHQUFHO0FBQ3pCLGlCQUFLLFVBQVU7QUFBQSxVQUNqQjtBQUNBLGNBQUksQ0FBQyxRQUFRO0FBQ1gsaUJBQUssT0FBTyxLQUFLLFFBQVE7QUFBQSxVQUMzQjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBQUEsSUFDRjtBQUVBLElBQU8saUJBQVE7QUFBQTtBQUFBOzs7QUNoUmYsSUFPTztBQVBQO0FBQUE7QUFPQSxJQUFPLDhCQUFRO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTWIsS0FBSztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQU1MLFFBQVE7QUFBQSxJQUNWO0FBQUE7QUFBQTs7O0FDcEJBLElBV00sVUFVTyxpQkFzRFAsWUE0UEM7QUF2VVA7QUFBQTtBQUdBO0FBQ0E7QUFDQTtBQU1BLElBQU0sV0FBVztBQUFBLE1BQ2YsUUFBUTtBQUFBLElBQ1Y7QUFRTyxJQUFNLGtCQUFOLGNBQThCLGNBQU07QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNekMsWUFBWSxNQUFNLFNBQVMsT0FBTztBQUNoQyxjQUFNLElBQUk7QUFPVixhQUFLLFVBQVU7QUFPZixhQUFLLFFBQVE7QUFBQSxNQUNmO0FBQUEsSUFDRjtBQStCQSxJQUFNLGFBQU4sY0FBeUIsZUFBVztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFLbEMsWUFBWSxPQUFPLFNBQVM7QUFDMUIsY0FBTTtBQUtOLGFBQUs7QUFLTCxhQUFLO0FBS0wsYUFBSztBQUVMLGtCQUFVLFdBQVcsQ0FBQztBQU10QixhQUFLLFVBQVUsQ0FBQyxDQUFDLFFBQVE7QUFNekIsYUFBSyxTQUFTLFFBQVEsUUFBUSxDQUFDO0FBRS9CLFlBQUksS0FBSyxTQUFTO0FBQ2hCLG1CQUFTLElBQUksR0FBRyxLQUFLLEtBQUssT0FBTyxRQUFRLElBQUksSUFBSSxFQUFFLEdBQUc7QUFDcEQsaUJBQUssY0FBYyxLQUFLLE9BQU8sQ0FBQyxHQUFHLENBQUM7QUFBQSxVQUN0QztBQUFBLFFBQ0Y7QUFFQSxhQUFLLGNBQWM7QUFBQSxNQUNyQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFNQSxRQUFRO0FBQ04sZUFBTyxLQUFLLFVBQVUsSUFBSSxHQUFHO0FBQzNCLGVBQUssSUFBSTtBQUFBLFFBQ1g7QUFBQSxNQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVNBLE9BQU8sS0FBSztBQUNWLGlCQUFTLElBQUksR0FBRyxLQUFLLElBQUksUUFBUSxJQUFJLElBQUksRUFBRSxHQUFHO0FBQzVDLGVBQUssS0FBSyxJQUFJLENBQUMsQ0FBQztBQUFBLFFBQ2xCO0FBQ0EsZUFBTztBQUFBLE1BQ1Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BU0EsUUFBUSxHQUFHO0FBQ1QsY0FBTSxRQUFRLEtBQUs7QUFDbkIsaUJBQVMsSUFBSSxHQUFHLEtBQUssTUFBTSxRQUFRLElBQUksSUFBSSxFQUFFLEdBQUc7QUFDOUMsWUFBRSxNQUFNLENBQUMsR0FBRyxHQUFHLEtBQUs7QUFBQSxRQUN0QjtBQUFBLE1BQ0Y7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFVQSxXQUFXO0FBQ1QsZUFBTyxLQUFLO0FBQUEsTUFDZDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsS0FBSyxPQUFPO0FBQ1YsZUFBTyxLQUFLLE9BQU8sS0FBSztBQUFBLE1BQzFCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxZQUFZO0FBQ1YsZUFBTyxLQUFLLElBQUksU0FBUyxNQUFNO0FBQUEsTUFDakM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQVFBLFNBQVMsT0FBTyxNQUFNO0FBQ3BCLFlBQUksUUFBUSxLQUFLLFFBQVEsS0FBSyxVQUFVLEdBQUc7QUFDekMsZ0JBQU0sSUFBSSxNQUFNLDBCQUEwQixLQUFLO0FBQUEsUUFDakQ7QUFDQSxZQUFJLEtBQUssU0FBUztBQUNoQixlQUFLLGNBQWMsSUFBSTtBQUFBLFFBQ3pCO0FBQ0EsYUFBSyxPQUFPLE9BQU8sT0FBTyxHQUFHLElBQUk7QUFDakMsYUFBSyxjQUFjO0FBQ25CLGFBQUs7QUFBQSxVQUNILElBQUksZ0JBQWdCLDRCQUFvQixLQUFLLE1BQU0sS0FBSztBQUFBLFFBQzFEO0FBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsTUFBTTtBQUNKLGVBQU8sS0FBSyxTQUFTLEtBQUssVUFBVSxJQUFJLENBQUM7QUFBQSxNQUMzQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsS0FBSyxNQUFNO0FBQ1QsWUFBSSxLQUFLLFNBQVM7QUFDaEIsZUFBSyxjQUFjLElBQUk7QUFBQSxRQUN6QjtBQUNBLGNBQU0sSUFBSSxLQUFLLFVBQVU7QUFDekIsYUFBSyxTQUFTLEdBQUcsSUFBSTtBQUNyQixlQUFPLEtBQUssVUFBVTtBQUFBLE1BQ3hCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFRQSxPQUFPLE1BQU07QUFDWCxjQUFNLE1BQU0sS0FBSztBQUNqQixpQkFBUyxJQUFJLEdBQUcsS0FBSyxJQUFJLFFBQVEsSUFBSSxJQUFJLEVBQUUsR0FBRztBQUM1QyxjQUFJLElBQUksQ0FBQyxNQUFNLE1BQU07QUFDbkIsbUJBQU8sS0FBSyxTQUFTLENBQUM7QUFBQSxVQUN4QjtBQUFBLFFBQ0Y7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTUFTQSxTQUFTLE9BQU87QUFDZCxZQUFJLFFBQVEsS0FBSyxTQUFTLEtBQUssVUFBVSxHQUFHO0FBQzFDLGlCQUFPO0FBQUEsUUFDVDtBQUNBLGNBQU0sT0FBTyxLQUFLLE9BQU8sS0FBSztBQUM5QixhQUFLLE9BQU8sT0FBTyxPQUFPLENBQUM7QUFDM0IsYUFBSyxjQUFjO0FBQ25CLGFBQUs7QUFBQTtBQUFBLFVBRUQsSUFBSSxnQkFBZ0IsNEJBQW9CLFFBQVEsTUFBTSxLQUFLO0FBQUEsUUFFL0Q7QUFDQSxlQUFPO0FBQUEsTUFDVDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BUUEsTUFBTSxPQUFPLE1BQU07QUFDakIsY0FBTSxJQUFJLEtBQUssVUFBVTtBQUN6QixZQUFJLFNBQVMsR0FBRztBQUNkLGVBQUssU0FBUyxPQUFPLElBQUk7QUFDekI7QUFBQSxRQUNGO0FBQ0EsWUFBSSxRQUFRLEdBQUc7QUFDYixnQkFBTSxJQUFJLE1BQU0sMEJBQTBCLEtBQUs7QUFBQSxRQUNqRDtBQUNBLFlBQUksS0FBSyxTQUFTO0FBQ2hCLGVBQUssY0FBYyxNQUFNLEtBQUs7QUFBQSxRQUNoQztBQUNBLGNBQU0sT0FBTyxLQUFLLE9BQU8sS0FBSztBQUM5QixhQUFLLE9BQU8sS0FBSyxJQUFJO0FBQ3JCLGFBQUs7QUFBQTtBQUFBLFVBRUQsSUFBSSxnQkFBZ0IsNEJBQW9CLFFBQVEsTUFBTSxLQUFLO0FBQUEsUUFFL0Q7QUFDQSxhQUFLO0FBQUE7QUFBQSxVQUVELElBQUksZ0JBQWdCLDRCQUFvQixLQUFLLE1BQU0sS0FBSztBQUFBLFFBRTVEO0FBQUEsTUFDRjtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BS0EsZ0JBQWdCO0FBQ2QsYUFBSyxJQUFJLFNBQVMsUUFBUSxLQUFLLE9BQU8sTUFBTTtBQUFBLE1BQzlDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BT0EsY0FBYyxNQUFNLFFBQVE7QUFDMUIsaUJBQVMsSUFBSSxHQUFHLEtBQUssS0FBSyxPQUFPLFFBQVEsSUFBSSxJQUFJLEVBQUUsR0FBRztBQUNwRCxjQUFJLEtBQUssT0FBTyxDQUFDLE1BQU0sUUFBUSxNQUFNLFFBQVE7QUFDM0Msa0JBQU0sSUFBSSxNQUFNLDZDQUE2QztBQUFBLFVBQy9EO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBRUEsSUFBTyxxQkFBUTtBQUFBO0FBQUE7OztBQ3ZVZixJQUlNLElBU08sU0FNQSxRQU1BLG1CQVNBLFFBTUEsS0FTQSxvQkFRQSx5QkFTQSxjQU9BLHFCQUtBO0FBOUViO0FBQUE7QUFJQSxJQUFNLEtBQ0osT0FBTyxjQUFjLGVBQWUsT0FBTyxVQUFVLGNBQWMsY0FDL0QsVUFBVSxVQUFVLFlBQVksSUFDaEM7QUFNQyxJQUFNLFVBQVUsR0FBRyxTQUFTLFNBQVM7QUFNckMsSUFBTSxTQUFTLEdBQUcsU0FBUyxRQUFRLEtBQUssQ0FBQyxHQUFHLFNBQVMsT0FBTztBQU01RCxJQUFNLG9CQUNYLFdBQ0MsR0FBRyxTQUFTLGNBQWMsS0FDekIsd0NBQXdDLEtBQUssRUFBRTtBQU01QyxJQUFNLFNBQVMsR0FBRyxTQUFTLFFBQVEsS0FBSyxDQUFDLEdBQUcsU0FBUyxNQUFNO0FBTTNELElBQU0sTUFBTSxHQUFHLFNBQVMsV0FBVztBQVNuQyxJQUFNLHFCQUNYLE9BQU8scUJBQXFCLGNBQWMsbUJBQW1CO0FBT3hELElBQU0sMEJBQ1gsT0FBTyxzQkFBc0IsZUFDN0IsT0FBTyxvQkFBb0IsZUFDM0IsZ0JBQWdCO0FBTVgsSUFBTSxlQUNYLE9BQU8sVUFBVSxlQUFlLE1BQU0sVUFBVTtBQU0zQyxJQUFNLHNCQUFzQixPQUFPLHNCQUFzQjtBQUt6RCxJQUFNLDBCQUEyQixXQUFZO0FBQ2xELFVBQUksVUFBVTtBQUNkLFVBQUk7QUFDRixjQUFNLFVBQVUsT0FBTyxlQUFlLENBQUMsR0FBRyxXQUFXO0FBQUEsVUFDbkQsS0FBSyxXQUFZO0FBQ2Ysc0JBQVU7QUFBQSxVQUNaO0FBQUEsUUFDRixDQUFDO0FBR0QsZUFBTyxpQkFBaUIsS0FBSyxNQUFNLE9BQU87QUFFMUMsZUFBTyxvQkFBb0IsS0FBSyxNQUFNLE9BQU87QUFBQSxNQUMvQyxTQUFTQSxRQUFPO0FBQUEsTUFFaEI7QUFDQSxhQUFPO0FBQUEsSUFDVCxFQUFHO0FBQUE7QUFBQTs7O0FDdkZJLFNBQVMsT0FBTyxXQUFXLGNBQWM7QUFDOUMsTUFBSSxDQUFDLFdBQVc7QUFDZCxVQUFNLElBQUksTUFBTSxZQUFZO0FBQUEsRUFDOUI7QUFDRjtBQVpBO0FBQUE7QUFBQTtBQUFBOzs7QUNtQ08sU0FBUyxTQUFTO0FBQ3ZCLFNBQU8sQ0FBQyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsQ0FBQztBQUMxQjtBQU9PLFNBQVMsTUFBTUMsWUFBVztBQUMvQixTQUFPLElBQUlBLFlBQVcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7QUFDeEM7QUFTTyxTQUFTLFNBQVMsWUFBWSxZQUFZO0FBQy9DLFFBQU0sS0FBSyxXQUFXLENBQUM7QUFDdkIsUUFBTSxLQUFLLFdBQVcsQ0FBQztBQUN2QixRQUFNLEtBQUssV0FBVyxDQUFDO0FBQ3ZCLFFBQU0sS0FBSyxXQUFXLENBQUM7QUFDdkIsUUFBTSxLQUFLLFdBQVcsQ0FBQztBQUN2QixRQUFNLEtBQUssV0FBVyxDQUFDO0FBQ3ZCLFFBQU0sS0FBSyxXQUFXLENBQUM7QUFDdkIsUUFBTSxLQUFLLFdBQVcsQ0FBQztBQUN2QixRQUFNLEtBQUssV0FBVyxDQUFDO0FBQ3ZCLFFBQU0sS0FBSyxXQUFXLENBQUM7QUFDdkIsUUFBTSxLQUFLLFdBQVcsQ0FBQztBQUN2QixRQUFNLEtBQUssV0FBVyxDQUFDO0FBRXZCLGFBQVcsQ0FBQyxJQUFJLEtBQUssS0FBSyxLQUFLO0FBQy9CLGFBQVcsQ0FBQyxJQUFJLEtBQUssS0FBSyxLQUFLO0FBQy9CLGFBQVcsQ0FBQyxJQUFJLEtBQUssS0FBSyxLQUFLO0FBQy9CLGFBQVcsQ0FBQyxJQUFJLEtBQUssS0FBSyxLQUFLO0FBQy9CLGFBQVcsQ0FBQyxJQUFJLEtBQUssS0FBSyxLQUFLLEtBQUs7QUFDcEMsYUFBVyxDQUFDLElBQUksS0FBSyxLQUFLLEtBQUssS0FBSztBQUVwQyxTQUFPO0FBQ1Q7QUFhTyxTQUFTLElBQUlBLFlBQVcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUc7QUFDL0MsRUFBQUEsV0FBVSxDQUFDLElBQUk7QUFDZixFQUFBQSxXQUFVLENBQUMsSUFBSTtBQUNmLEVBQUFBLFdBQVUsQ0FBQyxJQUFJO0FBQ2YsRUFBQUEsV0FBVSxDQUFDLElBQUk7QUFDZixFQUFBQSxXQUFVLENBQUMsSUFBSTtBQUNmLEVBQUFBLFdBQVUsQ0FBQyxJQUFJO0FBQ2YsU0FBT0E7QUFDVDtBQVFPLFNBQVMsYUFBYSxZQUFZLFlBQVk7QUFDbkQsYUFBVyxDQUFDLElBQUksV0FBVyxDQUFDO0FBQzVCLGFBQVcsQ0FBQyxJQUFJLFdBQVcsQ0FBQztBQUM1QixhQUFXLENBQUMsSUFBSSxXQUFXLENBQUM7QUFDNUIsYUFBVyxDQUFDLElBQUksV0FBVyxDQUFDO0FBQzVCLGFBQVcsQ0FBQyxJQUFJLFdBQVcsQ0FBQztBQUM1QixhQUFXLENBQUMsSUFBSSxXQUFXLENBQUM7QUFDNUIsU0FBTztBQUNUO0FBV08sU0FBUyxNQUFNQSxZQUFXLFlBQVk7QUFDM0MsUUFBTSxJQUFJLFdBQVcsQ0FBQztBQUN0QixRQUFNLElBQUksV0FBVyxDQUFDO0FBQ3RCLGFBQVcsQ0FBQyxJQUFJQSxXQUFVLENBQUMsSUFBSSxJQUFJQSxXQUFVLENBQUMsSUFBSSxJQUFJQSxXQUFVLENBQUM7QUFDakUsYUFBVyxDQUFDLElBQUlBLFdBQVUsQ0FBQyxJQUFJLElBQUlBLFdBQVUsQ0FBQyxJQUFJLElBQUlBLFdBQVUsQ0FBQztBQUNqRSxTQUFPO0FBQ1Q7QUFRTyxTQUFTLE9BQU9BLFlBQVcsT0FBTztBQUN2QyxRQUFNLE1BQU0sS0FBSyxJQUFJLEtBQUs7QUFDMUIsUUFBTSxNQUFNLEtBQUssSUFBSSxLQUFLO0FBQzFCLFNBQU8sU0FBU0EsWUFBVyxJQUFJLE1BQU0sS0FBSyxLQUFLLENBQUMsS0FBSyxLQUFLLEdBQUcsQ0FBQyxDQUFDO0FBQ2pFO0FBU08sU0FBUyxNQUFNQSxZQUFXLEdBQUcsR0FBRztBQUNyQyxTQUFPLFNBQVNBLFlBQVcsSUFBSSxNQUFNLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxDQUFDLENBQUM7QUFDeEQ7QUFTTyxTQUFTLFVBQVUsUUFBUSxHQUFHLEdBQUc7QUFDdEMsU0FBTyxJQUFJLFFBQVEsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7QUFDckM7QUFTTyxTQUFTLFVBQVVBLFlBQVcsSUFBSSxJQUFJO0FBQzNDLFNBQU8sU0FBU0EsWUFBVyxJQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLEVBQUUsQ0FBQztBQUMxRDtBQWVPLFNBQVMsUUFBUUEsWUFBVyxLQUFLLEtBQUssSUFBSSxJQUFJLE9BQU8sS0FBSyxLQUFLO0FBQ3BFLFFBQU0sTUFBTSxLQUFLLElBQUksS0FBSztBQUMxQixRQUFNLE1BQU0sS0FBSyxJQUFJLEtBQUs7QUFDMUIsRUFBQUEsV0FBVSxDQUFDLElBQUksS0FBSztBQUNwQixFQUFBQSxXQUFVLENBQUMsSUFBSSxLQUFLO0FBQ3BCLEVBQUFBLFdBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSztBQUNyQixFQUFBQSxXQUFVLENBQUMsSUFBSSxLQUFLO0FBQ3BCLEVBQUFBLFdBQVUsQ0FBQyxJQUFJLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNO0FBQ2pELEVBQUFBLFdBQVUsQ0FBQyxJQUFJLE1BQU0sS0FBSyxNQUFNLE1BQU0sS0FBSyxNQUFNO0FBQ2pELFNBQU9BO0FBQ1Q7QUFnQk8sU0FBUyxvQkFBb0IsS0FBSyxLQUFLLElBQUksSUFBSSxPQUFPLEtBQUssS0FBSztBQUNyRSxTQUFPLFNBQVMsUUFBUSxPQUFPLEdBQUcsS0FBSyxLQUFLLElBQUksSUFBSSxPQUFPLEtBQUssR0FBRyxDQUFDO0FBQ3RFO0FBT08sU0FBUyxPQUFPLFFBQVE7QUFDN0IsU0FBTyxZQUFZLFFBQVEsTUFBTTtBQUNuQztBQVNPLFNBQVMsWUFBWSxRQUFRLFFBQVE7QUFDMUMsUUFBTSxNQUFNLFlBQVksTUFBTTtBQUM5QixTQUFPLFFBQVEsR0FBRywwQ0FBMEM7QUFFNUQsUUFBTSxJQUFJLE9BQU8sQ0FBQztBQUNsQixRQUFNLElBQUksT0FBTyxDQUFDO0FBQ2xCLFFBQU0sSUFBSSxPQUFPLENBQUM7QUFDbEIsUUFBTSxJQUFJLE9BQU8sQ0FBQztBQUNsQixRQUFNLElBQUksT0FBTyxDQUFDO0FBQ2xCLFFBQU0sSUFBSSxPQUFPLENBQUM7QUFFbEIsU0FBTyxDQUFDLElBQUksSUFBSTtBQUNoQixTQUFPLENBQUMsSUFBSSxDQUFDLElBQUk7QUFDakIsU0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJO0FBQ2pCLFNBQU8sQ0FBQyxJQUFJLElBQUk7QUFDaEIsU0FBTyxDQUFDLEtBQUssSUFBSSxJQUFJLElBQUksS0FBSztBQUM5QixTQUFPLENBQUMsSUFBSSxFQUFFLElBQUksSUFBSSxJQUFJLEtBQUs7QUFFL0IsU0FBTztBQUNUO0FBT08sU0FBUyxZQUFZLEtBQUs7QUFDL0IsU0FBTyxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxJQUFJLENBQUM7QUFDekM7QUFjTyxTQUFTLFNBQVMsS0FBSztBQUM1QixRQUFNLGtCQUFrQixZQUFZLElBQUksS0FBSyxJQUFJLElBQUk7QUFDckQsTUFBSSx5QkFBeUI7QUFDM0IsV0FBTztBQUFBLEVBQ1Q7QUFDQSxRQUFNLE9BQ0osdUJBQXVCLHFCQUFxQixTQUFTLGNBQWMsS0FBSztBQUMxRSxPQUFLLE1BQU0sWUFBWTtBQUN2QixTQUFPLEtBQUssTUFBTTtBQUNwQjtBQWhTQSxJQTZCTSxNQWtQRjtBQS9RSjtBQUFBO0FBR0E7QUFDQTtBQXlCQSxJQUFNLE9BQU8sSUFBSSxNQUFNLENBQUM7QUFBQTtBQUFBOzs7QUM3QnhCLElBUU87QUFSUDtBQUFBO0FBUUEsSUFBTyx1QkFBUTtBQUFBLE1BQ2IsU0FBUztBQUFBLE1BQ1QsY0FBYztBQUFBLE1BQ2QsT0FBTztBQUFBLE1BQ1AsT0FBTztBQUFBLE1BQ1AsT0FBTztBQUFBLE1BQ1AsTUFBTTtBQUFBLElBQ1I7QUFBQTtBQUFBOzs7QUNRTyxTQUFTLGVBQWVDLGNBQWE7QUFDMUMsUUFBTSxTQUFTLFlBQVk7QUFDM0IsV0FBUyxJQUFJLEdBQUcsS0FBS0EsYUFBWSxRQUFRLElBQUksSUFBSSxFQUFFLEdBQUc7QUFDcEQscUJBQWlCLFFBQVFBLGFBQVksQ0FBQyxDQUFDO0FBQUEsRUFDekM7QUFDQSxTQUFPO0FBQ1Q7QUFTQSxTQUFTLG1CQUFtQixJQUFJLElBQUksTUFBTTtBQUN4QyxRQUFNLE9BQU8sS0FBSyxJQUFJLE1BQU0sTUFBTSxFQUFFO0FBQ3BDLFFBQU0sT0FBTyxLQUFLLElBQUksTUFBTSxNQUFNLEVBQUU7QUFDcEMsUUFBTSxPQUFPLEtBQUssSUFBSSxNQUFNLE1BQU0sRUFBRTtBQUNwQyxRQUFNLE9BQU8sS0FBSyxJQUFJLE1BQU0sTUFBTSxFQUFFO0FBQ3BDLFNBQU8sZUFBZSxNQUFNLE1BQU0sTUFBTSxNQUFNLElBQUk7QUFDcEQ7QUFVTyxTQUFTLE9BQU8sUUFBUSxPQUFPLE1BQU07QUFDMUMsTUFBSSxNQUFNO0FBQ1IsU0FBSyxDQUFDLElBQUksT0FBTyxDQUFDLElBQUk7QUFDdEIsU0FBSyxDQUFDLElBQUksT0FBTyxDQUFDLElBQUk7QUFDdEIsU0FBSyxDQUFDLElBQUksT0FBTyxDQUFDLElBQUk7QUFDdEIsU0FBSyxDQUFDLElBQUksT0FBTyxDQUFDLElBQUk7QUFDdEIsV0FBTztBQUFBLEVBQ1Q7QUFDQSxTQUFPO0FBQUEsSUFDTCxPQUFPLENBQUMsSUFBSTtBQUFBLElBQ1osT0FBTyxDQUFDLElBQUk7QUFBQSxJQUNaLE9BQU8sQ0FBQyxJQUFJO0FBQUEsSUFDWixPQUFPLENBQUMsSUFBSTtBQUFBLEVBQ2Q7QUFDRjtBQVNPLFNBQVMsTUFBTSxRQUFRLE1BQU07QUFDbEMsTUFBSSxNQUFNO0FBQ1IsU0FBSyxDQUFDLElBQUksT0FBTyxDQUFDO0FBQ2xCLFNBQUssQ0FBQyxJQUFJLE9BQU8sQ0FBQztBQUNsQixTQUFLLENBQUMsSUFBSSxPQUFPLENBQUM7QUFDbEIsU0FBSyxDQUFDLElBQUksT0FBTyxDQUFDO0FBQ2xCLFdBQU87QUFBQSxFQUNUO0FBQ0EsU0FBTyxPQUFPLE1BQU07QUFDdEI7QUFRTyxTQUFTLHlCQUF5QixRQUFRLEdBQUcsR0FBRztBQUNyRCxNQUFJLElBQUk7QUFDUixNQUFJLElBQUksT0FBTyxDQUFDLEdBQUc7QUFDakIsU0FBSyxPQUFPLENBQUMsSUFBSTtBQUFBLEVBQ25CLFdBQVcsT0FBTyxDQUFDLElBQUksR0FBRztBQUN4QixTQUFLLElBQUksT0FBTyxDQUFDO0FBQUEsRUFDbkIsT0FBTztBQUNMLFNBQUs7QUFBQSxFQUNQO0FBQ0EsTUFBSSxJQUFJLE9BQU8sQ0FBQyxHQUFHO0FBQ2pCLFNBQUssT0FBTyxDQUFDLElBQUk7QUFBQSxFQUNuQixXQUFXLE9BQU8sQ0FBQyxJQUFJLEdBQUc7QUFDeEIsU0FBSyxJQUFJLE9BQU8sQ0FBQztBQUFBLEVBQ25CLE9BQU87QUFDTCxTQUFLO0FBQUEsRUFDUDtBQUNBLFNBQU8sS0FBSyxLQUFLLEtBQUs7QUFDeEI7QUFVTyxTQUFTLG1CQUFtQixRQUFRLFlBQVk7QUFDckQsU0FBTyxXQUFXLFFBQVEsV0FBVyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUM7QUFDeEQ7QUFjTyxTQUFTLGVBQWUsU0FBUyxTQUFTO0FBQy9DLFNBQ0UsUUFBUSxDQUFDLEtBQUssUUFBUSxDQUFDLEtBQ3ZCLFFBQVEsQ0FBQyxLQUFLLFFBQVEsQ0FBQyxLQUN2QixRQUFRLENBQUMsS0FBSyxRQUFRLENBQUMsS0FDdkIsUUFBUSxDQUFDLEtBQUssUUFBUSxDQUFDO0FBRTNCO0FBV08sU0FBUyxXQUFXLFFBQVEsR0FBRyxHQUFHO0FBQ3ZDLFNBQU8sT0FBTyxDQUFDLEtBQUssS0FBSyxLQUFLLE9BQU8sQ0FBQyxLQUFLLE9BQU8sQ0FBQyxLQUFLLEtBQUssS0FBSyxPQUFPLENBQUM7QUFDNUU7QUFTTyxTQUFTLHVCQUF1QixRQUFRLFlBQVk7QUFDekQsUUFBTSxPQUFPLE9BQU8sQ0FBQztBQUNyQixRQUFNLE9BQU8sT0FBTyxDQUFDO0FBQ3JCLFFBQU0sT0FBTyxPQUFPLENBQUM7QUFDckIsUUFBTSxPQUFPLE9BQU8sQ0FBQztBQUNyQixRQUFNLElBQUksV0FBVyxDQUFDO0FBQ3RCLFFBQU0sSUFBSSxXQUFXLENBQUM7QUFDdEIsTUFBSSxlQUFlLHFCQUFhO0FBQ2hDLE1BQUksSUFBSSxNQUFNO0FBQ1osbUJBQWUsZUFBZSxxQkFBYTtBQUFBLEVBQzdDLFdBQVcsSUFBSSxNQUFNO0FBQ25CLG1CQUFlLGVBQWUscUJBQWE7QUFBQSxFQUM3QztBQUNBLE1BQUksSUFBSSxNQUFNO0FBQ1osbUJBQWUsZUFBZSxxQkFBYTtBQUFBLEVBQzdDLFdBQVcsSUFBSSxNQUFNO0FBQ25CLG1CQUFlLGVBQWUscUJBQWE7QUFBQSxFQUM3QztBQUNBLE1BQUksaUJBQWlCLHFCQUFhLFNBQVM7QUFDekMsbUJBQWUscUJBQWE7QUFBQSxFQUM5QjtBQUNBLFNBQU87QUFDVDtBQU9PLFNBQVMsY0FBYztBQUM1QixTQUFPLENBQUMsVUFBVSxVQUFVLFdBQVcsU0FBUztBQUNsRDtBQVdPLFNBQVMsZUFBZSxNQUFNLE1BQU0sTUFBTSxNQUFNLE1BQU07QUFDM0QsTUFBSSxNQUFNO0FBQ1IsU0FBSyxDQUFDLElBQUk7QUFDVixTQUFLLENBQUMsSUFBSTtBQUNWLFNBQUssQ0FBQyxJQUFJO0FBQ1YsU0FBSyxDQUFDLElBQUk7QUFDVixXQUFPO0FBQUEsRUFDVDtBQUNBLFNBQU8sQ0FBQyxNQUFNLE1BQU0sTUFBTSxJQUFJO0FBQ2hDO0FBT08sU0FBUyxvQkFBb0IsTUFBTTtBQUN4QyxTQUFPLGVBQWUsVUFBVSxVQUFVLFdBQVcsV0FBVyxJQUFJO0FBQ3RFO0FBT08sU0FBUyw2QkFBNkIsWUFBWSxNQUFNO0FBQzdELFFBQU0sSUFBSSxXQUFXLENBQUM7QUFDdEIsUUFBTSxJQUFJLFdBQVcsQ0FBQztBQUN0QixTQUFPLGVBQWUsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJO0FBQ3hDO0FBT08sU0FBUyw4QkFBOEJBLGNBQWEsTUFBTTtBQUMvRCxRQUFNLFNBQVMsb0JBQW9CLElBQUk7QUFDdkMsU0FBTyxrQkFBa0IsUUFBUUEsWUFBVztBQUM5QztBQVVPLFNBQVMsa0NBQ2QsaUJBQ0FDLFNBQ0EsS0FDQSxRQUNBLE1BQ0E7QUFDQSxRQUFNLFNBQVMsb0JBQW9CLElBQUk7QUFDdkMsU0FBTyxzQkFBc0IsUUFBUSxpQkFBaUJBLFNBQVEsS0FBSyxNQUFNO0FBQzNFO0FBT08sU0FBUyx3QkFBd0IsT0FBTyxNQUFNO0FBQ25ELFFBQU0sU0FBUyxvQkFBb0IsSUFBSTtBQUN2QyxTQUFPLFlBQVksUUFBUSxLQUFLO0FBQ2xDO0FBU08sU0FBU0MsUUFBTyxTQUFTLFNBQVM7QUFDdkMsU0FDRSxRQUFRLENBQUMsS0FBSyxRQUFRLENBQUMsS0FDdkIsUUFBUSxDQUFDLEtBQUssUUFBUSxDQUFDLEtBQ3ZCLFFBQVEsQ0FBQyxLQUFLLFFBQVEsQ0FBQyxLQUN2QixRQUFRLENBQUMsS0FBSyxRQUFRLENBQUM7QUFFM0I7QUFTTyxTQUFTLG9CQUFvQixTQUFTLFNBQVMsV0FBVztBQUMvRCxTQUNFLEtBQUssSUFBSSxRQUFRLENBQUMsSUFBSSxRQUFRLENBQUMsQ0FBQyxJQUFJLGFBQ3BDLEtBQUssSUFBSSxRQUFRLENBQUMsSUFBSSxRQUFRLENBQUMsQ0FBQyxJQUFJLGFBQ3BDLEtBQUssSUFBSSxRQUFRLENBQUMsSUFBSSxRQUFRLENBQUMsQ0FBQyxJQUFJLGFBQ3BDLEtBQUssSUFBSSxRQUFRLENBQUMsSUFBSSxRQUFRLENBQUMsQ0FBQyxJQUFJO0FBRXhDO0FBU08sU0FBU0MsUUFBTyxTQUFTLFNBQVM7QUFDdkMsTUFBSSxRQUFRLENBQUMsSUFBSSxRQUFRLENBQUMsR0FBRztBQUMzQixZQUFRLENBQUMsSUFBSSxRQUFRLENBQUM7QUFBQSxFQUN4QjtBQUNBLE1BQUksUUFBUSxDQUFDLElBQUksUUFBUSxDQUFDLEdBQUc7QUFDM0IsWUFBUSxDQUFDLElBQUksUUFBUSxDQUFDO0FBQUEsRUFDeEI7QUFDQSxNQUFJLFFBQVEsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxHQUFHO0FBQzNCLFlBQVEsQ0FBQyxJQUFJLFFBQVEsQ0FBQztBQUFBLEVBQ3hCO0FBQ0EsTUFBSSxRQUFRLENBQUMsSUFBSSxRQUFRLENBQUMsR0FBRztBQUMzQixZQUFRLENBQUMsSUFBSSxRQUFRLENBQUM7QUFBQSxFQUN4QjtBQUNBLFNBQU87QUFDVDtBQU1PLFNBQVMsaUJBQWlCLFFBQVEsWUFBWTtBQUNuRCxNQUFJLFdBQVcsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxHQUFHO0FBQzdCLFdBQU8sQ0FBQyxJQUFJLFdBQVcsQ0FBQztBQUFBLEVBQzFCO0FBQ0EsTUFBSSxXQUFXLENBQUMsSUFBSSxPQUFPLENBQUMsR0FBRztBQUM3QixXQUFPLENBQUMsSUFBSSxXQUFXLENBQUM7QUFBQSxFQUMxQjtBQUNBLE1BQUksV0FBVyxDQUFDLElBQUksT0FBTyxDQUFDLEdBQUc7QUFDN0IsV0FBTyxDQUFDLElBQUksV0FBVyxDQUFDO0FBQUEsRUFDMUI7QUFDQSxNQUFJLFdBQVcsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxHQUFHO0FBQzdCLFdBQU8sQ0FBQyxJQUFJLFdBQVcsQ0FBQztBQUFBLEVBQzFCO0FBQ0Y7QUFPTyxTQUFTLGtCQUFrQixRQUFRSCxjQUFhO0FBQ3JELFdBQVMsSUFBSSxHQUFHLEtBQUtBLGFBQVksUUFBUSxJQUFJLElBQUksRUFBRSxHQUFHO0FBQ3BELHFCQUFpQixRQUFRQSxhQUFZLENBQUMsQ0FBQztBQUFBLEVBQ3pDO0FBQ0EsU0FBTztBQUNUO0FBVU8sU0FBUyxzQkFDZCxRQUNBLGlCQUNBQyxTQUNBLEtBQ0EsUUFDQTtBQUNBLFNBQU9BLFVBQVMsS0FBS0EsV0FBVSxRQUFRO0FBQ3JDLGFBQVMsUUFBUSxnQkFBZ0JBLE9BQU0sR0FBRyxnQkFBZ0JBLFVBQVMsQ0FBQyxDQUFDO0FBQUEsRUFDdkU7QUFDQSxTQUFPO0FBQ1Q7QUFPTyxTQUFTLFlBQVksUUFBUSxPQUFPO0FBQ3pDLFdBQVMsSUFBSSxHQUFHLEtBQUssTUFBTSxRQUFRLElBQUksSUFBSSxFQUFFLEdBQUc7QUFDOUMsc0JBQWtCLFFBQVEsTUFBTSxDQUFDLENBQUM7QUFBQSxFQUNwQztBQUNBLFNBQU87QUFDVDtBQU9PLFNBQVMsU0FBUyxRQUFRLEdBQUcsR0FBRztBQUNyQyxTQUFPLENBQUMsSUFBSSxLQUFLLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQztBQUNqQyxTQUFPLENBQUMsSUFBSSxLQUFLLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQztBQUNqQyxTQUFPLENBQUMsSUFBSSxLQUFLLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQztBQUNqQyxTQUFPLENBQUMsSUFBSSxLQUFLLElBQUksT0FBTyxDQUFDLEdBQUcsQ0FBQztBQUNuQztBQVdPLFNBQVMsY0FBYyxRQUFRLFVBQVU7QUFDOUMsTUFBSTtBQUNKLFFBQU0sU0FBUyxjQUFjLE1BQU0sQ0FBQztBQUNwQyxNQUFJLEtBQUs7QUFDUCxXQUFPO0FBQUEsRUFDVDtBQUNBLFFBQU0sU0FBUyxlQUFlLE1BQU0sQ0FBQztBQUNyQyxNQUFJLEtBQUs7QUFDUCxXQUFPO0FBQUEsRUFDVDtBQUNBLFFBQU0sU0FBUyxZQUFZLE1BQU0sQ0FBQztBQUNsQyxNQUFJLEtBQUs7QUFDUCxXQUFPO0FBQUEsRUFDVDtBQUNBLFFBQU0sU0FBUyxXQUFXLE1BQU0sQ0FBQztBQUNqQyxNQUFJLEtBQUs7QUFDUCxXQUFPO0FBQUEsRUFDVDtBQUNBLFNBQU87QUFDVDtBQVFPLFNBQVMsUUFBUSxRQUFRO0FBQzlCLE1BQUksT0FBTztBQUNYLE1BQUksQ0FBQ0csU0FBUSxNQUFNLEdBQUc7QUFDcEIsV0FBTyxTQUFTLE1BQU0sSUFBSSxVQUFVLE1BQU07QUFBQSxFQUM1QztBQUNBLFNBQU87QUFDVDtBQVFPLFNBQVMsY0FBYyxRQUFRO0FBQ3BDLFNBQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQztBQUM5QjtBQVFPLFNBQVMsZUFBZSxRQUFRO0FBQ3JDLFNBQU8sQ0FBQyxPQUFPLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQztBQUM5QjtBQVFPLFNBQVMsVUFBVSxRQUFRO0FBQ2hDLFNBQU8sRUFBRSxPQUFPLENBQUMsSUFBSSxPQUFPLENBQUMsS0FBSyxJQUFJLE9BQU8sQ0FBQyxJQUFJLE9BQU8sQ0FBQyxLQUFLLENBQUM7QUFDbEU7QUFRTyxTQUFTLFVBQVUsUUFBUSxRQUFRO0FBQ3hDLE1BQUk7QUFDSixNQUFJLFdBQVcsZUFBZTtBQUM1QixpQkFBYSxjQUFjLE1BQU07QUFBQSxFQUNuQyxXQUFXLFdBQVcsZ0JBQWdCO0FBQ3BDLGlCQUFhLGVBQWUsTUFBTTtBQUFBLEVBQ3BDLFdBQVcsV0FBVyxZQUFZO0FBQ2hDLGlCQUFhLFdBQVcsTUFBTTtBQUFBLEVBQ2hDLFdBQVcsV0FBVyxhQUFhO0FBQ2pDLGlCQUFhLFlBQVksTUFBTTtBQUFBLEVBQ2pDLE9BQU87QUFDTCxVQUFNLElBQUksTUFBTSxnQkFBZ0I7QUFBQSxFQUNsQztBQUNBLFNBQU87QUFDVDtBQU9PLFNBQVMsZ0JBQWdCLFNBQVMsU0FBUztBQUNoRCxRQUFNLE9BQU8sS0FBSyxJQUFJLFFBQVEsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDO0FBQzVDLFFBQU0sT0FBTyxLQUFLLElBQUksUUFBUSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUM7QUFDNUMsUUFBTSxPQUFPLEtBQUssSUFBSSxRQUFRLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQztBQUM1QyxRQUFNLE9BQU8sS0FBSyxJQUFJLFFBQVEsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDO0FBQzVDLFVBQVEsT0FBTyxTQUFTLE9BQU87QUFDakM7QUFVTyxTQUFTLGtCQUFrQixRQUFRLFlBQVksVUFBVSxNQUFNLE1BQU07QUFDMUUsUUFBTSxDQUFDLElBQUksSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksRUFBRSxJQUFJO0FBQUEsSUFDdkM7QUFBQSxJQUNBO0FBQUEsSUFDQTtBQUFBLElBQ0E7QUFBQSxFQUNGO0FBQ0EsU0FBTztBQUFBLElBQ0wsS0FBSyxJQUFJLElBQUksSUFBSSxJQUFJLEVBQUU7QUFBQSxJQUN2QixLQUFLLElBQUksSUFBSSxJQUFJLElBQUksRUFBRTtBQUFBLElBQ3ZCLEtBQUssSUFBSSxJQUFJLElBQUksSUFBSSxFQUFFO0FBQUEsSUFDdkIsS0FBSyxJQUFJLElBQUksSUFBSSxJQUFJLEVBQUU7QUFBQSxJQUN2QjtBQUFBLEVBQ0Y7QUFDRjtBQVNPLFNBQVMsbUJBQW1CLFFBQVEsWUFBWSxVQUFVLE1BQU07QUFDckUsUUFBTSxLQUFNLGFBQWEsS0FBSyxDQUFDLElBQUs7QUFDcEMsUUFBTSxLQUFNLGFBQWEsS0FBSyxDQUFDLElBQUs7QUFDcEMsUUFBTSxjQUFjLEtBQUssSUFBSSxRQUFRO0FBQ3JDLFFBQU0sY0FBYyxLQUFLLElBQUksUUFBUTtBQUNyQyxRQUFNLE9BQU8sS0FBSztBQUNsQixRQUFNLE9BQU8sS0FBSztBQUNsQixRQUFNLE9BQU8sS0FBSztBQUNsQixRQUFNLE9BQU8sS0FBSztBQUNsQixRQUFNLElBQUksT0FBTyxDQUFDO0FBQ2xCLFFBQU0sSUFBSSxPQUFPLENBQUM7QUFDbEIsU0FBTztBQUFBLElBQ0wsSUFBSSxPQUFPO0FBQUEsSUFDWCxJQUFJLE9BQU87QUFBQSxJQUNYLElBQUksT0FBTztBQUFBLElBQ1gsSUFBSSxPQUFPO0FBQUEsSUFDWCxJQUFJLE9BQU87QUFBQSxJQUNYLElBQUksT0FBTztBQUFBLElBQ1gsSUFBSSxPQUFPO0FBQUEsSUFDWCxJQUFJLE9BQU87QUFBQSxJQUNYLElBQUksT0FBTztBQUFBLElBQ1gsSUFBSSxPQUFPO0FBQUEsRUFDYjtBQUNGO0FBUU8sU0FBUyxVQUFVLFFBQVE7QUFDaEMsU0FBTyxPQUFPLENBQUMsSUFBSSxPQUFPLENBQUM7QUFDN0I7QUFPTyxTQUFTLG9CQUFvQixTQUFTLFNBQVM7QUFDcEQsUUFBTSxlQUFlLGdCQUFnQixTQUFTLE9BQU87QUFDckQsU0FBTyxRQUFRLFlBQVk7QUFDN0I7QUFVTyxTQUFTLGdCQUFnQixTQUFTLFNBQVMsTUFBTTtBQUN0RCxRQUFNLGVBQWUsT0FBTyxPQUFPLFlBQVk7QUFDL0MsTUFBSSxXQUFXLFNBQVMsT0FBTyxHQUFHO0FBQ2hDLFFBQUksUUFBUSxDQUFDLElBQUksUUFBUSxDQUFDLEdBQUc7QUFDM0IsbUJBQWEsQ0FBQyxJQUFJLFFBQVEsQ0FBQztBQUFBLElBQzdCLE9BQU87QUFDTCxtQkFBYSxDQUFDLElBQUksUUFBUSxDQUFDO0FBQUEsSUFDN0I7QUFDQSxRQUFJLFFBQVEsQ0FBQyxJQUFJLFFBQVEsQ0FBQyxHQUFHO0FBQzNCLG1CQUFhLENBQUMsSUFBSSxRQUFRLENBQUM7QUFBQSxJQUM3QixPQUFPO0FBQ0wsbUJBQWEsQ0FBQyxJQUFJLFFBQVEsQ0FBQztBQUFBLElBQzdCO0FBQ0EsUUFBSSxRQUFRLENBQUMsSUFBSSxRQUFRLENBQUMsR0FBRztBQUMzQixtQkFBYSxDQUFDLElBQUksUUFBUSxDQUFDO0FBQUEsSUFDN0IsT0FBTztBQUNMLG1CQUFhLENBQUMsSUFBSSxRQUFRLENBQUM7QUFBQSxJQUM3QjtBQUNBLFFBQUksUUFBUSxDQUFDLElBQUksUUFBUSxDQUFDLEdBQUc7QUFDM0IsbUJBQWEsQ0FBQyxJQUFJLFFBQVEsQ0FBQztBQUFBLElBQzdCLE9BQU87QUFDTCxtQkFBYSxDQUFDLElBQUksUUFBUSxDQUFDO0FBQUEsSUFDN0I7QUFBQSxFQUNGLE9BQU87QUFDTCx3QkFBb0IsWUFBWTtBQUFBLEVBQ2xDO0FBQ0EsU0FBTztBQUNUO0FBTU8sU0FBUyxVQUFVLFFBQVE7QUFDaEMsU0FBTyxTQUFTLE1BQU0sSUFBSSxVQUFVLE1BQU07QUFDNUM7QUFRTyxTQUFTLFFBQVEsUUFBUTtBQUM5QixTQUFPLENBQUMsT0FBTyxDQUFDLElBQUksT0FBTyxDQUFDLEdBQUcsT0FBTyxDQUFDLElBQUksT0FBTyxDQUFDLENBQUM7QUFDdEQ7QUFRTyxTQUFTLFdBQVcsUUFBUTtBQUNqQyxTQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUM7QUFDOUI7QUFRTyxTQUFTLFlBQVksUUFBUTtBQUNsQyxTQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUM7QUFDOUI7QUFRTyxTQUFTLFNBQVMsUUFBUTtBQUMvQixTQUFPLE9BQU8sQ0FBQyxJQUFJLE9BQU8sQ0FBQztBQUM3QjtBQVNPLFNBQVMsV0FBVyxTQUFTLFNBQVM7QUFDM0MsU0FDRSxRQUFRLENBQUMsS0FBSyxRQUFRLENBQUMsS0FDdkIsUUFBUSxDQUFDLEtBQUssUUFBUSxDQUFDLEtBQ3ZCLFFBQVEsQ0FBQyxLQUFLLFFBQVEsQ0FBQyxLQUN2QixRQUFRLENBQUMsS0FBSyxRQUFRLENBQUM7QUFFM0I7QUFRTyxTQUFTQSxTQUFRLFFBQVE7QUFDOUIsU0FBTyxPQUFPLENBQUMsSUFBSSxPQUFPLENBQUMsS0FBSyxPQUFPLENBQUMsSUFBSSxPQUFPLENBQUM7QUFDdEQ7QUFPTyxTQUFTLGVBQWUsUUFBUSxNQUFNO0FBQzNDLE1BQUksTUFBTTtBQUNSLFNBQUssQ0FBQyxJQUFJLE9BQU8sQ0FBQztBQUNsQixTQUFLLENBQUMsSUFBSSxPQUFPLENBQUM7QUFDbEIsU0FBSyxDQUFDLElBQUksT0FBTyxDQUFDO0FBQ2xCLFNBQUssQ0FBQyxJQUFJLE9BQU8sQ0FBQztBQUNsQixXQUFPO0FBQUEsRUFDVDtBQUNBLFNBQU87QUFDVDtBQU1PLFNBQVMsZ0JBQWdCLFFBQVEsT0FBTztBQUM3QyxRQUFNLFVBQVcsT0FBTyxDQUFDLElBQUksT0FBTyxDQUFDLEtBQUssS0FBTSxRQUFRO0FBQ3hELFFBQU0sVUFBVyxPQUFPLENBQUMsSUFBSSxPQUFPLENBQUMsS0FBSyxLQUFNLFFBQVE7QUFDeEQsU0FBTyxDQUFDLEtBQUs7QUFDYixTQUFPLENBQUMsS0FBSztBQUNiLFNBQU8sQ0FBQyxLQUFLO0FBQ2IsU0FBTyxDQUFDLEtBQUs7QUFDZjtBQVVPLFNBQVMsa0JBQWtCLFFBQVEsT0FBTyxLQUFLO0FBQ3BELE1BQUlDLGNBQWE7QUFDakIsUUFBTSxXQUFXLHVCQUF1QixRQUFRLEtBQUs7QUFDckQsUUFBTSxTQUFTLHVCQUF1QixRQUFRLEdBQUc7QUFDakQsTUFDRSxhQUFhLHFCQUFhLGdCQUMxQixXQUFXLHFCQUFhLGNBQ3hCO0FBQ0EsSUFBQUEsY0FBYTtBQUFBLEVBQ2YsT0FBTztBQUNMLFVBQU0sT0FBTyxPQUFPLENBQUM7QUFDckIsVUFBTSxPQUFPLE9BQU8sQ0FBQztBQUNyQixVQUFNLE9BQU8sT0FBTyxDQUFDO0FBQ3JCLFVBQU0sT0FBTyxPQUFPLENBQUM7QUFDckIsVUFBTSxTQUFTLE1BQU0sQ0FBQztBQUN0QixVQUFNLFNBQVMsTUFBTSxDQUFDO0FBQ3RCLFVBQU0sT0FBTyxJQUFJLENBQUM7QUFDbEIsVUFBTSxPQUFPLElBQUksQ0FBQztBQUNsQixVQUFNLFNBQVMsT0FBTyxXQUFXLE9BQU87QUFDeEMsUUFBSSxHQUFHO0FBQ1AsUUFBSSxDQUFDLEVBQUUsU0FBUyxxQkFBYSxVQUFVLEVBQUUsV0FBVyxxQkFBYSxRQUFRO0FBRXZFLFVBQUksUUFBUSxPQUFPLFFBQVE7QUFDM0IsTUFBQUEsY0FBYSxLQUFLLFFBQVEsS0FBSztBQUFBLElBQ2pDO0FBQ0EsUUFDRSxDQUFDQSxlQUNELENBQUMsRUFBRSxTQUFTLHFCQUFhLFVBQ3pCLEVBQUUsV0FBVyxxQkFBYSxRQUMxQjtBQUVBLFVBQUksUUFBUSxPQUFPLFFBQVE7QUFDM0IsTUFBQUEsY0FBYSxLQUFLLFFBQVEsS0FBSztBQUFBLElBQ2pDO0FBQ0EsUUFDRSxDQUFDQSxlQUNELENBQUMsRUFBRSxTQUFTLHFCQUFhLFVBQ3pCLEVBQUUsV0FBVyxxQkFBYSxRQUMxQjtBQUVBLFVBQUksUUFBUSxPQUFPLFFBQVE7QUFDM0IsTUFBQUEsY0FBYSxLQUFLLFFBQVEsS0FBSztBQUFBLElBQ2pDO0FBQ0EsUUFDRSxDQUFDQSxlQUNELENBQUMsRUFBRSxTQUFTLHFCQUFhLFNBQ3pCLEVBQUUsV0FBVyxxQkFBYSxPQUMxQjtBQUVBLFVBQUksUUFBUSxPQUFPLFFBQVE7QUFDM0IsTUFBQUEsY0FBYSxLQUFLLFFBQVEsS0FBSztBQUFBLElBQ2pDO0FBQUEsRUFDRjtBQUNBLFNBQU9BO0FBQ1Q7QUFhTyxTQUFTLGVBQWUsUUFBUSxhQUFhLE1BQU0sT0FBTztBQUMvRCxNQUFJRCxTQUFRLE1BQU0sR0FBRztBQUNuQixXQUFPLG9CQUFvQixJQUFJO0FBQUEsRUFDakM7QUFDQSxNQUFJSixlQUFjLENBQUM7QUFDbkIsTUFBSSxRQUFRLEdBQUc7QUFDYixVQUFNLFFBQVEsT0FBTyxDQUFDLElBQUksT0FBTyxDQUFDO0FBQ2xDLFVBQU0sU0FBUyxPQUFPLENBQUMsSUFBSSxPQUFPLENBQUM7QUFDbkMsYUFBUyxJQUFJLEdBQUcsSUFBSSxPQUFPLEVBQUUsR0FBRztBQUM5QixNQUFBQSxhQUFZO0FBQUEsUUFDVixPQUFPLENBQUMsSUFBSyxRQUFRLElBQUs7QUFBQSxRQUMxQixPQUFPLENBQUM7QUFBQSxRQUNSLE9BQU8sQ0FBQztBQUFBLFFBQ1IsT0FBTyxDQUFDLElBQUssU0FBUyxJQUFLO0FBQUEsUUFDM0IsT0FBTyxDQUFDLElBQUssUUFBUSxJQUFLO0FBQUEsUUFDMUIsT0FBTyxDQUFDO0FBQUEsUUFDUixPQUFPLENBQUM7QUFBQSxRQUNSLE9BQU8sQ0FBQyxJQUFLLFNBQVMsSUFBSztBQUFBLE1BQzdCO0FBQUEsSUFDRjtBQUFBLEVBQ0YsT0FBTztBQUNMLElBQUFBLGVBQWM7QUFBQSxNQUNaLE9BQU8sQ0FBQztBQUFBLE1BQ1IsT0FBTyxDQUFDO0FBQUEsTUFDUixPQUFPLENBQUM7QUFBQSxNQUNSLE9BQU8sQ0FBQztBQUFBLE1BQ1IsT0FBTyxDQUFDO0FBQUEsTUFDUixPQUFPLENBQUM7QUFBQSxNQUNSLE9BQU8sQ0FBQztBQUFBLE1BQ1IsT0FBTyxDQUFDO0FBQUEsSUFDVjtBQUFBLEVBQ0Y7QUFDQSxjQUFZQSxjQUFhQSxjQUFhLENBQUM7QUFDdkMsUUFBTSxLQUFLLENBQUM7QUFDWixRQUFNLEtBQUssQ0FBQztBQUNaLFdBQVMsSUFBSSxHQUFHLElBQUlBLGFBQVksUUFBUSxJQUFJLEdBQUcsS0FBSyxHQUFHO0FBQ3JELE9BQUcsS0FBS0EsYUFBWSxDQUFDLENBQUM7QUFDdEIsT0FBRyxLQUFLQSxhQUFZLElBQUksQ0FBQyxDQUFDO0FBQUEsRUFDNUI7QUFDQSxTQUFPLG1CQUFtQixJQUFJLElBQUksSUFBSTtBQUN4QztBQVVPLFNBQVMsTUFBTSxRQUFRLFlBQVk7QUFDeEMsUUFBTSxtQkFBbUIsV0FBVyxVQUFVO0FBQzlDLFFBQU0sU0FBUyxVQUFVLE1BQU07QUFDL0IsTUFDRSxXQUFXLFNBQVMsTUFDbkIsT0FBTyxDQUFDLElBQUksaUJBQWlCLENBQUMsS0FBSyxPQUFPLENBQUMsS0FBSyxpQkFBaUIsQ0FBQyxJQUNuRTtBQUNBLFVBQU0sYUFBYSxTQUFTLGdCQUFnQjtBQUM1QyxVQUFNLGFBQWEsS0FBSztBQUFBLE9BQ3JCLE9BQU8sQ0FBQyxJQUFJLGlCQUFpQixDQUFDLEtBQUs7QUFBQSxJQUN0QztBQUNBLFVBQU1DLFVBQVMsYUFBYTtBQUM1QixXQUFPLENBQUMsS0FBS0E7QUFDYixXQUFPLENBQUMsS0FBS0E7QUFBQSxFQUNmO0FBQ0EsU0FBTztBQUNUO0FBY08sU0FBUyxjQUFjLFFBQVEsWUFBWTtBQUNoRCxNQUFJLFdBQVcsU0FBUyxHQUFHO0FBQ3pCLFVBQU0sbUJBQW1CLFdBQVcsVUFBVTtBQUU5QyxRQUFJLENBQUMsU0FBUyxPQUFPLENBQUMsQ0FBQyxLQUFLLENBQUMsU0FBUyxPQUFPLENBQUMsQ0FBQyxHQUFHO0FBQ2hELGFBQU8sQ0FBQyxDQUFDLGlCQUFpQixDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsaUJBQWlCLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBQUEsSUFDMUU7QUFFQSxVQUFNLFFBQVEsVUFBVTtBQUN4QixVQUFNLGFBQWEsU0FBUyxnQkFBZ0I7QUFFNUMsUUFBSSxTQUFTLE1BQU0sSUFBSSxZQUFZO0FBRWpDLGFBQU8sQ0FBQyxDQUFDLGlCQUFpQixDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsaUJBQWlCLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBQUEsSUFDMUU7QUFDQSxRQUFJLE9BQU8sQ0FBQyxJQUFJLGlCQUFpQixDQUFDLEdBQUc7QUFFbkMsYUFBTztBQUFBLFFBQ0wsQ0FBQyxPQUFPLENBQUMsSUFBSSxZQUFZLE9BQU8sQ0FBQyxHQUFHLGlCQUFpQixDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUM7QUFBQSxRQUNsRSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsT0FBTyxDQUFDLEdBQUcsT0FBTyxDQUFDLENBQUM7QUFBQSxNQUN2RDtBQUFBLElBQ0Y7QUFDQSxRQUFJLE9BQU8sQ0FBQyxJQUFJLGlCQUFpQixDQUFDLEdBQUc7QUFFbkMsYUFBTztBQUFBLFFBQ0wsQ0FBQyxPQUFPLENBQUMsR0FBRyxPQUFPLENBQUMsR0FBRyxpQkFBaUIsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDO0FBQUEsUUFDckQsQ0FBQyxpQkFBaUIsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxJQUFJLFlBQVksT0FBTyxDQUFDLENBQUM7QUFBQSxNQUNwRTtBQUFBLElBQ0Y7QUFBQSxFQUNGO0FBRUEsU0FBTyxDQUFDLE1BQU07QUFDaEI7QUF6NUJBO0FBQUE7QUFHQTtBQUFBO0FBQUE7OztBQ0hBLElBTU87QUFOUDtBQUFBO0FBTUEsSUFBTyxjQUFRO0FBQUEsTUFDZCxNQUFNO0FBQUEsTUFDTixLQUFLLENBQUMsR0FBRSxHQUFFLENBQUM7QUFBQSxNQUNYLEtBQUssQ0FBQyxLQUFJLEtBQUksR0FBRztBQUFBLE1BQ2pCLFNBQVMsQ0FBQyxPQUFPLFNBQVMsTUFBTTtBQUFBLE1BQ2hDLE9BQU8sQ0FBQyxLQUFLO0FBQUEsSUFDZDtBQUFBO0FBQUE7OztBQ1pBLElBT0ksS0FzSUc7QUE3SVA7QUFBQTtBQUtBO0FBRUEsSUFBSSxNQUFNO0FBQUEsTUFDVCxNQUFNO0FBQUEsTUFDTixLQUFLLENBQUMsR0FBRSxHQUFFLENBQUM7QUFBQSxNQUNYLFNBQVMsQ0FBQyxLQUFJLEtBQUksR0FBRztBQUFBLE1BQ3JCLE9BQU8sQ0FBQyxPQUFPLFVBQVUsU0FBUztBQUFBLElBQ25DO0FBUUEsUUFBSSxhQUFhO0FBQUE7QUFBQSxNQUVoQixHQUFHO0FBQUE7QUFBQSxRQUVGLEdBQUUsQ0FBQyxRQUFRLEtBQUssTUFBTTtBQUFBO0FBQUEsUUFFdEIsR0FBRyxDQUFDLFFBQVEsS0FBSyxPQUFPO0FBQUEsUUFDeEIsS0FBSyxDQUFDLFFBQVEsS0FBSyxNQUFNO0FBQUEsUUFDekIsS0FBSyxDQUFDLFFBQVEsS0FBSyxNQUFNO0FBQUE7QUFBQSxRQUV6QixLQUFLLENBQUMsaUJBQWlCLEtBQUssaUJBQWlCO0FBQUEsUUFDN0MsS0FBSyxDQUFDLFFBQVEsS0FBSyxPQUFPO0FBQUE7QUFBQTtBQUFBLFFBRzFCLElBQUksQ0FBQyxRQUFRLEtBQUssTUFBTTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFLeEIsSUFBSSxDQUFDLFFBQVEsS0FBSyxPQUFPO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFJekIsS0FBSyxDQUFDLFNBQVMsS0FBSyxLQUFNO0FBQUE7QUFBQSxRQUUxQixHQUFHLENBQUMsS0FBSSxLQUFJLEdBQUc7QUFBQSxNQUNoQjtBQUFBO0FBQUEsTUFHQSxJQUFJO0FBQUE7QUFBQSxRQUVILEdBQUUsQ0FBQyxTQUFTLEtBQUssSUFBTTtBQUFBLFFBQ3ZCLEdBQUcsQ0FBQyxRQUFRLEtBQUssT0FBTztBQUFBLFFBQ3hCLEtBQUssQ0FBQyxPQUFRLEtBQUssTUFBTTtBQUFBLFFBQ3pCLEtBQUssQ0FBQyxRQUFRLEtBQUssTUFBTTtBQUFBO0FBQUEsUUFFekIsS0FBSyxDQUFDLFFBQVEsS0FBSyxPQUFPO0FBQUEsUUFDMUIsS0FBSyxDQUFDLFFBQVEsS0FBSyxPQUFPO0FBQUE7QUFBQSxRQUUxQixJQUFJLENBQUMsUUFBUyxLQUFLLE1BQU07QUFBQSxRQUN6QixJQUFJLENBQUMsUUFBUSxLQUFLLE9BQU87QUFBQSxRQUN6QixLQUFLLENBQUMsU0FBUyxLQUFLLE1BQU07QUFBQSxRQUMxQixHQUFHLENBQUMsS0FBSSxLQUFJLEdBQUc7QUFBQSxNQUNoQjtBQUFBLElBQ0Q7QUFNQSxRQUFJLE1BQU0sSUFBSSxXQUFXLENBQUMsRUFBRTtBQVU1QixRQUFJLE1BQU0sU0FBVSxNQUFNLE9BQU87QUFFaEMsY0FBUSxTQUFTLElBQUksV0FBVyxDQUFDLEVBQUU7QUFFbkMsVUFBSSxJQUFJLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxHQUN4QixJQUFJLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxHQUNyQixJQUFJLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxHQUNyQixHQUFHLEdBQUc7QUFJUCxVQUFLLElBQUksb0JBQXNCLElBQUkscUJBQXVCLElBQUk7QUFDOUQsVUFBSyxJQUFJLG9CQUFzQixJQUFJLG1CQUFxQixJQUFJO0FBQzVELFVBQUssSUFBSSxvQkFBc0IsSUFBSSxvQkFBc0IsSUFBSTtBQUU3RCxVQUFJLElBQUksV0FBYyxRQUFRLEtBQUssSUFBSSxHQUFHLElBQU0sR0FBRyxJQUFLLFFBQ3JELElBQUssSUFBSTtBQUVaLFVBQUksSUFBSSxXQUFjLFFBQVEsS0FBSyxJQUFJLEdBQUcsSUFBTSxHQUFHLElBQUssUUFDckQsSUFBSyxJQUFJO0FBRVosVUFBSSxJQUFJLFdBQWMsUUFBUSxLQUFLLElBQUksR0FBRyxJQUFNLEdBQUcsSUFBSyxRQUNyRCxJQUFLLElBQUk7QUFFWixVQUFJLEtBQUssSUFBSSxLQUFLLElBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQztBQUM5QixVQUFJLEtBQUssSUFBSSxLQUFLLElBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQztBQUM5QixVQUFJLEtBQUssSUFBSSxLQUFLLElBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQztBQUU5QixhQUFPLENBQUMsSUFBSSxLQUFLLElBQUksS0FBSyxJQUFJLEdBQUc7QUFBQSxJQUNsQztBQVdBLGdCQUFJLE1BQU0sU0FBUyxLQUFLLE9BQU87QUFDOUIsVUFBSSxJQUFJLElBQUksQ0FBQyxJQUFJLEtBQ2YsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUNiLElBQUksSUFBSSxDQUFDLElBQUk7QUFHZixVQUFJLElBQUksVUFBVSxLQUFLLEtBQU0sSUFBSSxTQUFTLE9BQVEsR0FBRyxJQUFLLElBQUk7QUFDOUQsVUFBSSxJQUFJLFVBQVUsS0FBSyxLQUFNLElBQUksU0FBUyxPQUFRLEdBQUcsSUFBSyxJQUFJO0FBQzlELFVBQUksSUFBSSxVQUFVLEtBQUssS0FBTSxJQUFJLFNBQVMsT0FBUSxHQUFHLElBQUssSUFBSTtBQUU5RCxVQUFJLElBQUssSUFBSSxtQkFBcUIsSUFBSSxtQkFBcUIsSUFBSTtBQUMvRCxVQUFJLElBQUssSUFBSSxtQkFBcUIsSUFBSSxtQkFBcUIsSUFBSTtBQUMvRCxVQUFJLElBQUssSUFBSSxvQkFBc0IsSUFBSSxtQkFBcUIsSUFBSTtBQUVoRSxjQUFRLFNBQVMsSUFBSSxXQUFXLENBQUMsRUFBRTtBQUVuQyxhQUFPLENBQUMsSUFBSSxNQUFNLENBQUMsR0FBRyxJQUFJLE1BQU0sQ0FBQyxHQUFHLElBQUksTUFBTSxDQUFDLENBQUM7QUFBQSxJQUNqRDtBQUlBLElBQU8sY0FBUTtBQUFBO0FBQUE7OztBQzdJZixJQU9PO0FBUFA7QUFBQTtBQUtDO0FBRUQsSUFBTyxjQUFRO0FBQUEsTUFDZCxNQUFNO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxNQUtOLEtBQUssQ0FBQyxHQUFFLE1BQUssSUFBSTtBQUFBLE1BQ2pCLEtBQUssQ0FBQyxLQUFJLEtBQUksR0FBRztBQUFBLE1BQ2pCLFNBQVMsQ0FBQyxhQUFhLEtBQUssR0FBRztBQUFBLE1BQy9CLE9BQU8sQ0FBQyxPQUFPLFVBQVUsU0FBUztBQUFBLE1BRWxDLEtBQUssU0FBUyxLQUFLLEdBQUcsR0FBRTtBQUN2QixZQUFJLElBQUksSUFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLElBQUksSUFBSSxJQUFJO0FBQzlDLFlBQUksSUFBSSxDQUFDLEdBQUcsSUFBSSxJQUFJLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQztBQUVqQyxZQUFJLE1BQU07QUFBRyxpQkFBTyxDQUFDLEdBQUUsR0FBRSxDQUFDO0FBSTFCLFlBQUksSUFBSTtBQUdSLFlBQUksS0FBSztBQUNULFlBQUksS0FBSztBQUVULGFBQUssWUFBSSxXQUFXLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztBQUMzQixhQUFLLFlBQUksV0FBVyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7QUFDM0IsYUFBSyxZQUFJLFdBQVcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO0FBRTNCLGFBQU0sSUFBSSxNQUFPLEtBQU0sS0FBSyxLQUFPLElBQUk7QUFDdkMsYUFBTSxJQUFJLE1BQU8sS0FBTSxLQUFLLEtBQU8sSUFBSTtBQUt2QyxhQUFLLEtBQUssS0FBSyxLQUFLLE1BQU07QUFDMUIsYUFBSyxLQUFLLEtBQUssS0FBSyxNQUFNO0FBRTFCLFlBQUksSUFBSSxJQUFJLEtBQUssS0FBSyxLQUFNLElBQUksTUFBTSxLQUFNLENBQUMsSUFBSSxLQUFLLElBQUk7QUFHMUQsWUFBSSxJQUFJLElBQUksTUFBTSxJQUFJLE9BQU87QUFDN0IsWUFBSSxLQUFLLEtBQUssSUFBSSxLQUFLLEtBQUssT0FBTyxJQUFJLE9BQU87QUFPOUMsZUFBTyxDQUFDLEdBQUcsR0FBRyxDQUFDO0FBQUEsTUFDaEI7QUFBQSxJQUNEO0FBTUEsZ0JBQUksTUFBTSxTQUFTLEtBQUssR0FBRyxHQUFHO0FBQzdCLFVBQUksSUFBSSxJQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUksSUFBSSxJQUFJLElBQUk7QUFHOUMsVUFBSSxJQUFJO0FBQ1IsVUFBSSxJQUFJO0FBR1IsVUFBSSxLQUFLO0FBQ1QsVUFBSSxLQUFLO0FBRVQsV0FBSyxZQUFJLFdBQVcsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDO0FBQzNCLFdBQUssWUFBSSxXQUFXLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQztBQUMzQixXQUFLLFlBQUksV0FBVyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUM7QUFFM0IsV0FBTSxJQUFJLE1BQU8sS0FBTSxLQUFLLEtBQU8sSUFBSTtBQUN2QyxXQUFNLElBQUksTUFBTyxLQUFNLEtBQUssS0FBTyxJQUFJO0FBR3ZDLFVBQUksSUFBSSxDQUFDLEdBQUcsSUFBSSxJQUFJLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQztBQUdqQyxXQUFNLElBQUksS0FBTSxJQUFLLEtBQUssSUFBTSxJQUFJLE1BQU87QUFDM0MsV0FBTSxJQUFJLEtBQU0sSUFBSyxLQUFLLElBQU0sSUFBSSxNQUFPO0FBRTNDLFVBQUksS0FBSyxJQUFFO0FBRVgsVUFBSSxNQUFNLElBQUksSUFBSSxLQUFLLE1BQU0sS0FBSyxJQUFJLElBQUksSUFBRSxDQUFDLElBQUk7QUFFakQsVUFBSSxLQUFLLEtBQUssS0FBSztBQUNuQixVQUFJLEtBQUssS0FBSyxLQUFLO0FBRW5CLGFBQU8sQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUFBLElBQ2hCO0FBQUE7QUFBQTs7O0FDakdBLElBU0ksT0F3Qkc7QUFqQ1A7QUFBQTtBQUtBO0FBQ0E7QUFHQSxJQUFJLFFBQVE7QUFBQSxNQUNYLE1BQU07QUFBQSxNQUNOLFNBQVMsQ0FBQyxhQUFhLFVBQVUsS0FBSztBQUFBLE1BQ3RDLE9BQU8sQ0FBQyxTQUFTLFVBQVU7QUFBQSxNQUMzQixLQUFLLENBQUMsR0FBRSxHQUFFLENBQUM7QUFBQSxNQUNYLEtBQUssQ0FBQyxLQUFJLEtBQUksR0FBRztBQUFBLE1BRWpCLEtBQUssU0FBUyxLQUFJO0FBQ2pCLFlBQUksSUFBSSxJQUFJLENBQUMsR0FDYixJQUFJLElBQUksQ0FBQyxHQUNULElBQUksSUFBSSxDQUFDLEdBQ1QsR0FBRyxHQUFHO0FBRU4sYUFBSyxJQUFJLE1BQU0sSUFBSSxLQUFLO0FBQ3hCLFlBQUksSUFBSSxLQUFLLElBQUksRUFBRTtBQUNuQixZQUFJLElBQUksS0FBSyxJQUFJLEVBQUU7QUFDbkIsZUFBTyxDQUFDLEdBQUcsR0FBRyxDQUFDO0FBQUEsTUFDaEI7QUFBQSxNQUVBLEtBQUssU0FBUyxLQUFLO0FBQ2xCLGVBQU8sWUFBSSxJQUFJLE1BQU0sSUFBSSxHQUFHLENBQUM7QUFBQSxNQUM5QjtBQUFBLElBQ0Q7QUFFQSxJQUFPLGdCQUFRO0FBRWYsZ0JBQUksUUFBUSxTQUFTLEtBQUk7QUFDeEIsVUFBSSxJQUFJLElBQUksQ0FBQyxHQUFHLElBQUksSUFBSSxDQUFDLEdBQUcsSUFBSSxJQUFJLENBQUM7QUFFckMsVUFBSSxJQUFJLEtBQUssS0FBSyxJQUFFLElBQUksSUFBRSxDQUFDO0FBQzNCLFVBQUksS0FBSyxLQUFLLE1BQU0sR0FBRSxDQUFDO0FBQ3ZCLFVBQUksSUFBSSxLQUFLLE1BQU0sSUFBSSxLQUFLO0FBQzVCLFVBQUksSUFBSSxHQUFHO0FBQ1YsYUFBSztBQUFBLE1BQ047QUFFQSxhQUFPLENBQUMsR0FBRSxHQUFFLENBQUM7QUFBQSxJQUNkO0FBRUEsZ0JBQUksUUFBUSxTQUFTLEtBQUk7QUFDdkIsYUFBTyxZQUFJLE1BQU0sWUFBSSxJQUFJLEdBQUcsQ0FBQztBQUFBLElBQy9CO0FBQUE7QUFBQTs7O0FDbERBO0FBQUE7QUFBQTtBQUVBLFdBQU8sVUFBVTtBQUFBLE1BQ2hCLGFBQWEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzNCLGdCQUFnQixDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDOUIsUUFBUSxDQUFDLEdBQUcsS0FBSyxHQUFHO0FBQUEsTUFDcEIsY0FBYyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDNUIsU0FBUyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDdkIsU0FBUyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDdkIsVUFBVSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDeEIsU0FBUyxDQUFDLEdBQUcsR0FBRyxDQUFDO0FBQUEsTUFDakIsa0JBQWtCLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxNQUNoQyxRQUFRLENBQUMsR0FBRyxHQUFHLEdBQUc7QUFBQSxNQUNsQixjQUFjLENBQUMsS0FBSyxJQUFJLEdBQUc7QUFBQSxNQUMzQixTQUFTLENBQUMsS0FBSyxJQUFJLEVBQUU7QUFBQSxNQUNyQixhQUFhLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxNQUMzQixhQUFhLENBQUMsSUFBSSxLQUFLLEdBQUc7QUFBQSxNQUMxQixjQUFjLENBQUMsS0FBSyxLQUFLLENBQUM7QUFBQSxNQUMxQixhQUFhLENBQUMsS0FBSyxLQUFLLEVBQUU7QUFBQSxNQUMxQixTQUFTLENBQUMsS0FBSyxLQUFLLEVBQUU7QUFBQSxNQUN0QixrQkFBa0IsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ2hDLFlBQVksQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzFCLFdBQVcsQ0FBQyxLQUFLLElBQUksRUFBRTtBQUFBLE1BQ3ZCLFFBQVEsQ0FBQyxHQUFHLEtBQUssR0FBRztBQUFBLE1BQ3BCLFlBQVksQ0FBQyxHQUFHLEdBQUcsR0FBRztBQUFBLE1BQ3RCLFlBQVksQ0FBQyxHQUFHLEtBQUssR0FBRztBQUFBLE1BQ3hCLGlCQUFpQixDQUFDLEtBQUssS0FBSyxFQUFFO0FBQUEsTUFDOUIsWUFBWSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDMUIsYUFBYSxDQUFDLEdBQUcsS0FBSyxDQUFDO0FBQUEsTUFDdkIsWUFBWSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDMUIsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsZUFBZSxDQUFDLEtBQUssR0FBRyxHQUFHO0FBQUEsTUFDM0Isa0JBQWtCLENBQUMsSUFBSSxLQUFLLEVBQUU7QUFBQSxNQUM5QixjQUFjLENBQUMsS0FBSyxLQUFLLENBQUM7QUFBQSxNQUMxQixjQUFjLENBQUMsS0FBSyxJQUFJLEdBQUc7QUFBQSxNQUMzQixXQUFXLENBQUMsS0FBSyxHQUFHLENBQUM7QUFBQSxNQUNyQixjQUFjLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxNQUM1QixnQkFBZ0IsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzlCLGlCQUFpQixDQUFDLElBQUksSUFBSSxHQUFHO0FBQUEsTUFDN0IsaUJBQWlCLENBQUMsSUFBSSxJQUFJLEVBQUU7QUFBQSxNQUM1QixpQkFBaUIsQ0FBQyxJQUFJLElBQUksRUFBRTtBQUFBLE1BQzVCLGlCQUFpQixDQUFDLEdBQUcsS0FBSyxHQUFHO0FBQUEsTUFDN0IsY0FBYyxDQUFDLEtBQUssR0FBRyxHQUFHO0FBQUEsTUFDMUIsWUFBWSxDQUFDLEtBQUssSUFBSSxHQUFHO0FBQUEsTUFDekIsZUFBZSxDQUFDLEdBQUcsS0FBSyxHQUFHO0FBQUEsTUFDM0IsV0FBVyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDekIsV0FBVyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDekIsY0FBYyxDQUFDLElBQUksS0FBSyxHQUFHO0FBQUEsTUFDM0IsYUFBYSxDQUFDLEtBQUssSUFBSSxFQUFFO0FBQUEsTUFDekIsZUFBZSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDN0IsZUFBZSxDQUFDLElBQUksS0FBSyxFQUFFO0FBQUEsTUFDM0IsV0FBVyxDQUFDLEtBQUssR0FBRyxHQUFHO0FBQUEsTUFDdkIsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsY0FBYyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDNUIsUUFBUSxDQUFDLEtBQUssS0FBSyxDQUFDO0FBQUEsTUFDcEIsYUFBYSxDQUFDLEtBQUssS0FBSyxFQUFFO0FBQUEsTUFDMUIsUUFBUSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDdEIsU0FBUyxDQUFDLEdBQUcsS0FBSyxDQUFDO0FBQUEsTUFDbkIsZUFBZSxDQUFDLEtBQUssS0FBSyxFQUFFO0FBQUEsTUFDNUIsUUFBUSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDdEIsWUFBWSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDMUIsV0FBVyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDekIsYUFBYSxDQUFDLEtBQUssSUFBSSxFQUFFO0FBQUEsTUFDekIsVUFBVSxDQUFDLElBQUksR0FBRyxHQUFHO0FBQUEsTUFDckIsU0FBUyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDdkIsU0FBUyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDdkIsWUFBWSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDMUIsaUJBQWlCLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxNQUMvQixhQUFhLENBQUMsS0FBSyxLQUFLLENBQUM7QUFBQSxNQUN6QixnQkFBZ0IsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzlCLGFBQWEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzNCLGNBQWMsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzVCLGFBQWEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzNCLHdCQUF3QixDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDdEMsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsY0FBYyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDNUIsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsZUFBZSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDN0IsaUJBQWlCLENBQUMsSUFBSSxLQUFLLEdBQUc7QUFBQSxNQUM5QixnQkFBZ0IsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzlCLGtCQUFrQixDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDaEMsa0JBQWtCLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxNQUNoQyxrQkFBa0IsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ2hDLGVBQWUsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzdCLFFBQVEsQ0FBQyxHQUFHLEtBQUssQ0FBQztBQUFBLE1BQ2xCLGFBQWEsQ0FBQyxJQUFJLEtBQUssRUFBRTtBQUFBLE1BQ3pCLFNBQVMsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3ZCLFdBQVcsQ0FBQyxLQUFLLEdBQUcsR0FBRztBQUFBLE1BQ3ZCLFVBQVUsQ0FBQyxLQUFLLEdBQUcsQ0FBQztBQUFBLE1BQ3BCLG9CQUFvQixDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDbEMsY0FBYyxDQUFDLEdBQUcsR0FBRyxHQUFHO0FBQUEsTUFDeEIsZ0JBQWdCLENBQUMsS0FBSyxJQUFJLEdBQUc7QUFBQSxNQUM3QixnQkFBZ0IsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzlCLGtCQUFrQixDQUFDLElBQUksS0FBSyxHQUFHO0FBQUEsTUFDL0IsbUJBQW1CLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxNQUNqQyxxQkFBcUIsQ0FBQyxHQUFHLEtBQUssR0FBRztBQUFBLE1BQ2pDLG1CQUFtQixDQUFDLElBQUksS0FBSyxHQUFHO0FBQUEsTUFDaEMsbUJBQW1CLENBQUMsS0FBSyxJQUFJLEdBQUc7QUFBQSxNQUNoQyxnQkFBZ0IsQ0FBQyxJQUFJLElBQUksR0FBRztBQUFBLE1BQzVCLGFBQWEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzNCLGFBQWEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzNCLFlBQVksQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzFCLGVBQWUsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzdCLFFBQVEsQ0FBQyxHQUFHLEdBQUcsR0FBRztBQUFBLE1BQ2xCLFdBQVcsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3pCLFNBQVMsQ0FBQyxLQUFLLEtBQUssQ0FBQztBQUFBLE1BQ3JCLGFBQWEsQ0FBQyxLQUFLLEtBQUssRUFBRTtBQUFBLE1BQzFCLFVBQVUsQ0FBQyxLQUFLLEtBQUssQ0FBQztBQUFBLE1BQ3RCLGFBQWEsQ0FBQyxLQUFLLElBQUksQ0FBQztBQUFBLE1BQ3hCLFVBQVUsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3hCLGlCQUFpQixDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDL0IsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsaUJBQWlCLENBQUMsS0FBSyxLQUFLLEdBQUc7QUFBQSxNQUMvQixpQkFBaUIsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQy9CLGNBQWMsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzVCLGFBQWEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzNCLFFBQVEsQ0FBQyxLQUFLLEtBQUssRUFBRTtBQUFBLE1BQ3JCLFFBQVEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3RCLFFBQVEsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQ3RCLGNBQWMsQ0FBQyxLQUFLLEtBQUssR0FBRztBQUFBLE1BQzVCLFVBQVUsQ0FBQyxLQUFLLEdBQUcsR0FBRztBQUFBLE1BQ3RCLGlCQUFpQixDQUFDLEtBQUssSUFBSSxHQUFHO0FBQUEsTUFDOUIsT0FBTyxDQUFDLEtBQUssR0FBRyxDQUFDO0FBQUEsTUFDakIsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsYUFBYSxDQUFDLElBQUksS0FBSyxHQUFHO0FBQUEsTUFDMUIsZUFBZSxDQUFDLEtBQUssSUFBSSxFQUFFO0FBQUEsTUFDM0IsVUFBVSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDeEIsY0FBYyxDQUFDLEtBQUssS0FBSyxFQUFFO0FBQUEsTUFDM0IsWUFBWSxDQUFDLElBQUksS0FBSyxFQUFFO0FBQUEsTUFDeEIsWUFBWSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDMUIsVUFBVSxDQUFDLEtBQUssSUFBSSxFQUFFO0FBQUEsTUFDdEIsVUFBVSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDeEIsV0FBVyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDekIsYUFBYSxDQUFDLEtBQUssSUFBSSxHQUFHO0FBQUEsTUFDMUIsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsYUFBYSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDM0IsUUFBUSxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDdEIsZUFBZSxDQUFDLEdBQUcsS0FBSyxHQUFHO0FBQUEsTUFDM0IsYUFBYSxDQUFDLElBQUksS0FBSyxHQUFHO0FBQUEsTUFDMUIsT0FBTyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDckIsUUFBUSxDQUFDLEdBQUcsS0FBSyxHQUFHO0FBQUEsTUFDcEIsV0FBVyxDQUFDLEtBQUssS0FBSyxHQUFHO0FBQUEsTUFDekIsVUFBVSxDQUFDLEtBQUssSUFBSSxFQUFFO0FBQUEsTUFDdEIs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LEdBQUc7QUFBQSxRQUNYO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixVQUFVO0FBQUEsTUFDNUI7QUFBQSxNQUNBLENBQUMsSUFBSSxHQUFHLEdBQUc7QUFBQSxRQUNUO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixVQUFVO0FBQUEsTUFDNUI7QUFBQSxNQUNBLENBQUMsSUFBSSxHQUFHLEdBQUc7QUFBQSxRQUNUO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixVQUFVO0FBQUEsTUFDNUI7QUFBQSxNQUNBLENBQUMsSUFBSSxHQUFHLEdBQUc7QUFBQSxRQUNUO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixVQUFVO0FBQUEsTUFDNUI7QUFBQSxNQUNBLENBQUMsSUFBSSxLQUFLLEdBQUc7QUFBQSxRQUNYO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixVQUFVO0FBQUEsTUFDNUI7QUFBQSxNQUNBLENBQUMsSUFBSSxJQUFJLEdBQUc7QUFBQSxRQUNWO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixVQUFVO0FBQUEsTUFDNUI7QUFBQSxNQUNBLENBQUMsSUFBSSxLQUFLLEdBQUc7QUFBQSxRQUNYO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixVQUFVO0FBQUEsTUFDNUI7QUFBQSxNQUNBLENBQUMsSUFBSSxHQUFHLEdBQUc7QUFBQSxRQUNUO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixVQUFVO0FBQUEsTUFDNUI7QUFBQSxNQUNBLENBQUMsSUFBSSxHQUFHLEdBQUc7QUFBQSxRQUNUO0FBQUEsUUFDQSxjQUFjLEdBQUcsQ0FBQztBQUFBLFFBQ2xCLGdCQUFnQixVQUFVO0FBQUEsTUFDNUI7QUFBQSxNQUNBLENBQUMsSUFBSSxJQUFJLEdBQUc7QUFB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LE9BQU8sY0FBYyxFQUFFLGNBQWM7IiwKICAibmFtZXMiOiBbImVycm9yIiwgInRyYW5zZm9ybSIsICJjb29yZGluYXRlcyIsICJvZmZzZXQiLCAiZXF1YWxzIiwgImV4dGVuZCIsICJpc0VtcHR5IiwgImludGVyc2VjdHMiLCAibmFtZXMiLCAidG9TdHJpbmciLCAiRXZlbnRUeXBlX2RlZmF1bHQiLCAiaW5pdF9FdmVudFR5cGUiLCAiUkFESVVTIiwgIkVYVEVOVCIsICJNRVRFUlNfUEVSX1VOSVQiLCAiUFJPSkVDVElPTlMiLCAiY2xlYXIiLCAiY2FjaGUiLCAiY2xlYXIiLCAiYWRkIiwgInJlbW92ZSIsICJ0cmFuc2Zvcm0iLCAiZ2V0IiwgImFkZCIsICJlcXVhbHMiLCAicm90YXRlIiwgInNjYWxlIiwgInNxdWFyZWREaXN0YW5jZSIsICJ3cmFwWCIsICJjb29yZGluYXRlcyIsICJnZXRBcmVhIiwgImRpc3RhbmNlIiwgImdldCIsICJkaXNhYmxlIiwgImFkZCIsICJ0b0VQU0c0MzI2IiwgImNsZWFyIiwgImVxdWFscyIsICJ0cmFuc2Zvcm0iLCAiUFJPSkVDVElPTlMiLCAib2Zmc2V0IiwgIm5vbmUiLCAib2Zmc2V0IiwgInRyYW5zZm9ybSIsICJyb3RhdGUiLCAic2NhbGUiLCAidHJhbnNsYXRlIiwgImluaXRfdHJhbnNmb3JtIiwgImluaXRfdHJhbnNmb3JtIiwgInRyYW5zZm9ybSIsICJjbG9uZSIsICJleHRlbnQiLCAiZ2V0IiwgInNjYWxlIiwgInRyYW5zZm9ybSIsICJpbml0X3RyYW5zZm9ybSIsICJjb29yZGluYXRlcyIsICJyb3RhdGUiLCAic2NhbGUiLCAidHJhbnNsYXRlIiwgIm9mZnNldCIsICJzcXVhcmVkRGlzdGFuY2UiLCAib2Zmc2V0IiwgImNvb3JkaW5hdGVzIiwgIm9mZnNldCIsICJzcXVhcmVkRGlzdGFuY2UiLCAib2Zmc2V0IiwgImNvb3JkaW5hdGVzIiwgIm9mZnNldCIsICJjb29yZGluYXRlcyIsICJjb29yZGluYXRlcyIsICJzcXVhcmVkRGlzdGFuY2UiLCAib2Zmc2V0IiwgIm9mZnNldCIsICJvZmZzZXQiLCAib2Zmc2V0IiwgIm9mZnNldCIsICJvZmZzZXQiLCAiaXNFbXB0eSIsICJvZmZzZXQiLCAiYW5nbGUiLCAiY29vcmRpbmF0ZXMiLCAibGluZWFyUmluZyIsICJsaW5lYXJSaW5ncyIsICJub25lIiwgImVxdWFscyIsICJyb3RhdGUiLCAiYWRkIiwgIm9mZnNldCIsICJpc0VtcHR5IiwgInVzZXJQcm9qZWN0aW9uIiwgImluaXRfRXZlbnRUeXBlIiwgImxheWVyU3RhdGUiLCAiRXZlbnRUeXBlX2RlZmF1bHQiLCAiRXZlbnRfZGVmYXVsdCIsICJpbml0X0V2ZW50IiwgImNhbnZhc1Bvb2wiLCAiY2FjaGUiLCAidHJhbnNmb3JtIiwgInNjYWxlIiwgImJ1ZmZlciIsICJzY2FsZSIsICJlcnJvciIsICJnZXQiLCAic2VsZiIsICJMYXllcl9kZWZhdWx0IiwgImluaXRfTGF5ZXIiLCAidGlsZSIsICJjYW52YXNQb29sIiwgIkxheWVyX2RlZmF1bHQiLCAiaW5pdF9MYXllciIsICJpbml0X0V2ZW50IiwgImluaXRfRXZlbnRUeXBlIiwgInRyYW5zZm9ybSIsICJFdmVudF9kZWZhdWx0IiwgIkV2ZW50VHlwZV9kZWZhdWx0IiwgImNsb25lIiwgIm9mZnNldCIsICJvZmZzZXQiLCAiY29vcmRpbmF0ZXMiLCAiSW1hZ2VfZGVmYXVsdCIsICJpbml0X0ltYWdlIiwgInNjYWxlIiwgInRvU3RyaW5nIiwgImluaXRfSW1hZ2UiLCAiSW1hZ2VfZGVmYXVsdCIsICJzY2FsZSIsICJhZGQiLCAic2NhbGUiLCAic2NhbGUiLCAiZXh0ZW5kIiwgImludGVyc2VjdHMiLCAiYmJveCIsICJsZXZlbCIsICJnZXQiLCAiaW5pdF9JbWFnZSIsICJJbWFnZV9kZWZhdWx0IiwgInNjYWxlIiwgImdldCIsICJpbWFnZSIsICJvZmZzZXQiLCAibmFtZXMiLCAicGFyc2UiLCAidHlwZSIsICJwYXJzZSIsICJleHByZXNzaW9uIiwgImNvbnRleHQiLCAiYWx3YXlzIiwgImNvbnRleHQiLCAib2Zmc2V0IiwgIlByb3BlcnR5IiwgImNvb3JkaW5hdGVzIiwgIm9mZnNldCIsICJmaWxsSW5zdHJ1Y3Rpb24iLCAib2Zmc2V0IiwgIm9mZnNldCIsICJjb29yZGluYXRlcyIsICJvZmZzZXQiLCAib2Zmc2V0IiwgImNvb3JkaW5hdGVzIiwgInAxIiwgInAyIiwgInAzIiwgInNjYWxlIiwgIm9mZnNldCIsICJzY2FsZSIsICJtZWFzdXJlQW5kQ2FjaGVUZXh0V2lkdGgiLCAiY2FjaGUiLCAicm90YXRlIiwgImluaXRfdHJhbnNmb3JtIiwgImluaXRfdHJhbnNmb3JtIiwgInNjYWxlIiwgInRleHQiLCAicDEiLCAicDIiLCAicDMiLCAicDQiLCAiZmlsbEluc3RydWN0aW9uIiwgInN0cm9rZUluc3RydWN0aW9uIiwgInRyYW5zZm9ybSIsICJpbnRlcnNlY3RzIiwgImkiLCAiaWkiLCAiZGlzdGFuY2UiLCAiaW5pdF90cmFuc2Zvcm0iLCAidHJhbnNmb3JtIiwgImkiLCAicmVzdWx0IiwgImluaXRfdHJhbnNmb3JtIiwgInRyYW5zZm9ybSIsICJvZmZzZXQiLCAiaW5pdF9zdHlsZSIsICJpbml0X0ltYWdlIiwgInRyYW5zZm9ybXMiLCAiaSIsICJnZW9tZXRyeSIsICJpbml0X3N0eWxlIiwgInRyYW5zZm9ybSIsICJpbWFnZVJlcGxheSIsICJpbml0X0xheWVyIiwgImluaXRfRXZlbnRUeXBlIiwgIkxheWVyX2RlZmF1bHQiLCAidHJhbnNmb3JtIiwgImNhbnZhc1Bvb2wiLCAicmVuZGVyIiwgIkV2ZW50VHlwZV9kZWZhdWx0IiwgInRyYW5zZm9ybXMiLCAid3JhcFgiLCAidXNlclByb2plY3Rpb24iLCAiZXh0ZW50IiwgInVzZXJFeHRlbnQiLCAiUkJ1c2giLCAiYmJveCIsICJlcXVhbHMiLCAiQ2lyY2xlX2RlZmF1bHQiLCAiaW5pdF9DaXJjbGUiLCAiaW5pdF90cmFuc2Zvcm0iLCAic3F1YXJlZERpc3RhbmNlIiwgIm9mZnNldCIsICJjb29yZGluYXRlcyIsICJyb3RhdGUiLCAiY29vcmRpbmF0ZXMiLCAiZW5kcyIsICJsYXlvdXQiLCAib2Zmc2V0IiwgImNvb3JkaW5hdGVzIiwgInNxdWFyZWREaXN0YW5jZSIsICJsaW5lYXJSaW5nc3MiLCAib2Zmc2V0IiwgImNvb3JkaW5hdGVzIiwgIm9mZnNldCIsICJsaW5lYXJSaW5nc3MiLCAiaW5pdF9DaXJjbGUiLCAicmVuZGVyRmVhdHVyZSIsICJ0bXBUcmFuc2Zvcm0iLCAiRmVhdHVyZV9kZWZhdWx0IiwgImluaXRfRmVhdHVyZSIsICJpbml0X3RyYW5zZm9ybSIsICJsaW5lYXJSaW5nc3MiLCAib2Zmc2V0IiwgInRyYW5zZm9ybSIsICJnZXQiLCAic2NhbGUiLCAiYWxsIiwgImZvcm1hdCIsICJ4aHIiLCAiVmVjdG9yX2V4cG9ydHMiLCAiVmVjdG9yX2RlZmF1bHQiLCAiaW5pdF9WZWN0b3IiLCAiaW5pdF9GZWF0dXJlIiwgImFsbCIsICJGZWF0dXJlX2RlZmF1bHQiLCAiZXF1YWxzIiwgIlZBUlMiLCAiRVZFTlRfVFlQRSIsICJDT05UUk9MX1RZUEUiLCAiVEFSR0VUX1RZUEUiLCAiUFJPVklERVJTIiwgIkRFRkFVTFRfT1BUSU9OUyIsICJwcm92aWRlciIsICJsYWJlbCIsICJwbGFjZWhvbGRlciIsICJmZWF0dXJlU3R5bGUiLCAidGFyZ2V0VHlwZSIsICJsYW5nIiwgImxpbWl0IiwgImtlZXBPcGVuIiwgInByZXZlbnREZWZhdWx0IiwgInByZXZlbnRQYW5uaW5nIiwgInByZXZlbnRNYXJrZXIiLCAiZGVmYXVsdEZseVJlc29sdXRpb24iLCAiZGVidWciLCAiYXNzZXJ0IiwgImNvbmRpdGlvbiIsICJtZXNzYWdlIiwgIkVycm9yIiwgInJhbmRvbUlkIiwgInByZWZpeCIsICJpZCIsICJ3aW5kb3ciLCAicGVyZm9ybWFuY2UiLCAibm93T2Zmc2V0IiwgIkRhdGUiLCAibm93IiwgInRpbWluZyIsICJuYXZpZ2F0aW9uU3RhcnQiLCAidG9TdHJpbmciLCAiaXNOdW1lcmljIiwgInN0ciIsICJ0ZXN0IiwgImFkZENsYXNzIiwgImVsZW1lbnQiLCAiY2xhc3NuYW1lIiwgInRpbWVvdXQiLCAiQXJyYXkiLCAiaXNBcnJheSIsICJmb3JFYWNoIiwgImVhY2giLCAiYXJyYXkiLCAic3BsaXQiLCAiaSIsICJsZW5ndGgiLCAiaGFzQ2xhc3MiLCAiX2FkZENsYXNzIiwgInJlbW92ZUNsYXNzIiwgIl9yZW1vdmVDbGFzcyIsICJjIiwgImNsYXNzTGlzdCIsICJjb250YWlucyIsICJjbGFzc1JlZ2V4IiwgImNsYXNzTmFtZSIsICJ0ZW1wbGF0ZSIsICJodG1sIiwgInJvdyIsICJyZXBsYWNlIiwgImh0bSIsICJrZXkiLCAidmFsdWUiLCAiU3RyaW5nIiwgInJlcGxhY2VBbGwiLCAiY3JlYXRlRWxlbWVudCIsICJub2RlIiwgImVsZW0iLCAiZG9jdW1lbnQiLCAiYXR0ciIsICJzZXRBdHRyaWJ1dGUiLCAibmFtZSIsICJpbm5lckhUTUwiLCAiZnJhZyIsICJjcmVhdGVEb2N1bWVudEZyYWdtZW50IiwgImNoaWxkTm9kZXMiLCAiYXBwZW5kIiwgIlJlZ0V4cCIsICJlbCIsICJrbGFzcyIsICJhZGQiLCAidHJpbSIsICJzZXRUaW1lb3V0IiwgInJlbW92ZSIsICJrbGFzc2VzIiwgImNzc0NsYXNzZXMiLCAiSHRtbCIsICJvcHRpb25zIiwgInRoaXMiLCAiZWxzIiwgImNyZWF0ZUNvbnRyb2wiLCAiY29udGFpbmVyIiwgImNvbnRhaW5lckNsYXNzIiwgImVsZW1lbnRzIiwgIm5hbWVzcGFjZSIsICJpbnB1dFRleHQiLCAiY29udGFpbmVySWQiLCAiaW5wdXQiLCAiY29udHJvbCIsICJxdWVyeVNlbGVjdG9yIiwgInNlYXJjaCIsICJyZXN1bHQiLCAiZ2xhc3MiLCAiYnV0dG9uIiwgImpzb24iLCAib2JqIiwgIlByb21pc2UiLCAicmVzb2x2ZSIsICJyZWplY3QiLCAidXJsIiwgImRhdGEiLCAidG9RdWVyeVN0cmluZyIsICJjb25maWciLCAibWV0aG9kIiwgIm1vZGUiLCAiY3JlZGVudGlhbHMiLCAianNvbnAiLCAiY2FsbGJhY2siLCAiaGVhZCIsICJzY3JpcHQiLCAiY2FsbGJhY2tOYW1lIiwgIk1hdGgiLCAicm91bmQiLCAicmFuZG9tIiwgImluZGV4T2YiLCAicmVtb3ZlQ2hpbGQiLCAiZmV0Y2giLCAidGhlbiIsICJyIiwgImNhdGNoIiwgIk9iamVjdCIsICJrZXlzIiwgInJlZHVjZSIsICJhY2MiLCAiayIsICJwdXNoIiwgImVuY29kZVVSSUNvbXBvbmVudCIsICJqb2luIiwgIm9sQ29udHJvbCIsICJidXR0b25Db250cm9sSWQiLCAiaW5wdXRRdWVyeUlkIiwgImlucHV0U2VhcmNoSWQiLCAiaGlkZGVuIiwgImljb24iLCAiUGhvdG9uIiwgImNvbnN0cnVjdG9yIiwgInNldHRpbmdzIiwgInBhcmFtcyIsICJxIiwgImxhbmdzIiwgInRvTG93ZXJDYXNlIiwgInF1ZXJ5IiwgImluY2x1ZGVzIiwgInJlc3VsdHMiLCAiZmVhdHVyZXMiLCAibWFwIiwgImxvbiIsICJnZW9tZXRyeSIsICJjb29yZGluYXRlcyIsICJsYXQiLCAiYWRkcmVzcyIsICJwcm9wZXJ0aWVzIiwgInBvc3Rjb2RlIiwgImNpdHkiLCAic3RhdGUiLCAiY291bnRyeSIsICJvcmlnaW5hbCIsICJmb3JtYXR0ZWQiLCAiZGV0YWlscyIsICJPcGVuU3RyZWV0IiwgImZvcm1hdCIsICJhZGRyZXNzZGV0YWlscyIsICJjb3VudHJ5Y29kZXMiLCAidmlld2JveCIsICJvcHQiLCAiYmJveCIsICJib3VuZGluZ2JveCIsICJkaXNwbGF5X25hbWUiLCAicm9hZCIsICJob3VzZU51bWJlciIsICJob3VzZV9udW1iZXIiLCAidG93biIsICJNYXBRdWVzdCIsICJuZWlnaGJvdXJob29kIiwgIkJpbmciLCAiaW5jbHVkZU5laWdoYm9yaG9vZCIsICJtYXhSZXN1bHRzIiwgInJlc291cmNlcyIsICJyZXNvdXJjZVNldHMiLCAicG9pbnQiLCAiZm9ybWF0dGVkQWRkcmVzcyIsICJPcGVuQ2FnZSIsICJjb3VudHJ5Y29kZSIsICJwcmV0dHkiLCAibm9fYW5ub3RhdGlvbnMiLCAibG5nIiwgImNvbXBvbmVudHMiLCAiTm9taW5hdGltIiwgImJhc2UiLCAiQmFzZSIsICJsYXllck5hbWUiLCAibGF5ZXIiLCAiTGF5ZXJWZWN0b3IiLCAic291cmNlIiwgIlNvdXJjZVZlY3RvciIsICJkaXNwbGF5SW5MYXllclN3aXRjaGVyIiwgIm5ld1Byb3ZpZGVyIiwgImxhc3RRdWVyeSIsICJyZWdpc3RlcmVkTGlzdGVuZXJzIiwgIm1hcENsaWNrIiwgInNldExpc3RlbmVycyIsICJvcGVuU2VhcmNoIiwgImV2dCIsICJzdG9wUHJvcGFnYXRpb24iLCAiZXhwYW5kZWQiLCAiY29sbGFwc2UiLCAiZXhwYW5kIiwgImFkZEV2ZW50TGlzdGVuZXIiLCAidGFyZ2V0IiwgIndoaWNoIiwgImtleUNvZGUiLCAiZm9jdXMiLCAicGFyYW1ldGVycyIsICJnZXRQYXJhbWV0ZXJzIiwgImZpcnN0Q2hpbGQiLCAiY2xlYXJSZXN1bHRzIiwgInNwaW4iLCAiYWpheCIsICJyZXMiLCAiY29uc29sZSIsICJpbmZvIiwgInJlc18iLCAiaGFuZGxlUmVzcG9uc2UiLCAiY3JlYXRlTGlzdCIsICJsaXN0ZW5NYXBDbGljayIsICJsaSIsICJyZXNwb25zZSIsICJ1bCIsICJhZGRyZXNzSHRtbCIsICJhZGRyZXNzVGVtcGxhdGUiLCAiY2hvc2VuIiwgInBsYWNlIiwgImFkZHJlc3NPYmoiLCAiYWRkcmVzc09yaWdpbmFsIiwgImdldE1hcCIsICJjb29yZF8iLCAiTnVtYmVyIiwgInBhcnNlRmxvYXQiLCAicHJvamVjdGlvbiIsICJnZXRWaWV3IiwgImdldFByb2plY3Rpb24iLCAiY29vcmQiLCAicHJvaiIsICJ0cmFuc2Zvcm0iLCAidHJhbnNmb3JtRXh0ZW50IiwgImRpc3BhdGNoRXZlbnQiLCAidHlwZSIsICJjb29yZGluYXRlIiwgImZlYXR1cmUiLCAiY3JlYXRlRmVhdHVyZSIsICJmaXQiLCAiZHVyYXRpb24iLCAiYW5pbWF0ZSIsICJjZW50ZXIiLCAicmVzb2x1dGlvbiIsICJGZWF0dXJlIiwgIlBvaW50IiwgImFkZExheWVyIiwgInNldFN0eWxlIiwgInNldElkIiwgImdldFNvdXJjZSIsICJhZGRGZWF0dXJlIiwgImJ1aWxkaW5nIiwgInZpbGxhZ2UiLCAiYmx1ciIsICJ0aGF0IiwgIm1hcEVsZW1lbnQiLCAiZ2V0VGFyZ2V0RWxlbWVudCIsICJyZW1vdmVFdmVudExpc3RlbmVyIiwgImZvdW5kIiwgImdldExheWVycyIsICJDb250cm9sIiwgIlN0eWxlIiwgImltYWdlIiwgIkljb24iLCAic2NhbGUiLCAic3JjIiwgIiRub21pbmF0aW0iLCAiJGh0bWwiLCAic3VwZXIiLCAiZ2V0TGF5ZXIiLCAid3JhcFgiLCAiY29vcmRpbmF0ZXMiLCAiY2FsbGJhY2siLCAiaW5pdF9FdmVudCIsICJpbml0X0V2ZW50VHlwZSIsICJFdmVudF9kZWZhdWx0IiwgIkV2ZW50VHlwZV9kZWZhdWx0IiwgIlByb3BlcnR5IiwgIkV2ZW50VHlwZV9kZWZhdWx0IiwgIkV2ZW50VHlwZV9kZWZhdWx0IiwgIm5ld0V2ZW50IiwgInRpbGUiLCAidHJhbnNmb3JtIiwgImNvbnRhaW5zIiwgIlByb3BlcnR5X2RlZmF1bHQiLCAiUHJvcGVydHlfZGVmYXVsdCIsICJjZW50cm9pZCIsICJtYXAiLCAic2NhbGUiLCAicm90YXRlIiwgImRpc3RhbmNlIiwgIm9mZnNldCIsICJjb29yZGluYXRlcyIsICJyb3RhdGUiLCAiZGlzdGFuY2UiLCAiZGVmYXVsdHMiLCAiaW5pdF9FdmVudFR5cGUiLCAiZGVmYXVsdHMiLCAidGlsZSIsICJFdmVudFR5cGVfZGVmYXVsdCIsICJpc0VtcHR5IiwgImVxdWFscyIsICJNYXBfZGVmYXVsdCIsICJFdmVudFR5cGVfZGVmYXVsdCIsICJmb3JtYXQiLCAiZ2V0IiwgInVzZXJQcm9qZWN0aW9uIiwgIndyYXBYIiwgInRpbGUiLCAib2Zmc2V0IiwgImV4dGVuZCIsICJzb3VyY2UiLCAidGlsZSIsICJzdGF0ZSIsICJUaWxlX2RlZmF1bHQiLCAiY3JlYXRlT3JVcGRhdGUiLCAiZ2V0S2V5IiwgInRpbGUiLCAiZ2V0S2V5IiwgImNyZWF0ZU9yVXBkYXRlIiwgImNyZWF0ZU9yVXBkYXRlIiwgInNjYWxlIiwgIndyYXBYIiwgImdldCIsICJ0aWxlIiwgInNjYWxlIiwgIndyYXBYIiwgIlRpbGVfZGVmYXVsdCIsICJUaWxlX2RlZmF1bHQiLCAidGlsZSIsICJ0aWxlIiwgImNhY2hlIiwgImdldEtleSIsICJUaWxlX2RlZmF1bHQiLCAieiIsICJ4IiwgInkiLCAicGl4ZWxSYXRpbyIsICJyZW5kZXIiLCAiZ2V0IiwgImluaXRfTGF5ZXIiLCAiTGF5ZXJfZGVmYXVsdCIsICJ0aWxlIiwgIlRpbGVfZGVmYXVsdCIsICJ0bXBFeHRlbnQiLCAiZHgiLCAiZHkiLCAiaSIsICJlcXVhbHMiLCAidGlsZVNvdXJjZSIsICJmcmFtZVN0YXRlIiwgIlRpbGVfZGVmYXVsdCIsICJpbml0X1ZlY3RvciIsICJpbml0X3N0eWxlIiwgIlZlY3Rvcl9kZWZhdWx0IiwgIlRpbGVfZGVmYXVsdCIsICJNYXBfZGVmYXVsdCIsICJHZW9jb2RlciIsICJsYXQiLCAibG9uIl0KfQo=
